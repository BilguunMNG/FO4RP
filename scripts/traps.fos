// Traps by Jonathan Joestar for FO4RP

#include "_macros.fos"
#include "_colors.fos"
#include "scripting_object.fos"

import Lookup@ getClassesLookup() from "scripting_objects_lookup";

import void HookHoldAttack( Critter@ target, uint8 hardness ) from "handcuffs";
import void CriticallyInjureCritter( Critter& cr, uint dmg, uint dmgType, uint8 dir, uint attackerId, uint hitLocation ) from "combat";

void registerTraps()
{
	getClassesLookup().appendScriptingObjects(DeactivatedTrap());
	getClassesLookup().appendScriptingObjects(ActiveTrap());
}

class DeactivatedTrap : GenericObject
{

	bool itemUse(Item& item, Critter& crit, Critter@ onCritter, Item@ onItem, Scenery@ onScenery)	
	{
		Item@ handItem = _CritGetItemHand(crit);
		if( item.Accessory != ACCESSORY_CRITTER || (valid(handItem) && handItem.Id != item.Id))
		{
			crit.Say(SAY_NETMSG, "Чтобы разложить капкан тот должен находиться у вас в руках.");
			return true;
		}
		
		Map@ map = crit.GetMap();
		
		if(!valid(map))
		{
			return true;
		}
		
		if(valid(map.GetItem(crit.HexX, crit.HexY, PID_TRAP_ACTIVE)))
		{
			crit.Say(SAY_NETMSG, "Вы не можете установить капкан туда где уже есть один.");
			return true;
		}
		
		int roll = Random(0, 100);
		int skill = crit.Param[SK_TRAPS];
		int hardness = 0;
		
		if(skill <= 100)
		{
			if(roll > skill)
			{
				CriticallyInjureCritter( crit, Random(30, 60), DAMAGE_NORMAL, crit.Dir, 0, Random(0, 1) == 0 ? HIT_LOCATION_LEFT_ARM : HIT_LOCATION_RIGHT_ARM);
				crit.Say(SAY_NETMSG, "Ваша рука попала в ваш же капкан.");
				return true;
			}
		}
		else if(skill <= 200)
		{
			if(roll < skill - 100)
			{
				hardness = Random(10, 20);
			}
		}
		else
		{
			if(roll < skill - 200)
			{
				hardness = Random(30, 60);
			}
		}
		
		DeleteItem(item);
		item.Update();
		
		Item@ activeTrap = map.AddItem( crit.HexX, crit.HexY, PID_TRAP_ACTIVE, 1);
		
		activeTrap.Val0 = hardness;	
		activeTrap.Val1 = skill;
		
		crit.Say(SAY_EMOTE, "Устанавливает капкан");
		
		return true;
	}	
	
	array<int> getProtoIds()
	{
		array<int> protoIds = {PID_TRAP_DEACTIVATED};
		return protoIds;
	}
}

class ActiveTrap : GenericObject
{

	bool itemSkillUse(Item& item, Critter& crit, int skill)
	{
		Map@ map = crit.GetMap();
		Item@ deactivatedTrap = map.AddItem( item.HexX, item.HexY, PID_TRAP_DEACTIVATED, 1);
		map.SetText(item.HexX, item.HexY, COLOR_LGRAY, "::щелк::");
		
		DeleteItem(item);
		item.Update();
		
		return true;
	}
	
	void itemWalk(Item& item, Critter& crit, bool entered, uint8 dir)
	{

		if(entered)
		{
			crit.Wait(0);
			
			int hardness = item.Val0;
			int skill = item.Val1;
			
			if(Random(0, 100 + (crit.Param[ST_PERCEPTION] * 10)) > Random(0, 100 + (skill / 3)))
			{
				crit.Say(SAY_NETMSG, "Вы чуть было не наступили в капкан, но вовремя заметили его.");
				return;
			}
			
			crit.Say(SAY_EMOTE, "Наступает в капкан");
			Map@ map = crit.GetMap();

			if(hardness == 0 && Random(0, 2) == 0)
			{
				map.SetText(item.HexX, item.HexY, COLOR_LGRAY, "::кряк::");
			}
			else
			{
				CriticallyInjureCritter( crit, Random(30, 60), DAMAGE_NORMAL, dir, 0, Random(0, 1) == 0 ? HIT_LOCATION_LEFT_LEG : HIT_LOCATION_RIGHT_LEG);
				
				if(hardness > 0)
				{
					HookHoldAttack( crit, hardness );
				}
				
				map.SetText(item.HexX, item.HexY, COLOR_LGRAY, "::щелк::");
			}
			
			Item@ deactivatedTrap = map.AddItem( item.HexX, item.HexY, PID_TRAP_DEACTIVATED, 1);
			
			DeleteItem(item);
			item.Update();
		}	
	}
	
	array<int> getProtoIds()
	{
		array<int> protoIds = {PID_TRAP_ACTIVE};
		return protoIds;
	}
}