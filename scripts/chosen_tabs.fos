#include "_macros.fos"
#include "_client_defines.fos"
#include "_colors.fos"
#include "_msgstr.fos"
#include "sprite.fos"
#include "gathering_h.fos"

import int GUI_GetActiveMainScreen() from "client_gui";
import int GUI_GetActiveScreen() from "client_gui";
import int GetIniValue( string& iniKey, int defaultValue ) from "ini_parser";
import int[] @ GetIniValues2( string & iniKey, int[] @ defaultValues ) from "ini_parser";

#define TAB_SPRITE_LENGTH    ( 127 )

/* TODO: 
	1) Вынести модели поведения каждого таймаута и стата в отдельную для него логику (т.н. "mutual-изация").
	2) Присобачить ГМ-функционал к render_iface(), что бы можно было на лету из под ГМки открывать микро-менюшки, по типу текущих плашек состояний.
	3) Настраиваемость списка отобржаемых плашек на стороне клиента.
*/


Sprite TabPic;
int[]  Position;
int    StepX;
int    StepY;
bool   LevelUp;
int    CurTab;

void InitChosenTabs() // Export
{
    TabPic.LoadByIni( "ChosenTabPic", PT_ART_INTRFACE );
    Position = GetIniValues2( "ChosenTab", null );
    StepX = GetIniValue( "ChosenTabStepX", 0 );
    StepY = GetIniValue( "ChosenTabStepY", 5 );
    if( StepX != 0 )
        StepX += TabPic.Width;
    if( StepY != 0 )
        StepY += TabPic.Height;
    LevelUp = false;
    CurTab = 0;
}

void SetChosenTabLevelUp( bool enable ) //exported
{
	LevelUp = enable;
}

void DrawChosenTabs() // Export
{
    if( GUI_GetActiveMainScreen() != CLIENT_MAIN_SCREEN_GAME )
        return;

    CritterCl@ chosen = GetChosen();
    if( not valid( chosen ) )
        return;
	
	if( __f4Pressed || __ShowF1Help )
		return;

    if( LevelUp && ( GUI_GetActiveMainScreen() != CLIENT_MAIN_SCREEN_GAME ||
                     GUI_GetActiveScreen() == CLIENT_SCREEN_CHARACTER || GUI_GetActiveScreen() == CLIENT_SCREEN_PERK ) )
        LevelUp = false;

    CurTab = 0;

	bool isTester = chosen.Param[ QST_GAMEMODE ] == GAME_TEST;
	
    showTab( "Инвиз", chosen.Param[ QST_INVIS ] != 0, COLOR_LBLUE );
		
	showAim( chosen.Param[CR_AUTO_AIM] );
	
    showTab( GetMsgStr( TEXTMSG_GAME, STR_ADDICTED_TITLE ), chosen.IsAddicted(), COLOR_DRED );
    showTab( GetMsgStr( TEXTMSG_GAME, STR_INJURED_TITLE ), chosen.IsInjured(), COLOR_DRED );

    showTab( GetMsgStr( TEXTMSG_GAME, STR_HEAVY_DMG_TITLE ), FLAG( chosen.Stat[ ST_CRSTATUS ], CR_STATUS_HEAVY_DMG ), COLOR_DRED );
    showTab( GetMsgStr( TEXTMSG_GAME, STR_BULLET_OVER_TITLE ), FLAG( chosen.Stat[ ST_CRSTATUS ], CR_STATUS_BULLET_OVER ), COLOR_DRED );

	showTab( "Загрязнение", chosen.Param[ CR_DIRTINESS ], 100, 20, isTester );
	
    showParalysis( chosen.Stat[ ST_PARALYSIS_LEVEL ], chosen.Param[CR_VAL9], isTester );
		
    showTab( "Кровотечение", chosen.Stat[ ST_BLEED ], chosen.Stat[ST_MAX_LIFE], 10, isTester );
    showTab( "Кровопотеря", chosen.Param[ BP_BLOOD_LOSS ], chosen.Stat[ST_MAX_LIFE] - __DeadHitPoints, 15, isTester );

    showTab( "Болезнь", chosen.Stat[ ST_TOXIC ], 100, 15, isTester );

    showTab( "Отравление", chosen.Stat[ ST_POISONING_LEVEL ], 100, 10, isTester );
    showTab( "Радиация", chosen.Stat[ ST_RADIATION_LEVEL ] / 10, 100, 20, isTester );

    showTab( "Удушье", 100 - chosen.Stat[ ST_DYSPNEA ], 100, 5, isTester );
    showTab( "Голод", 100 - chosen.Stat[ ST_HUNGER ], 100, 15, isTester );
    showTab( "Жажда", 100 - chosen.Stat[ ST_THIRST ], 100, 15, isTester );
	showTab( "Опьянение", chosen.Stat[ ST_DRUNK ], 100, 20, isTester );
	
	showWeight( chosen.Param[ CR_ITEMS_WEIGHT ], chosen.Stat[ ST_CARRY_WEIGHT ], 5, isTester );
	showVolume( chosen.ItemsVolume(), 1000, 50, isTester );

    showTab( GetMsgStr( TEXTMSG_GAME, STR_LEVELUP_TITLE ), LevelUp, COLOR_DGREEN );

    showTab( GetMsgStr( TEXTMSG_GAME, STR_HIDEMODE_TITLE ), chosen.Mode[ MODE_HIDE ] != 0, COLOR_DGREEN );
    showTab( GetMsgStr( TEXTMSG_GAME, STR_RELOAD_TITLE ), chosen.Mode[ MODE_NO_RUN ] == 2, COLOR_DGREEN );

    showTabTimeout( "Переход", chosen.Timeout[ TO_TRANSFER ], 15, isTester );
    showTabTimeout( "Действие", chosen.Timeout[ TO_SK_STEAL ], 6, isTester );
	showTabTimeout( "Взлом", chosen.Timeout[ TO_SK_LOCKPICK ], 6, isTester, true );
    showTabTimeout( "Лечение", chosen.Timeout[ TO_SK_FIRST_AID ], 6, isTester, true );
    showTabTimeout( "Доктор", chosen.Timeout[ TO_SK_DOCTOR ], 6, isTester, true );
	showTabTimeout( "Ремонт", chosen.Timeout[ TO_SK_REPAIR ], 6, isTester, true );
	showTabTimeout( "Наука", chosen.Timeout[ TO_SK_SCIENCE ], 6, isTester, true );
	
	showTabTimeout( "Бой", chosen.Timeout[ TO_BATTLE ], 6, isTester, true );
	
	uint timeout_limit = ( chosen.Stat[ST_ENDURANCE] * PHASE_TIMEOUT_RATE ) + PHASE_TIMEOUT_BASE;
	int timeout = CLAMP( timeout_limit, PHASE_TIMEOUT_MIN, PHASE_TIMEOUT_MAX);
	showTabTimeout( "Усталость", chosen.Timeout[ TO_TIREDNESS ], timeout, isTester );
		
	showCooldown( chosen.Timeout[ TO_STEALING ], 90, 120, isTester, true );
		
    if( IsTurnBased() && chosen.IsTurnBasedTurn() )
        DrawTab( GetMsgStr( TEXTMSG_GAME, STR_YOU_TURN_TITLE ), GetTurnBasedTime() / 1000, COLOR_DGREEN );

    if( IsTurnBased() && !chosen.IsTurnBasedTurn() )
        DrawTab( GetMsgStr( TEXTMSG_GAME, STR_TURN_BASED_TITLE ), COLOR_DGREEN );
}

void DrawTab( string@ text, uint color )
{
    uint8 tempTab = CurTab;

	uint8 width = __ScreenWidth / StepX;
	uint8 tx = CurTab % width;
	uint8 ty = CurTab / width;
	
    TabPic.Draw( Position[ 0 ] + tx * StepX, Position[ 1 ] + ty * 25 );
    DrawText( text, Position[ 0 ] + tx * StepX, Position[ 1 ] + ty * 25, TabPic.Width, TabPic.Height, color, FONT_FALLOUT, FT_CENTERXY );
    CurTab++;
}

void DrawTab( string@ text, int value, uint color )
{

    bool offsetY = false;

    if( Position[ 0 ] + StepX * ( CurTab + 1 ) > __ScreenWidth )
    {
        offsetY = true;
    }

    uint8 tempTab = CurTab;

    if( offsetY )
    {
        tempTab -= __ScreenWidth / TAB_SPRITE_LENGTH;
    }

    uint16 time = value / __TimeMultiplier + 1;  // pm added

    text = ReplaceText( text, "VALUE", time );   // pm edit
    TabPic.Draw( Position[ 0 ] + tempTab * StepX, Position[ 1 ] + tempTab * StepY + ( offsetY ? 25 : 0 ) );
    DrawText( text, Position[ 0 ] + tempTab * StepX, Position[ 1 ] + tempTab * StepY + ( offsetY ? 25 : 0 ), TabPic.Width, TabPic.Height, color, FONT_FALLOUT, FT_CENTERXY );
    CurTab++;
}

void showTab( string name, int value, int max, int min_to_show = 0, bool showAnyway = false, bool isPositive = true )
{
	value = CLAMP( 100 * value / max, 0, 100 );
	if( value < min_to_show && !showAnyway ) return;
	
	uint color = __GetGradient( COLOR_GREEN, COLOR_DRED, isPositive ? ( 100 - value ) : value );
	DrawTab( name + " [" + CLAMP( value, 0, 100 ) +  "%]", color );
}

void showTabTimeout( string name, int value, int max, bool showAnyway = false, bool showGray = false )
{
	value = value / __TimeMultiplier;
	if( value <= 0 && !showAnyway ) return;
	
	uint color = showGray ? COLOR_LGRAY : 
	( value > max ? COLOR_DRED : 
	__GetGradient( COLOR_GREEN, COLOR_DRED, 100 * ( max - CLAMP( value, 0, max ) ) / max ) );
	
	DrawTab( name + " [" + value + "]", color );
}

void showCooldown( int value, int min_to_show = 0, int max = 0, bool showAnyway = false, bool showGray = false )
{
	value = value / __TimeMultiplier;
	if( value < min_to_show && !showAnyway ) return;
	
	DrawTab( "КД [" + ( value / 60 ) + ":" + ( value % 60 ) + "]", value >= max ? COLOR_LGRAY : __GetGradient( COLOR_GREEN, COLOR_DRED, 100 * ( 60 - CLAMP( value, 0, 60 ) ) / 60 ) );
}

void showTab( string name, bool flag, uint color )
{
	if( flag )
		DrawTab( name, color );
}

void showAim( int value )
{
	if( value == 0 ) return;
	
	string text = "";
	switch( value )
	{
		//case( HIT_LOCATION_NONE ): text = "рандом"; HIT_LOCATION_NONE; break;
		case( HIT_LOCATION_HEAD ): text = "Голова"; break;
		case( HIT_LOCATION_LEFT_ARM ): text = "Л. Рука"; break;
		case( HIT_LOCATION_TORSO ): text = "Торс"; break;
		case( HIT_LOCATION_RIGHT_ARM ): text = "Рука П."; break;
		case( HIT_LOCATION_LEFT_LEG ): text = "Л. Нога"; break;
		case( HIT_LOCATION_GROIN ): text = "Живот"; break;
		case( HIT_LOCATION_RIGHT_LEG ): text = "Нога П."; break;
	}
	if( text.length() > 1 )
		DrawTab( "Прицел: " + text, COLOR_LGREEN );
}

void showTemp( int value, bool showAnyway = false )
{
	if( value == 0 && !showAnyway ) return;
	
	if( value > 0 )
		showTab( "Жар", value, 100, 0, showAnyway );
	else
		showTab( "Холод", -value, 100, 0, showAnyway );
}

void showExp( int fitness, int relaxed, int min_to_show = 0, bool showAnyway = false )
{
	fitness = CLAMP( fitness, 1, 999 );
	relaxed = CLAMP( relaxed, 0, fitness );
	if( fitness > min_to_show || showAnyway )
		DrawTab( "Опыт [" + ( relaxed > 0 ? relaxed + "/" : "" ) + fitness + "]", __GetGradient( COLOR_GREEN, COLOR_DRED, 100 * relaxed / fitness ) );		
}

void showParalysis( int value, int fastMode, bool showAnyway = false )
{
	if( ( fastMode == 0 && value > 0 ) || showAnyway ) 
		DrawTab( "Паралич [" + value + "%]", __GetGradient( COLOR_GREEN, COLOR_DRED, 100 - value ) );
}

void showWeight( int value, int max, int min_to_show = 0, bool showAnyway = false )
{
	int weight_percentage = 100 * value / max; //Целочисленное, в процентах.
	if( weight_percentage >= min_to_show || showAnyway )
        DrawTab( "Вес [" + weight_percentage + "%]", __GetGradient( COLOR_GREEN, COLOR_DRED, 100 - CLAMP( weight_percentage, 0, 100 ) ) );
}

void showVolume( int value, int max, int min_to_show = 0, bool showAnyway = false )
{
	int volume_percentage = 100 * value / max;
	if( volume_percentage > min_to_show || showAnyway )
        DrawTab( "Объём [" + volume_percentage + "%]", __GetGradient( COLOR_GREEN, COLOR_DRED, 100 - CLAMP( volume_percentage, 0, 100 ) ) );
}