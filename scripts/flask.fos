// Author: Anuri

#include "_utils.fos"
#include "_ltp.fos"
#include "STAT_MODS_H.fos"

#define REMAINING_USES 				Val0
#define DNA							Val1
#define EXTRA_WEIGHT				Val2
#define TASTE						Val8

import void ProccessDrink( Critter& cr, Critter& target, Item& item ) from "food";

const uint16[] Flasks = { PID_WATER_FLASK, PID_MilkBrhm, PID_FLASKB, PID_FLASK_FULL };

bool FlaskCheck( Critter& cr, Item@ drink, Item@ flask )
{
	Map@ map = cr.GetMap(); 
    if( !valid( map ) ) { return false;
    }
	
    if( !valid( drink ) || !valid( flask ) ) { return false;
    }
	
	uint16 flaskPid = flask.GetProtoId();
	if( Flasks.find( flaskPid ) == -1 ) { return false;
    }
	
	uint16 drinkPid = drink.GetProtoId();
	if( flask.DNA != 0 && flask.DNA != drinkPid ) { cr.Say( SAY_NETMSG, "|0xFFFF00 ‘л€га заполнена чем-то другим." ); return false;
	}
	
	//if( flask.REMAINING_USES != 0 ) { cr.Say( SAY_NETMSG, "|0xFFFF00 ‘л€га чем-то уже заполнена." ); return false;
	//}
	
	if( find_opened_drinks( drink ) ) { //search.fos
		cr.Say( SAY_EMOTE, "Ќаполн€ет фл€гу" );
		
		if( flaskPid == PID_FLASKB ) {
			flask.ChangeProto( PID_FLASK_FULL );
			flask.Update();
		}
		
		start_pouring( cr, drink, flask );
		
		/*flask.DNA = drink.GetProtoId();
		flask.REMAINING_USES = drink.REMAINING_USES;
		flask.EXTRA_WEIGHT = flask.REMAINING_USES * 100;
		_SubItem( drink, 1 );
		cr.AddItem( PID_BOTTLE_GLASS, 1 );*/

	}
	return true;
}

bool DrinkFlask( Critter& cr, Item& flask )
{
	Map@ map = cr.GetMap(); 
	if( !valid( map ) || !valid( flask ) ) { return false;
    }
	
	if( flask.CritSlot != SLOT_HAND1 ) { cr.Say( SAY_NETMSG, "|0xFFFF00 ¬озьмите фл€жку в руку." ); return false;
	}
	
	if( flask.REMAINING_USES <= 0 ) { cr.Say( SAY_NETMSG, "|0xFFFF00 ‘л€га пуста." ); return false;
	}
	
	flask.REMAINING_USES --;
	flask.EXTRA_WEIGHT = flask.REMAINING_USES * 100;
	
	cr.Say( SAY_EMOTE_ON_HEAD, "ѕьет из фл€ги" );
	
	Item@ consumedDrink = cr.AddItem( flask.DNA, 1 );
	consumedDrink.REMAINING_USES = 2;
	ProccessDrink( cr, cr, consumedDrink );
	
	_SubItem( consumedDrink, 1 );
	
	if( flask.REMAINING_USES == 0 ) { 
		flask.DNA = 0;
		flask.EXTRA_WEIGHT = 0;
		if( flask.GetProtoId() == PID_FLASK_FULL ) {
			flask.ChangeProto( PID_FLASKB );
		}
	}
	
	flask.Update();
	return true;
}

bool PourFlask( Critter& cr, Item& flask )
{
	Map@ map = cr.GetMap(); 
	if( !valid( map ) || !valid( flask ) ) { return false;
    }
	
	if( flask.REMAINING_USES <= 0) { cr.Say( SAY_NETMSG, "|0xFFFF00 ‘л€га пуста." ); return false;
	}
	
	flask.REMAINING_USES = 0;
	flask.EXTRA_WEIGHT = 0;
	flask.DNA = 0;
	
	cr.Say(SAY_EMOTE, "¬ыливает фл€гу" );
	map.PlaySound( "splash.ogg", cr.HexX, cr.HexY, 5 );
	
	if( flask.GetProtoId() == PID_FLASK_FULL ) {
		flask.ChangeProto( PID_FLASKB );
	}
	
	flask.Update();
	return true;
}

bool ltp_inited = false;
void ltp_init()
{
	LTPREG( LTP_POURING, process_pouring )
	ltp_inited = true;
}

bool start_pouring( Critter& cr, Item& drink, Item& flask )
{
	if(!ltp_inited) { 
		ltp_init();
	}
	
	Map@ map = cr.GetMap();
	
	if( valid( flask ) ) {
		
		if( flask.REMAINING_USES == flask.Proto.Partial_Item ) { cr.Say( SAY_NETMSG, "|0xFFFF00 ‘л€га уже заполнена." ); return false;
		}

		uint hit_pause = ACTION_PAUSE_BASE - (cr.Stat[ST_AGILITY] * ACTION_PAUSE_BONUS_RATE );
		uint action_pause = CLAMP( hit_pause, ACTION_PAUSE_MIN, ACTION_PAUSE_MAX );
		
		map.PlaySound( "homebrew_pouring.ogg", cr.HexX, cr.HexY, 5 );
		
		CreateTimeEvent( AFTER( REAL_MS( 1000 ) ), "e_TiredenessTimeout", cr.Id, true);
		
		cr.SetAnims( COND_LIFE, 0, ANIM2_WINDUP_UNARMED );
		
		StartProcess( cr, LTP_POURING, 0, drink.Id, flask.Id, action_pause );
		
		return true;
	}
	return false;
}

uint process_pouring( Critter@ cr, int& param0, int& param1, int& param2 )
{
    LTPROCESS( cr, param0, LTP_POURING )
	
	uint hit_pause = ACTION_PAUSE_BASE - ( cr.Stat[ST_AGILITY] * ACTION_PAUSE_BONUS_RATE );
	uint action_pause = CLAMP( hit_pause, ACTION_PAUSE_MIN, ACTION_PAUSE_MAX );
	
	Item@ drink = GetItem( param1 );
  	Item@ flask = GetItem( param2 );
	
  	if( valid( flask ) ) {
		
		if( drink.REMAINING_USES == 0 ) {
			cr.Say( SAY_NETMSG, "|0xFFFF00 Ѕутылка опустела." );
			_SubItem( drink, 1 );
			cr.AddItem( PID_BOTTLE_GLASS, 1 );
			
			cr.SetAnims(COND_LIFE, 0, ANIM2_IDLE);
			
			return 0;
		}
		
		Map@ map = cr.GetMap();
		map.PlaySound( "homebrew_pouring.ogg", cr.HexX, cr.HexY, 5 );
			
		drink.REMAINING_USES --;
		flask.REMAINING_USES ++;
			
		drink.EXTRA_WEIGHT = drink.REMAINING_USES * 100;
		flask.EXTRA_WEIGHT = flask.REMAINING_USES * 100;
			
		drink.Update();
		flask.Update();
			
		flask.DNA = drink.GetProtoId();

		CreateTimeEvent( AFTER( REAL_MS( 1000 ) ), "e_TiredenessTimeout", cr.Id, true);
		
		if( flask.Proto.Partial_Item - flask.REMAINING_USES == 0 ) {
			cr.Say( SAY_NETMSG, "|0xFFFF00 ¬ы наполнили фл€гу." );
			
			cr.SetAnims(COND_LIFE, 0, ANIM2_IDLE);
			
			return 0;
		}
		
		return action_pause;
	}
	
	cr.SetAnims(COND_LIFE, 0, ANIM2_IDLE);
	
	return 0;
}

uint e_TiredenessTimeout(uint[]@ values)
{
	Critter@ cr = GetCritter( values[0] ); 
	uint fatigue_per_action = ACTION_FATIGUE_BASE - ( cr.Stat[ST_ENDURANCE] * ACTION_FATIGUE_RATE );
	uint fatigue = CLAMP( fatigue_per_action, ACTION_FATIGUE_MIN, ACTION_FATIGUE_MAX);
	cr.TimeoutBase[ TO_TIREDNESS ] = __FullSecond + cr.Timeout[ TO_TIREDNESS ] + REAL_SECOND( fatigue );
	return 0;
}