// minutils.fos
// Uses an advanced header file. Requires "mutual_h.fos" to work.
// Start by binding your new module to corresponding section in "scripts.fos".
// Either use "server bind" or "client bind", or both - depending on your needs.

#ifndef MINIUTILS_MODULE
#define MINIUTILS_MODULE

#include "miniutils_h.fos"
// #define YOUR_DEFINES

int GetGvar(uint gvar)
{
    GameVar@ var = GetGlobalVar(gvar);
    if(valid(var))
        return var.GetValue();
    else
        Log("GVar " + gvar + " not valid");
    return -1;
	// return var.GetValue();
}

/**
 * Wrapper function for setting the value of a GVAR (Global variable).
 * @param gvar Target GVAR.
 * @param value Value to set.
 */
void SetGvar(uint gvar, uint value)
{
    GameVar@ var = GetGlobalVar(gvar);
    if(valid(var))
        var = value;
    else
        Log("GVar " + gvar + " not valid");
	// var = value;
}


//
// PData
// Personal data attached to specific Location / Map / Critter / Item

// used internally, do NOT change enum name
/* enum PDataType
{
    PDataLoc,
    PDataMap,
    PDataCr,
    PDataIt
};

string PDataString(PDataType type)
{
    string result = "";

    if(EnumContains("PDataType", type))
    {
        array<string@> names;
        array<int>     values;
        uint           count = GetEnum("PDataType", names, values);
        for(uint e = 0; e < count; e++)
        {
            if(values[e] == type)
                return(names[e]);
        }
    }

    return("");
};
 */
//
// *PData() - *AnyData() wrappers
// none of them should be exported, ever
//
/* bool IsPData(PDataType type, uint id)
{
    string prefix = PDataString(type);
    if(prefix.length() == 0 || id == 0)
        return(false);

    return(IsAnyData(prefix + ":" + id));
}

bool GetPData(PDataType type, uint id, array<uint8>& raw)
{
    string prefix = PDataString(type);
    if(prefix.length() == 0 || id == 0)
        return(false);

    return(GetAnyData(prefix + ":" + id, raw));
}

bool SetPData(PDataType type, uint id, array<uint8>& raw)
{
    string prefix = PDataString(type);
    if(prefix.length() == 0 || id == 0)
        return(false);

    if(SetAnyData(prefix + ":" + id, raw))
    {
        array<uint> list;
        bool        add = true;
        if(IsAnyData(prefix) && GetAnyData(prefix, list))
        {
            if(list.find(id) >= 0)
                add = false;
        }

        if(add)
        {
            list.insertLast(id);
            list.sortAsc();
        }

        SetAnyData(prefix, list);

        return(true);
    }

    return(false);
}

bool UnsetPData(PDataType type, uint id)
{
    string prefix = PDataString(type);
    if(prefix.length() == 0 || id == 0)
        return(false);

    EraseAnyData(prefix + ":" + id);

    array<uint> list;
    if(IsAnyData(prefix) && GetAnyData(prefix, list))
    {
        int idx = -1;
        if((idx = list.find(id)) >= 0)
            list.removeAt(idx);
    }

    if(list.length() > 0)
        SetAnyData(prefix, list);
    else
        EraseAnyData(prefix);

    return(true);
}

void StartPersonalDataCleanup()
{
    CreateTimeEvent(AFTER(REAL_SECOND(1)), "utils@e_CleanupPData", false);
}

uint e_CleanupPData(array<uint>@)
{
    array<string>  pdataName;
    array<int>     pdataType;

    array<string@> names;
    array<int>     values;
    uint           count = GetEnum("PDataType", names, values);
    for(uint e = 0; e < count; e++)
    {
        if(IsAnyData(names[e]))
        {
            pdataName.insertLast(names[e]);
            pdataType.insertLast(values[e]);
        }
    }

    for(uint d = 0, dLen = pdataName.length(); d < dLen; d++)
    {
        array<uint> list;
        if(IsAnyData(pdataName[d]) && GetAnyData(pdataName[d], list))
        {
            for(uint l = 0, len = list.length(); l < len; l++)
            {
                bool   exists = true;
                string what = "something";

                switch(pdataType[d])
                {
                case PDataLoc:
                    exists = valid(GetLocation(list[l]));
                    what = "location";
                    break;
                case PDataMap:
                    exists = valid(GetMap(list[l]));
                    what = "map";
                    break;
                case PDataCr:
                    if(list[l] >= NPC_BASE_ID)
                    {
                        exists = valid(GetCritter(list[l]));
                        what = "npc";
                    }
                    else
                    {
                        exists = valid(GetPlayerName(list[l]));
                        what = "player";
                    }
                    break;
                case PDataIt:
                    exists = valid(GetItem(list[l]));
                    what = "item";
                }

                if(!exists)
                {
                    Log("Removing personal data for " + what + "<" + list[l] + ">");
                    UnsetPData(PDataType(pdataType[d]), list[l]);
                }
            }
        }
    }

    #ifdef __DEBUG__
    return(REAL_MINUTE(1));
    #endif
    #ifndef __DEBUG__
    return(REAL_MINUTE(10));
    #endif
}

bool IsPersonalData(PDataType type, uint id, string& name)
{
    array<uint8> dataRaw;

    if(IsPData(type, id) && GetPData(type, id, dataRaw))
    {
        array<string> dataNames;

        Buffer@       buffer = NewBuffer(dataRaw);
        buffer >> dataNames;

        if(dataNames.length() == 0)
            return(false);

        for(uint d = 0, dLen = dataNames.length(); d < dLen; d++)
        {
            if(dataNames[d] == name)
                return(true);
        }
    }

    return(false);
}

bool GetPersonalData(PDataType type, uint id, string& name, array<uint8>& data)
{
    array<uint8> dataRaw;

    if(IsPData(type, id) && GetPData(type, id, dataRaw))
    {
        array<string>        dataNames;
        array<array<uint8> > dataValues;

        Buffer@              buffer = NewBuffer(dataRaw);
        buffer >> dataNames >> dataValues;

        if(dataNames.length() == 0 || dataValues.length() == 0)
            return(false);
        if(dataNames.length() != dataValues.length())
            return(false);

        for(uint d = 0, dLen = dataNames.length(); d < dLen; d++)
        {
            if(dataNames[d] == name)
            {
                data = dataValues[d];
                return(true);
            }
        }
    }

    return(false);
}

uint GetPersonalData(PDataType type, uint id, array<string>& outNames, array<array<uint8> >& outValues)
{
    uint         count = 0;
    array<uint8> dataRaw;

    if(IsPData(type, id) && GetPData(type, id, dataRaw))
    {
        array<string>        dataNames;
        array<array<uint8> > dataValues;

        Buffer@              buffer = NewBuffer(dataRaw);
        buffer >> dataNames >> dataValues;

        if(dataNames.length() == 0 || dataValues.length() == 0)
            return(0);
        if(dataNames.length() != dataValues.length())
            return(0);

        for(uint d = 0, dLen = dataNames.length(); d < dLen; d++)
        {
            outNames.insertLast(dataNames[d]);
            outValues.insertLast(dataValues[d]);
            count++;
        }
    }

    return(count);
}

bool SetPersonalData(PDataType type, uint id, string& name, array<uint8>& value)
{
    array<uint8>         dataRaw;
    array<string>        dataNames;
    array<array<uint8> > dataValues;

    Buffer@              buffer = null;

    bool                 added = false;

    if(IsPData(type, id) && GetPData(type, id, dataRaw))
    {
        @buffer = NewBuffer(dataRaw);
        buffer >> dataNames >> dataValues;

        if(dataNames.length() == 0 || dataValues.length() == 0)
            return(false);
        if(dataNames.length() != dataValues.length())
            return(false);

        for(uint d = 0, dLen = dataNames.length(); d < dLen; d++)
        {
            if(dataNames[d] == name)
            {
                dataValues[d] = value;
                added = true;
                break;
            }
        }
    }

    if(!added)
    {
        dataNames.insertLast(name);
        dataValues.insertLast(value);
    }

    @buffer = NewBuffer();
    buffer << dataNames << dataValues;

    return(SetPData(type, id, buffer.AsUint8()));
}

bool UnsetPersonalData(PDataType type, uint id, string& name)
{
    array<uint8> dataRaw;

    if(IsPData(type, id) && GetPData(type, id, dataRaw))
    {
        array<string>        dataNames;
        array<array<uint8> > dataValues;

        Buffer@              buffer = NewBuffer(dataRaw);
        buffer >> dataNames >> dataValues;

        if(dataNames.length() == 0 || dataValues.length() == 0)
            return(false);
        if(dataNames.length() != dataValues.length())
            return(false);

        for(uint d = 0, dLen = dataNames.length(); d < dLen; d++)
        {
            if(dataNames[d] == name)
            {
                dataNames.removeAt(d);
                dataValues.removeAt(d);
                break;
            }
        }

        if(dataNames.length() == 0 || dataValues.length() == 0)
        {
            UnsetPData(type, id);

            return(true);
        }

        @buffer = NewBuffer();
        buffer << dataNames << dataValues;

        return(SetPData(type, id, buffer.AsUint8()));
    }

    return(false);
}

bool PersonalDataAllowed(Item& item)
{
    if(item.IsStackable())
    {
        //WLog("utils", "[PersonalData] Stackable items not supported", DEBUG_WARNING);
        PrintCallstack();
        return(false);
    }

    return(true);
}

bool IsPersonalData(Location& location, string& name)
{
    return(IsPersonalData(PDataLoc, location.Id, name));
}

bool GetPersonalData(Location& location, string& name, array<uint8>& value)
{
    return(GetPersonalData(PDataLoc, location.Id, name, value));
}

uint GetPersonalData(Location& location, array<string>& names, array<array<uint8> >& values)
{
    return(GetPersonalData(PDataLoc, location.Id, names, values));
}

bool SetPersonalData(Location& location, string& name, array<uint8>& value)
{
    return(SetPersonalData(PDataLoc, location.Id, name, value));
}

bool UnsetPersonalData(Location& location, string& name)
{
    return(UnsetPersonalData(PDataLoc, location.Id, name));
}

bool IsPersonalData(Map& map, string& name)
{
    return(IsPersonalData(PDataMap, map.Id, name));
}

bool GetPersonalData(Map& map, string& name, array<uint8>& value)
{
    return(GetPersonalData(PDataMap, map.Id, name, value));
}

uint GetPersonalData(Map& map, array<string>& names, array<array<uint8> >& values)
{
    return(GetPersonalData(PDataMap, map.Id, names, values));
}

bool SetPersonalData(Map& map, string& name, array<uint8>& value)
{
    return(SetPersonalData(PDataMap, map.Id, name, value));
}

bool UnsetPersonalData(Map& map, string& name)
{
    return(UnsetPersonalData(PDataMap, map.Id, name));
}

bool IsPersonalData(Critter& critter, string& name)
{
    return(IsPersonalData(PDataCr, critter.Id, name));
}

bool GetPersonalData(Critter& critter, string& name, array<uint8>& value)
{
    return(GetPersonalData(PDataCr, critter.Id, name, value));
}

uint GetPersonalData(Critter& critter, array<string>& names, array<array<uint8> >& values)
{
    return(GetPersonalData(PDataCr, critter.Id, names, values));
}

bool SetPersonalData(Critter& critter, string& name, array<uint8>& value)
{
    return(SetPersonalData(PDataCr, critter.Id, name, value));
}

bool UnsetPersonalData(Critter& critter, string& name)
{
    return(UnsetPersonalData(PDataCr, critter.Id, name));
}

bool IsPersonalData(Item& item, string& name)
{
    if(!PersonalDataAllowed(item))
        return(false);

    return(IsPersonalData(PDataIt, item.Id, name));
}

bool GetPersonalData(Item& item, string& name, array<uint8>& value)
{
    if(!PersonalDataAllowed(item))
        return(false);

    return(GetPersonalData(PDataIt, item.Id, name, value));
}

uint GetPersonalData(Item& item, array<string>& names, array<array<uint8> >& values)
{
    if(!PersonalDataAllowed(item))
        return(0);

    return(GetPersonalData(PDataIt, item.Id, names, values));
}

bool SetPersonalData(Item& item, string& name, array<uint8>& value)
{
    if(!PersonalDataAllowed(item))
        return(false);

    return(SetPersonalData(PDataIt, item.Id, name, value));
}

bool UnsetPersonalData(Item& item, string& name)
{
    if(!PersonalDataAllowed(item))
        return(false);

    return(UnsetPersonalData(PDataIt, item.Id, name));
}
 */
/* bool FindPreferredGridApprox(Map& map, uint16& hx, uint16& hy)
{
    if(map.FindNearestGridApprox(hx, hy, true))
        return true;
    return map.FindNearestGridApprox(hx, hy, false);
}*/

/* #ifdef __DEBUG__
void pdata_item(Critter& cr, int, int pid, int count)
{
    Item@ item = cr.AddItem(pid, count);
    if(valid(item))
    {
        Buffer@ buffer = NewBuffer();
        buffer << cr.Name;
        if(SetPersonalData(item, "owner", buffer.AsUint8()))
        {
            if(IsPersonalData(item, "owner"))
            {
                array<uint8> raw;
                if(GetPersonalData(item, "owner", raw))
                {
                    string owner = "unknown";
                    @buffer = NewBuffer(raw);
                    buffer >> owner;
                    cr.Say(SAY_NETMSG, "Owner of item <" + item.Id + "> is <" + owner + ">");
                }
                else
                    cr.Say(SAY_NETMSG, "GetPersonalData fail");
            }
            else
                cr.Say(SAY_NETMSG, "IsPersonalData fail");
        }
        else
            cr.Say(SAY_NETMSG, "SetPersonalData fail");
    }
    else
        cr.Say(SAY_NETMSG, "item invalid");
}
#endif
*/

/* string IpToString(uint ip)
{
    if(ip > 0)
    {
        string result = "";

        for(uint i = 0; i < 4; i++)
            result += (i == 0 ? "" : ".") + ((ip >> (i * 8)) & 0xFF);

        return(result);
    }
    else
        return("0.0.0.0");
}
*/



/* string GetCritterName(Critter& cr)
{
    string crName = cr.Name;

    if(IsLexem(cr, "$name"))
        crName = GetLexem(cr, "$name");

    if(cr.IsNpc() && !IsLexem(cr, "$name"))
    {
        crName = "|dlgName" + cr.Id + "|";     // parsed by client_messages@in_message
    }

    return(crName);
}

void SayEx(uint8 type, Critter& target, string& text)
{
    if(type >= SAYEX_MAX)
    {
        Log("Invalid type<" + type + ">");
        return;
    }

    array<Critter@> players;
    Map@            map = target.GetMap();
    if(valid(map))
    {
        Critter@[] target_ = { target };
        map.GetCrittersSeeing(target_, true, FIND_ALL | FIND_ONLY_PLAYERS, players);
    }
    else
        players = target.GetGlobalGroup();

    uint count = players.length();
    if(count == 0)
        return;

    for(uint p = 0; p < count; p++)
    {
        if(players[p].IsPlayer())
            players[p].RunClientScript("client_messages@sayEx", type, target.Id, 0, text, null);
    }
}


void MapMessageEx(uint8 type, uint8 mode, Critter& target, string& text, uint16 hexX, uint16 hexY, uint8 delay = 150, uint color = 0, bool fade = true, int8 fromX = 0, int8 toX = 0, int8 fromY = 0, int8 toY = 0)
{
    if(type >= FLOAT_MAX)
    {
        Log("Invalid type<" + type + ">");
        return;
    }

    if(mode >= FLOAT_MODE_MAX)
    {
        Log("Invalid mode<" + mode + "> (check #1)");
        return;
    }

    if(text.length() == 0)
    {
        Log("Empty text");
        return;
    }

    Map@ map = target.GetMap();
    if(!valid(map))
        return;

    if(hexX == 0 || hexY == 0)
    {
        Log("Invalid hex hexX<" + hexX + "> hexY<" + hexY + ">");
        PrintCallstack();
        return;
    }

    array<Critter@> players;

    switch(mode)
    {
    case FLOAT_MODE_SINGLE:
        if(target.IsPlayer())
            players.insertLast(target);
        else if(target.IsNpc() && _IsFollower(target))
        {
            Critter@ master = GetMaster(target);
            if(valid(master) && master.GetMapId() == target.GetMapId())
                players.insertLast(master);
        }
        else
            return;
        break;

    case FLOAT_MODE_ALL:
    case FLOAT_MODE_AROUND:
    {
        Critter@[] target_ = { target };
        map.GetCrittersSeeing(target_, true, FIND_ALL | FIND_ONLY_PLAYERS, players);

        if(mode == FLOAT_MODE_AROUND)
        {
            for(uint c = 0, cLen = players.length(); c < cLen; c++)
            {
                if(players[c].Id == target.Id)
                {
                    players.removeAt(c);
                    break;
                }
            }
        }
    };
        break;

    default:
        Log("Invalid mode<" + mode + "> (check #2)");
    }

    if(!valid(players))
        return;

    uint count = players.length();
    if(count == 0)
        return;

    Buffer@ buff = NewBuffer();
    buff << delay << color << fade << fromX << toX << fromY << toY;

    array<int32> data = buff.AsInt32();

    for(uint p = 0; p < count; p++)
    {
        if(players[p].IsPlayer())
            players[p].RunClientScript("client_messages@map", type, hexX, hexY, text, data);
    }
}

void VerboseAction(Critter& cr, string& text)   // Export, love it, use it
{
    if(text.length() > 0)
    {
        stringReplaceText(text, "CRITTER", GetCritterName(cr));

        // uint color = COLOR_RGB( 58, 137, 133 );
        // cr.Say( SAY_VERBOSE_ACTION, "|"+color+" **"+text+"**" );

        text = "**" + text + "**";

        MapMessageEx(FLOAT_VERBOSE_ACTION, FLOAT_MODE_ALL, cr, text, cr.HexX, cr.HexY, 150, COLOR_RGB(58, 137, 133), true, -20, 20, -20, -20);
        SayEx(SAYEX_VERBOSE_ACTION, cr, text);
    }
}

void VerboseAction(Critter& cr, Critter& target, string& text)
{
    if(text.length() > 0)
    {
        stringReplaceText(text, "TARGET",  GetCritterName(target));
        VerboseAction(cr, text);
    }
}

void PrintCallstack()
{
    PrintCallstack(1);
}

void PrintCallstack(int level)
{
    level++;
    array<string@> modules;
    array<string@> names;
    array<uint>    lines;
    array<uint>    columns;
    uint           n = GetCallstack(modules, names, lines, columns);
    for(uint i = level; i < n; i++)
        Log("  " + (n - i - 1) + ") " + modules[i] + " : " + names[i] + " : " + lines[i] + "," + columns[i]);
}
 */

#endif