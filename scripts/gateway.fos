#ifndef GATEWAY
#define GATEWAY

#include "_utils.fos"
#include "gateway_h.fos"
#include "terminal_h.fos"
#include "_npc_pids.fos"
#include "_animation.fos"
#include "npc_planes_h.fos"

const string[] SoundNames = { "saber_ambient_1.ogg", "saber_ambient_2.ogg", "saber_ambient_3.ogg", "saber_ambient_4.ogg" };

void t_EnterHex( Critter& cr, Scenery& trigger, bool entered, uint8 dir, int val )
{
	if( cr.IsNpc() || isGM( cr ) ) { return; }
	
	Map@ map = cr.GetMap();
	if( !valid( map ) ) { return; }
	
	Location@ loc = map.GetLocation();
	if( !valid( loc ) ) { return; }
	
	if( entered ) {
		if( cr.Dir >= 0 && cr.Dir <= 2 ) {
			Critter@[] turrets;
			uint count = map.GetCritters( NPC_PID_LAS_TURRET, FIND_LIFE, turrets );
			if( turrets.length() < 1 ) { return; }
			
			Critter@ turret = null;
			for( uint j = 0; j < turrets.length(); j ++ ) {
				@ turret = turrets[j];
				if( turret.LASER_FENCE_GRID != 0 ) {
					break;
				}
			}

			if( val == 5 && cr.Param[ CR_THREAT_LEVEL ] == -1 ) { return; } //Не реагирует на авторизованных
			
			for( uint i = 0; i < count; i++ ) {
				uint8 dir = GetDirection( turrets[i].HexX, turrets[i].HexY, cr.HexX, cr.HexY );
				turrets[i].SetDir( dir );
			}
			
			cr.SetEvent( CRITTER_EVENT_IDLE, null );

			if( val == 4 ) {
				if( cr.CountItem( turret.SECURITY_ACCESS_CARD ) > 0 )
				{
					cr.Say( SAY_EMOTE_ON_HEAD, "показывает пропуск" );
					cr.ParamBase[ CR_THREAT_LEVEL ] = -1;
				} else {
					cr.Wait( 500 );
				}
				RunDialog( cr, turret, true );
				return;
			}
			
			if( cr.CountItem( turret.SECURITY_ACCESS_CARD ) == 0 ) {
				if( cr.ParamBase[ CR_THREAT_LEVEL ] == -1 ) {
					return;
				}
				
				if( val == 5 ) {
					for( uint i = 0; i < count; i++ ) {
						AddAttackPlane( turrets[i], 0, cr, -300 );
					}
					
					uint16 hx = 0, hy = 0;
					uint8 dir = 0;
					int entireId = turret.LASER_FENCE_GRID;
					map.GetEntireCoords( entireId, 1, hx, hy, dir );
					Item@ deathHexCheck = map.GetItem( hx, hy, PID_DEATH_HEX ); 
					if( !valid( deathHexCheck ) ) { 
						ToggleLaserFence( map, entireId );
						uint[] values = { map.Id, entireId }; 
						CreateTimeEvent( AFTER( REAL_SECOND( 60 ) ), "e_ToggleFence", values, true );
					}
					cr.ParamBase[ CR_THREAT_LEVEL ] = 1;
				} else {
					RunDialog( cr, turret, true );
					cr.Wait( 500 );
				}
			}
		}
	}
}

uint e_ToggleFence( uint[]@ values )
{
	Map@ map = GetMap( values[0] );
	int entireId = values[1];
	ToggleLaserFence( map, entireId );
	return 0;
}

void ToggleLaserFence( Map& map, int entireId )
{
	uint entires = map.CountEntire( entireId );
	uint16 hx = 0, hy = 0;
	uint8 dir = 0;
	for( uint i = 0; i < entires; i++ )  {
		map.GetEntireCoords( entireId, i, hx, hy, dir );
		
		uint distance = 2;
		uint16 laserFencePid = PID_LAZER_FENCE_NS;
		
		if( dir == 1 ) {
			distance = 5;
			laserFencePid = PID_LAZER_FENCE_WE;
		}
		
		Item@ deathHex = null;
		@deathHex = map.GetItem( hx, hy, PID_DEATH_HEX );
		uint16 tx = hx, ty = hy;
		if( !valid( deathHex ) ) { 
		
			@deathHex = map.AddItem( hx, hy, PID_DEATH_HEX, 1 );
			CheckVictims( map, hx, hy );
			deathHex.DEATH_HEX_TYPE = ANIM2_DEAD_LASER;
			
			map.MoveHexByDir( tx, ty, dir, 1 );
			if( dir == 1 ) {
				map.MoveHexByDir( tx, ty, 0, 1 );
			}
			Item@ fenceVFX = map.AddItem( tx, ty, laserFencePid, 1 );
			map.PlaySound( "saber_on.ogg" , tx, ty, 3 );
			
		} else {
			DeleteItem( deathHex );
			
			map.MoveHexByDir( tx, ty, dir, 1 );
			if( dir == 1 ) {
				map.MoveHexByDir( tx, ty, 0, 1 );
			}
			Item@ fenceVFX = map.GetItem( tx, ty, laserFencePid );
			if( valid( fenceVFX ) ) {
				DeleteItem( fenceVFX ); 
				map.PlaySound( "saber_off.ogg" , tx, ty, 3 );
			}
		}
		for( uint steps = 0; steps < distance; steps ++ ) {
			if( dir == 1 && ( steps == 1 || steps == 3 || steps == 5 ) ) {
				map.MoveHexByDir( hx, hy, 0, 1 );
			} else {
				map.MoveHexByDir( hx, hy, dir, 1 );
			}
			
			@deathHex = map.GetItem( hx, hy, PID_DEATH_HEX ); 
			if( !valid( deathHex ) ) { 
				@deathHex = map.AddItem( hx, hy, PID_DEATH_HEX, 1 );
				CheckVictims( map, hx, hy );
				deathHex.DEATH_HEX_TYPE = ANIM2_DEAD_LASER;
			} else {
				DeleteItem( deathHex );
			}
		}
	}
}

void CheckVictims( Map& map, uint16 hx, uint16 hy )
{
	Critter@[] victims; 
	map.GetCrittersHex( hx, hy, 0, FIND_LIFE_AND_KO, victims );
	if( victims.length() > 0 ) {
		for( uint j = 0; j < victims.length(); j++ ) {
			Critter@ victim = victims[ j ];
			victim.ToDead( ANIM2_DEAD_LASER, null );
			map.PlaySound( "saber_kill.ogg", victim.HexX, victim.HexY, 5 );
		}
	}
}

#endif //GATEWAY