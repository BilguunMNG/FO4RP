Critter@ getTarget( Critter& cr, int crId = 0 )
{
	Critter@ target = null;
	if( crId == 0 )
	{
		crId = cr.Id;
		@target = @cr;
	}
	else
	{
		@target = GetCritter( crId );
	}
	
	return target;
}

int SNEAK_TIMEOUT( Critter@ cr )
{
	if( !valid( cr ) ) return 0;
	
	return __FullSecond + REAL_SECOND( MAX( 34 - cr.Stat[ ST_SEQUENCE ], 3 ) );
}

void setTimeout( Critter@ cr, uint id, int value )
{
	if( !valid( cr ) ) return;
	if( cr.Timeout[ id ] < int( REAL_SECOND(value) ) )
		cr.TimeoutBase[ id ] = __FullSecond + REAL_SECOND(value);
}

bool Find( Critter@& link, int id )
{
	if( id == 0 ) return false;
	@link = GetCritter( uint( id ) );	
	return valid( link );
}

Item@[] getItemsAround( Item& target )
{
	Item@[] empty_result; //Костыль, т.к. нет нормального преобразования типов из null.

	Map@ map = GetMap( target.MapId );
	if( !valid( map ) && Warning( "Can't find items around item #" + target.Id + ", as it's at the global map.", true ) ) return empty_result;
	return getItemsAround( map, target.HexX, target.HexY );

}

Item@[] getItemsAround( Critter& target )
{
	Item@[] empty_result; //Костыль, т.к. нет нормального преобразования типов из null.

	Map@ map = target.GetMap( );
	if( !valid( map ) && Warning( "Can't find items around critter #" + target.Id + ", as it's at the global map.", true ) ) return empty_result;
	return getItemsAround( map, target.HexX, target.HexY );
}

Item@[] getItemsAround( Map& map, uint16 x, uint16 y ) //TODO: range arg
{
	Item@[] result;
	
	for( uint i = 0; i < 6; i++ )
	{
		uint16 tx = x, ty = y;
		map.MoveHexByDir( tx, ty, i, 1 );
		map.GetItems( tx, ty, result );
	}
	map.GetItems( x, y, result );
	
	return result;
}

string itemInfo( Item@ item )
{
	if( !valid( item ) )
		return "[пусто]";
	
	return "[" + item.GetProtoId() + ":" + item.GetCount() + "]";
}

string itemDesc( Item& item ) 
{
	return itemName( item ) + itemCount(item) + " #" + item.Id + " PID " + item.GetProtoId();
}

string itemName( Item& item ) { return itemName( item.GetProtoId() ); }
string itemName( uint pid )
{
	string@ name = GetItemMsgStr( pid * 100 );
	return valid( name ) ? "[ " + name + " ]" : "";
}

string getPID_name( int pid )
{
	string@ text = GetItemMsgStr( pid );
	return valid( text ) ? text : "[PID:" + pid + "]";
}

string itemCount( Item& item )
{
	if( !item.IsStackable() ) return "";

	uint count = item.GetCount();
	if( count > 1 )
		return " x" + count;
	
	return "";
}

string ItemState( Item& item, bool fullInfo = false )
{
	string info = "Объект " + ( fullInfo ? "№" + item.Id + ":" + item.GetProtoId() + " " : "" ) + "находится ";
	switch( item.Accessory )
	{
		case( ACCESSORY_NONE ): info += "в нигде (создан через ~ais)"; break;
		case( ACCESSORY_CRITTER ): info += "у криттера №" + item.CritId + " в слоте №" + item.CritSlot; break;
		case( ACCESSORY_HEX ): info += "на карте №" + item.MapId + " в позиции (" + item.HexX + ", " + item.HexY + ")"; break;
		case( ACCESSORY_CONTAINER ): info += "внутри контейнера №" + item.ContainerId; break;
		default: info += "в нигде (особый случай, опишите в #багах)"; break;
	}
	return info + ".";	
}

int ContainmentVolume( Item@ item )
{
	if( !valid( item ) ) return 0;

	Item@[] loot;
	uint volume = 0;
	uint count = item.GetItems( uint(-1), loot );
	for( uint i = 0; i < count; i++ )
		volume += loot[i].Proto.Volume * loot[i].GetCount();
	
	return volume;
}

string FullItemInfo( Item@ item )
{
	if( !valid( item ) ) return "[null]";
	
	uint count = item.GetCount();
	float weight = float( item.Proto.Weight ) / 1000;
	string info = 
		StyledText( "|", "ProtoID: ", item.GetProtoId() ) + 
		StyledText( "\n", "ID: ", item.Id ) +
		StyledText( "|", "Count: ", count ) + 
		StyledText( "\n", "Flags: ", item.Flags ) +
		StyledText( "|", "Cost: ", OneAll( item.Proto.Cost, count ) ) +
		StyledText( "\n", "Volume: ", OneAll( item.Proto.Volume, count ) ) +
		StyledText( "\n", "Weight: ", OneAll( weight, count ) ) +
		"";
		
	if( item.Proto.Deteriorable )
		info += StyledText( "\n", "Deterioration: ", item.Deterioration );
	
	if( item.Proto.Container_Volume > 0 )
		info += StyledText( "\n", "Used Space: ", ContainmentVolume( item ) + "/" + item.Proto.Container_Volume );
	
	uint8 type = item.GetType();
	if( type == ITEM_TYPE_DOOR || type == ITEM_TYPE_CONTAINER )
	{
		bool always_open = ( type == ITEM_TYPE_CONTAINER && !item.Proto.Container_Changeble );
		string state = "" +
			( FLAG( item.LockerCondition, LOCKER_ISOPEN ) ? "open " : "" ) +
			( FLAG( item.LockerCondition, LOCKER_JAMMED ) ? "jammed " : "" ) +
			( FLAG( item.LockerCondition, LOCKER_BROKEN ) ? "broken " : "" ) +
			( FLAG( item.LockerCondition, LOCKER_NOOPEN ) ? "blocked " : "" ) +
			( FLAG( item.LockerCondition, LOCKER_LOCKED ) ? "locked " : "" ) +
			( FLAG( item.LockerCondition, LOCKER_ELECTRO ) ? "electro " : "" ) +
			"";

		if( state.length() < 2 )//if( item.LockerCondition == 0 )
			state = always_open ? "always open" : "closed";

		info += StyledText( "|", "State: ", state );		
		
		if( FLAG( item.LockerCondition, LOCKER_LOCKED ) )
			info += StyledText( "\n", "Id: ", item.LockerId ) + StyledText( "\n", "Complexity: ", item.LockerComplexity );

		if( FLAG( item.LockerCondition, LOCKER_ELECTRO ) ) 
			info += StyledText( "\n", "Code: ", item.Val4 ) + StyledText( "\n", "Complexity: ", item.LockerComplexity );
	}
	return info;
}

string crInfo( Critter& cr, bool full = false )
{
	uint id = cr.Id;
	
	if( cr.IsPlayer() )
		return "#" + id + " [ " + GetPlayerName( id ) + " ]";
	
	return "#" + id + " [mob] " + ( full ? " DLG " + cr.Stat[ST_DIALOG_ID] + " PID " + cr.GetProtoId() + " BODYTYPE " + cr.StatBase[ ST_BODY_TYPE ] + " SKIN " + cr.StatBase[ ST_BASE_CRTYPE ] : "" );
}

string timeInfo()
{
	return __Day + "." + __Month + "." + __Year + " " + MakeTime( __FullSecond );
}

//Формат: "[pid:count], [pid:count]"
string enlist( Item@[] list )
{
	if( !valid( list ) ) return "[null]";

	uint len = list.length();
	if( len == 0 ) return "[empty]";
	
	string result = itemInfo( list[0] );
	for( uint i = 1; i < len; i++ )
		result += ", " + itemInfo( list[i] );
	
	return result;
}

string genderEnding( Critter& cr )
{
	switch( cr.Stat[ ST_GENDER ] )
	{
		case(0): return ""; //он
		case(1): return "а"; //онА
		case(2): return "о"; //онО
	}
	
	return "";
}