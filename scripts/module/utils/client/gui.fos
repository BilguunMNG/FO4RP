/*********Графики и интерфейсы**************/

void DrawText( string@ text, Dot@ dot, int dx, int dy ) 
{ 
	if( !valid( text ) || !valid( dot ) ) return; 
	DrawText( text, dot.x + dx, dot.y + dy, dot.color ); 
}

void DrawText( string@ text, int x, int y, Color@ color )
{
	if( !valid( text ) ) return;
	
	DrawText( text, x, y, text.length() * 10, 20, valid( color ) ? color.rgb() : COLOR_RGB( 255, 0, 0 ), FONT_FALLOUT, 0 );
}

void PhysicalDrawTextAboveHex( string@ text, int hexX, int hexY, Color@ color, uint16 type, uint id, uint16 part = 0, bool show_line = false, bool show_rect = false) {
	if( !valid( text ) ) return;

	int anchor_x = 0, anchor_y = 0;
	GetHexPos( hexX, hexY, anchor_x, anchor_y );

	int width = 0;
	int height = 0;
	int lines = 0;
	int flags = FT_BORDERED | FT_CENTERX | FT_CENTERY;
	GetTextInfo( text, 0, 0, FONT_FALLOUT, flags, width, height, lines );
	width += 4;
	height += 4;

	int half_width = width/2;
	int half_height = height/2;

	int x0 = 0, y0 = 0;
	PhysicalUI_UpsertCustom(id, type, part, anchor_x, anchor_y, width, height, x0, y0);

	int x2 = x0;
	int y2 = y0;
	x0 -= half_width;
	y0 -= half_height;

	if( x0+width < 0 || y0+height < 0 || x0 > __ScreenWidth || y0 > __ScreenHeight ) {
		return;
	}

	int diff_x = x0 - anchor_x;
	int diff_y = y0 - anchor_y;
	int abs_diff_x = ABS(diff_x);
	int abs_diff_y = ABS(diff_y);

	if(show_rect) {
		rect_solid(x0, y0, width, height, color, 0.7);
	}

	if(show_line && (abs_diff_x > half_width+5 || abs_diff_y > half_height+5) ) {
		if( abs_diff_x > abs_diff_y ) {
			if(diff_x > 0) {
				x2 -= half_width;
			} else {
				x2 += half_width;
			}
		} else {
			if(diff_y > 0) {
				y2 -= half_height;
			} else {
				y2 += half_height;
			}
		}
		line(anchor_x, anchor_y, x2, y2, color);
	}
	DrawText( text, x0, y0, width, height, valid( color ) ? color.rgb() : COLOR_RGB( 255, 0, 0 ), FONT_FALLOUT, flags );
}

void DrawTextAboveHex( string@ text, int hexX, int hexY, Color@ color, bool underline = false )
{
	if( !valid( text ) ) return;
	
	int x = 0, y = 0;
	GetHexPos( hexX, hexY, x, y ); 
	
	//string@[] lines;
	//lines = split( text, "\n" );
	
	//for( uint i = 0, l = lines.length(); i < l; i++ )
	//	DrawTextLine( lines[i], x, y + 10 - ( l - i ) * 20, color, underline );
	DrawTextLine( text, x, y + 10, color, underline );
}

void DrawTextLine( string@ text, int x, int y, Color@ color, bool underline = false )
{
	if( !valid( text ) ) return;
	
	int width = 0;
	int height = 0;
	int lines = 0;
	int flags = FT_BORDERED | FT_CENTERX;
	GetTextInfo( text, 0, 0, FONT_FALLOUT, flags, width, height, lines );

	int x0 = x - width / 2;
	int y0 = y - 10;

	//rect(x0, y0, width, height, NewColor(255, 0, 0 ));
	//rect_center(x0, y0, width, height, NewColor(0, 255, 0 ));
	
	DrawText( text, x0, y0, width, height, valid( color ) ? color.rgb() : COLOR_RGB( 255, 0, 0 ), FONT_FALLOUT, flags );
	
	if( underline )
		line( x0, y0 + 10, x0 + width, y0 + 10, NewColor( 255, 100, 100 ) );
}

void triangle( Dot@ dot, int size = 2 ) 
{ 
	if( !valid( dot ) || !valid( dot.color ) ) return;
	
	triangle( dot.x, dot.y, dot.color, size ); 
}

void triangle( int x, int y, Color color, int size = 2 )
{
	NewLine( "", color )
		.add( -size,  size )
		.add(  size,  size )
		.add(     0, -size )
		.draw( x, y, true );
}

void rect( int x, int y, int w, int h, Color color)
{
	NewLine( "", color )
		.add( 0, 0 )
		.add( w, 0 )
		.add( w, h)
		.add( 0, h)
		.draw( x, y, true );
}

void rect_solid( int x, int y, int w, int h, Color color, float alpha)
{
	uint8 alpha_byte;
	if(alpha >= 1.0) {
		alpha_byte = 0xFF;
	} else if(alpha <= 0.0) {
		alpha_byte = 0;
	} else {
		alpha_byte = uint8(alpha * 255.0);
	}
	int rgba = color.rgba(alpha_byte);

	int[]  drawData = { x, y, rgba, x + w, y, rgba, x, y + h, rgba, x + w, y + h, rgba };
	DrawPrimitive( DRAW_PRIMITIVE_TRIANGLESTRIP, drawData );
}

void rect_center( int x, int y, int w, int h, Color color)
{
	int half_w = w/2;
	int half_h = h/2;
	NewLine( "", color )
		.add( -half_w, -half_h )
		.add( half_w, -half_h )
		.add( half_w, half_h)
		.add( -half_w, half_h)
		.draw( x, y, true );
}

void line( int x1, int y1, int x2, int y2, Color color )
{
	NewLine( "", color ).add( x1, y1 ).add( x2, y2 ).draw();
}

void line( Dot@ a, Dot@ b, Color color )
{
	NewLine( "", color ).add(a).add(b).draw();
}

void DrawLine( Line@ line, int x0 = 0, int y0 = 0, float scale = 1, bool looped = false )
{
	if( !valid( line ) || !valid( line.dots ) || line.dots.length() == 0 )
		return;

	int[] drawData;
	
	for( uint i = 0, l = line.dots.length(); i <= l; i++ )
	{
		if( !looped && i == l ) break;
		
		Dot@ dot = line.dot(i%l);

		drawData.insertLast( x0 + dot.x * scale );
		drawData.insertLast( y0 + dot.y * scale );
	
		drawData.insertLast( dot.color.inherited ? line.color.rgb() : dot.color.rgb() );
	}
	
	DrawPrimitive( DRAW_PRIMITIVE_LINESTRIP, drawData );
	
	return;
}