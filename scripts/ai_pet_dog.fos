#ifndef AI_PET_DOG
#define AI_PET_DOG

#include "_utils.fos"
#include "npc_planes_h.fos"
#include "heal_h.fos"
#include "speed_h.fos"

import void unsafe_sleep( Critter& player, int isBack, int isRemote, int param2, string@ param3, int[] @ param4 ) from "general_unsafe";

void GM_PetDog( Critter& npc ) // Export
{
    npc.SetScript( "_PetDogInit" );
	npc.Say( SAY_EMOTE, "barks" );
}

void _PetDogInit( Critter& npc, bool firstTime )
{
	npc.SetEvent( CRITTER_EVENT_SHOW_CRITTER,	"_CritterLookAt" );
	npc.SetEvent( CRITTER_EVENT_HIDE_CRITTER,	"_CritterOutOfSight" );
    npc.SetEvent( CRITTER_EVENT_IDLE,			"_Idle" );
	npc.SetEvent( CRITTER_EVENT_MESSAGE,     	"_OnMessage" );
    npc.SetEvent( CRITTER_EVENT_PLANE_BEGIN,	"_PlaneBegin" );
	npc.SetEvent( CRITTER_EVENT_PLANE_END,		"_PlaneEnd" );
    npc.SetEvent( CRITTER_EVENT_DEAD,			"_MyDeath" );
    npc.SetEvent( CRITTER_EVENT_ATTACKED,		"_Attacked" );
	npc.SetEvent( CRITTER_EVENT_SMTH_DEAD,		"_FindKiller" );
	npc.SetEvent( CRITTER_EVENT_SMTH_ATTACK,	"_AssistAttack" );
	npc.SetEvent( CRITTER_EVENT_SMTH_ATTACKED,	"_AssistAttacked" );
}

void _CritterLookAt( Critter& npc, Critter& target )
{
	if( npc.IsDead() )
	{
		return;
	}
	
	if( npc.CheckEnemyInStack( target.Id ) )
	{
		if( target.IsDead() )
		{ 
			npc.EraseEnemyFromStack( target.Id );
			return;
		}
		
		npc.ErasePlane( AI_PLANE_WALK, true );
		AddAttackPlane( npc, 0, target );
		return;
	}
	
	if( Random( 0, 100 ) == 100 )
	{
		uint16 hx = npc.HexX, hy = npc.HexY;
		uint16 tx = target.HexX, ty = target.HexY;
		uint dir = GetDirection( hx, hy, tx, ty );
		npc.SetDir( dir );
	}
}

void _CritterOutOfSight( Critter& npc, Critter& target )
{
	if( npc.IsDead() )
	{
		return;
	}
	
	if( npc.CheckEnemyInStack( target.Id ) )
	{
		npc.DropPlanes();
		if( npc.IsSee( target ) )
		{
			if( target.IsDead() )
			{ 
				npc.EraseEnemyFromStack( target.Id );
				return;
			}
			
			if( !npc.CheckEnemyInStack( target.Id ) )
			{
				npc.AddEnemyInStack( target.Id );
			}
			
			AddAttackPlane( npc, 0, target );
			
		}
		else
		{
			uint16 hx = npc.HexX, hy = npc.HexY;
			uint16 tx = target.HexX, ty = target.HexY;
			int dir = GetDirection( hx, hy, tx, ty );
			AddWalkPlane( npc, AI_PLANE_ATTACK_PRIORITY - 1, target.HexX, target.HexY, dir, true, 1 );
		}
	}
}

void _Idle( Critter& npc )
{
	if( npc.IsPlayer() )
	{
		npc.SetEvent( CRITTER_EVENT_IDLE, null );
		return;
	}

	if( npc.IsDead() || npc.IsKnockout() )
	{
		return;
	}

	if( npc.IsBusy() || !npc.IsNoPlanes() )
	{
		return;
	}
	
	if( npc.Stat[ ST_FOLLOW_CRIT ] != 0 )
	{
		Critter@ follow = GetCritter( npc.Stat[ ST_FOLLOW_CRIT ] );
		if( valid( follow ) )
		{
			Map@ nMap = npc.GetMap();
			Map@ fMap = follow.GetMap();
	
			if( nMap.Id == fMap.Id )
			{
				if( npc.IsSee( follow ) )
				{
					npc.EraseTimeEvents( CTE_NPC_FOLLOW );
					npc.ModeBase[ MODE_NO_HOME ] = 1;
					npc.AddTimeEvent( "mobcontrol@follow", REAL_SECOND( 1 ), CTE_NPC_FOLLOW );
				}
			}
		}
	}
	
	uint[] index;
	if( npc.Mode[ MODE_NO_HOME ] == 1 && npc.GetTimeEvents( CTE_NPC_FOLLOW, index, null, null ) == 0 && Random( 1, 3 ) == 1 )
	{
		npc.MoveRandom();
	}
}

void _OnMessage( Critter& npc, Critter& fromCrit, int message, int value )
{
    if( npc.IsPlayer() )
	{
		return;
	}
	
    if( npc.IsDead() )
	{
		return;
	}
	
    if( npc.Param[ PET_OWNER_ID ] == 0 )
	{
		return;
	}

    if( npc.Param[ PET_OWNER_ID ] != int( fromCrit.Id ) )
	{
		return;
	}

	if( int( GetDistantion( npc.HexX, npc.HexY, fromCrit.HexX, fromCrit.HexY ) ) > ( 50 - fromCrit.Stat[ ST_SPEECH_VOLUME ] ) )
	{
		return;
	}

	switch( message )
	{
		case( MSG_PET_SIT_MESSAGE ):
		{
			NpcRefresh( npc, 0 );
			
			npc.Say( SAY_EMOTE_ON_HEAD, "obeys it's master" );
			npc.StatBase[ ST_FOLLOW_CRIT ] = 0;
			npc.SetHomePos( npc.HexX, npc.HexY, npc.Dir );
			
			if( !npc.IsKnockout() )
			{
				unsafe_sleep( npc, 1, 0, 0, null, null );
			}

			break;
		}
		case( MSG_PET_STAND_MESSAGE ):
		{
			NpcRefresh( npc, 1 );
			
			npc.Say( SAY_EMOTE_ON_HEAD, "obeys it's master" );
			npc.StatBase[ ST_FOLLOW_CRIT ] = 0;
			
			if( npc.IsKnockout() )
			{
				unsafe_sleep( npc, 1, 0, 0, null, null );
			}
			
			break;
		}
		case( MSG_PET_STAY_MESSAGE ):
		{
			NpcRefresh( npc, 0 );
			npc.StatBase[ ST_FOLLOW_CRIT ] = 0;
			npc.Say( SAY_EMOTE_ON_HEAD, "obeys it's master" );
			npc.SetHomePos( npc.HexX, npc.HexY, npc.Dir );
			
			if( npc.IsKnockout() )
			{
				unsafe_sleep( npc, 0, 0, 0, null, null );
			}
			
			break;
		}
		case( MSG_PET_FOLLOW_MESSAGE ):
		{
			NpcRefresh( npc, 1 );
			
			if( npc.IsKnockout() )
			{
				unsafe_sleep( npc, 1, 0, 0, null, null );
				npc.Wait( 1000 );
			}

			npc.Say( SAY_EMOTE_ON_HEAD, "begins to follow master" );
			npc.ModeBase[ MODE_NO_HOME ] = 1;
			npc.StatBase[ ST_FOLLOW_CRIT ] = fromCrit.Id;
			npc.AddTimeEvent( "mobcontrol@follow", REAL_SECOND( 1 ), CTE_NPC_FOLLOW );
			break;
		}
		case( MSG_PET_ATTACK_MESSAGE ):
		{
			Critter@ target = GetCritter( value );
			if( valid( target ) )
			{
				NpcRefresh( npc, 1 );

				if( npc.IsKnockout() )
				{
					unsafe_sleep( npc, 1, 0, 0, null, null );
					npc.Wait( 1000 );
				}
				
				npc.Say( SAY_EMOTE_ON_HEAD, "grnarls aggressively" );
				if( !npc.CheckEnemyInStack( target.Id ) )
				{
					npc.AddEnemyInStack( target.Id );
				}
				
				AttackOrFind( npc, target, false );
			}

			break;
		}
		case( MSG_PET_KILL_MESSAGE ):
		{
			Critter@ target = GetCritter( value );
			if( valid( target ) )
			{
				NpcRefresh( npc, 1 );
				
				npc.Say( SAY_EMOTE_ON_HEAD, "loud gnarl" );
			
				if( npc.IsKnockout() )
				{
					unsafe_sleep( npc, 1, 0, 0, null, null );
					npc.Wait( 1000 );
				}

				if( !npc.CheckEnemyInStack( target.Id ) )
				{
					npc.AddEnemyInStack( target.Id );
				}
				
				AttackOrFind( npc, target, true );
			}
			
			break;
		}
		case( MSG_PET_PROTECT_MESSAGE ):
		{
			if( value > 0 )
			{
				npc.ParamBase[ PET_PROTECT_ID ] = value;
				npc.Say( SAY_EMOTE_ON_HEAD, "starts protecting" );
				npc.ClearEnemyStack();
				npc.DropPlanes();

				if( npc.IsKnockout() )
				{
					unsafe_sleep( npc, 1, 0, 0, null, null );
					npc.Wait( 1000 );
				}
				
				npc.EraseTimeEvents( CTE_NPC_FOLLOW );
				npc.ModeBase[ MODE_NO_HOME ] = 1;
				npc.StatBase[ ST_FOLLOW_CRIT ] = npc.Param[ PET_PROTECT_ID ];
				npc.AddTimeEvent( "mobcontrol@follow", REAL_SECOND( 1 ), CTE_NPC_FOLLOW );
			}
			
			break;
		}
	}
}

int _PlaneBegin( Critter& npc, NpcPlane& plane, int reason, Critter@ someCr, Item@ someItem )
{
	if( npc.IsDead() )
	{
		return PLANE_DISCARD;
	}
	
    if( plane.Type == AI_PLANE_ATTACK )
	{
        Critter@ target = GetCritter( plane.Attack_TargId );
        if( !valid( target ) )
		{
			return PLANE_RUN_GLOBAL;
		}

        if( ( target.Stat[ ST_TEAM_ID ] == npc.Stat[ ST_TEAM_ID ] ) && target.Stat[ ST_TEAM_ID ] != 0 )
		{
			return PLANE_DISCARD; 
		}
	}
	else if( reason == REASON_FROM_SCRIPT )
	{
		return PLANE_KEEP;
	}
	
    return PLANE_RUN_GLOBAL;
}

int _PlaneEnd( Critter& npc, NpcPlane& plane, int reason, Critter@ someCr, Item@ someItem ) 
{
	if( npc.IsDead() )
	{
		return PLANE_DISCARD;
	}
	
	if( reason == REASON_GAG_CRITTER && someCr.IsNpc() )
	{
        if( someCr.ParamBase[ ST_TEAM_ID ] != npc.ParamBase[ ST_TEAM_ID ] )
		{
            return PLANE_RUN_GLOBAL;
		}
		
        if( TryLetPassage( someCr, npc ) ) 
		{
            npc.Wait( AI_DELAY );
            return PLANE_KEEP;
        }
    }
	
	return PLANE_RUN_GLOBAL;
}

void _MyDeath( Critter& npc, Critter@ killer ) 
{
	npc.DropPlanes();
    npc.ClearEnemyStack();
	npc.AddTimeEvent ( "rotting@cte_rotten", 0, CTE_ROTTEN, 0 );
}

bool _Attacked( Critter& npc, Critter& target )
{
	if( !valid( npc ) )
	{
		return false;
	}
	
	if( npc.IsDead() )
	{
		return false;
	}
	
	if( !valid( target ) )
	{
		return false;
	}
	
	if( target.IsDead() )
	{
		return false;
	}
	
	npc.EraseTimeEvents( CTE_NPC_FOLLOW );
	npc.ModeBase[ MODE_NO_HOME ] = 1;
	
	if( int( target.Id ) == npc.Param[ PET_OWNER_ID ] || int( target.Id ) == npc.Param[ PET_PROTECT_ID ] ) 
	{
        npc.EraseEnemyFromStack( target.Id );
        EraseAttackPlane( npc, target );
	}
	else
	{
		AttackOrFind( npc, target, true );
	}
	
    return true;
}

void _FindKiller( Critter& npc, Critter& fromCrit, Critter@ killer )
{
	if( !valid( killer ) )
	{
		return;
	}

	if( killer.IsDead() )
	{
		npc.EraseEnemyFromStack( killer.Id );
		return;
	}
	
	if( int( killer.Id ) == npc.Param[ PET_OWNER_ID ] || int( killer.Id ) == npc.Param[ PET_PROTECT_ID ] || killer.Id == npc.Id )
	{
		npc.EraseEnemyFromStack( killer.Id );
		return;
	}
	
    if( npc.IsPlayer() )
	{
		return;
	}
	
    if( npc.IsDead() )
	{
		return;
	}
	
	if( npc.Param[ PET_PROTECT_ID ] == int( fromCrit.Id ) || npc.Param[ PET_OWNER_ID ] == int( fromCrit.Id ) )
	{
		if( !npc.CheckEnemyInStack( killer.Id ) )
		{
			npc.AddEnemyInStack( killer.Id );
		}
		
		AttackOrFind( npc, killer, true );
	}
}

void _AssistAttack( Critter& npc, Critter& fromCr, Critter& target )
{
	if( !valid( target ) )
	{
		return;
	}
	
	if( npc.IsDead() )
	{
		return;
	}
	
	if( target.IsDead() )
	{
		return;
	}

	if( npc.Param[ PET_OWNER_ID ] == int( target.Id ) )
	{
		NpcRefresh( npc, 1 );
		npc.AddEnemyInStack( fromCr.Id );
		AttackOrFind( npc, fromCr, false );
		return;
	}

	if( npc.Param[ PET_PROTECT_ID ] == int( fromCr.Id ) || npc.Param[ PET_OWNER_ID ] == int( fromCr.Id ) )
	{
		npc.ModeBase[ MODE_NO_HOME ] = 1;
		npc.EraseTimeEvents( CTE_NPC_FOLLOW );

		npc.AddEnemyInStack( target.Id );
		AttackOrFind( npc, target, false );
	}
}

void _AssistAttacked( Critter& npc, Critter& fromCr, Critter& attacker )
{
	if( npc.IsDead() || npc.IsKnockout() )
	{
		return;
	}
	
	if( attacker.IsDead() )
	{
		return;
	}
	
	if( int( attacker.Id ) == npc.Param[ PET_OWNER_ID ] )
	{
		npc.EraseEnemyFromStack( attacker.Id );
		return;
	}
	
	if( npc.Param[ PET_PROTECT_ID ] == int( fromCr.Id ) || npc.Param[ PET_OWNER_ID ] == int( fromCr.Id ) )
	{
		npc.ModeBase[ MODE_NO_HOME ] = 1;
		npc.EraseTimeEvents( CTE_NPC_FOLLOW );
		
		npc.AddEnemyInStack( attacker.Id );
		AttackOrFind( npc, attacker, false );
	}
}

void AttackOrFind( Critter& npc, Critter& target, bool kill )
{
	if( !valid( npc ) )
	{
		return;
	}
	
	if( npc.IsDead() )
	{
		return;
	}
	
	if( !valid( target ) )
	{
		return;
	}
	
	if( target.IsDead() )
	{
		npc.EraseEnemyFromStack( target.Id );
		EraseAttackPlane( npc, target );
		return;
	}
	
	if( int( target.Id ) == npc.Param[ PET_OWNER_ID ] || int( target.Id ) == npc.Param[ PET_PROTECT_ID ] )
	{
		npc.EraseEnemyFromStack( target.Id );
		EraseAttackPlane( npc, target );
		return;
	}
	
	if( npc.IsSee( target ) )
	{
		if( kill )
		{
			AddAttackPlane( npc, 0, target );
		}
		else
		{
			uint[] values = { npc.Id, target.Id, 10 };
			CreateTimeEvent( AFTER( REAL_SECOND( 1 ) ), "ai_pet_dog@e_stopAttack", values, true );
			AddAttackPlane( npc, 0, target, -10 );
		}
	}
	else
	{
		AddWalkPlane( npc, AI_PLANE_ATTACK_PRIORITY - 1, target.HexX, target.HexY, Random( 0, 5 ), true, 1 );
	}
}

uint e_stopAttack( uint[]@ values )
{
	Critter@ npc = GetCritter( values[0] );
	if( !valid( npc ) )
	{
		return 0;
	}
	
	Critter@ target = GetCritter( values[1] );
	if( !valid( target ) )
	{
		return 0;
	}
	
	if( npc.IsDead() || target.IsDead() )
	{
		return 0;
	}
	
	if( npc.IsDead() || target.IsDead() )
	{
		return 0;
	}
	
	Map@ sMap = npc.GetMap();
	Map@ tMap = target.GetMap();
	
	if( sMap.Id != tMap.Id )
    {
		EraseAttackPlane( npc, target );
		return 0;
	}
	
	int minHp = -values[2];
	if( target.Stat[ ST_CURRENT_HP ] <= minHp )
	{
		npc.EraseEnemyFromStack( target.Id );
		EraseAttackPlane( npc, target );
		return 0;
	}
	
	return REAL_SECOND(1);
}

void NpcRefresh( Critter& npc, int no_home )
{
	npc.ClearEnemyStack();
	npc.DropPlanes();
	npc.EraseTimeEvents( CTE_NPC_FOLLOW );
	npc.ModeBase[ MODE_NO_HOME ] = no_home;
	npc.ParamBase[ PET_PROTECT_ID ] = 0;
}

#endif //AI_PET_DOG