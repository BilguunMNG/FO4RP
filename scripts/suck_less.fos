#define __SUCK_LESS__

#include "_defines.fos"
#include "_math.fos"
#include "_dialogbox.fos"


#define BUTTONS_PER_PAGE_USEFUL (17)
#define BUTTONS_PER_PAGE_UTILITY (2)
#define BUTTONS_PER_PAGE ((BUTTONS_PER_PAGE_USEFUL+BUTTONS_PER_PAGE_UTILITY))

class Menu: iDialogBox {
    uint m_cr_id;
    uint m_state;
    string m_name;
    string[] m_buttons;
    string@[] m_buttons_ext;
    int m_page;
    int m_page_max;
    iMenuHandler@ m_handler;

    bool this_multipage;
    uint this_page_first;
    uint this_page_last;
    uint this_page_count;

    Menu@ m_child;
    bool m_is_root;

    Menu(string& name, uint cr_id, iMenuHandler& handler) {
        m_cr_id = cr_id;
        m_state = uint(-1);
        m_name = name;
        m_page = 0;
        @m_handler = handler;
        @m_child = null;
        m_is_root = true;
    }

    // Public Interface:

    bool OpenChild(string& name, iMenuHandler& handler) {
        Menu@ menu = Menu(name, m_cr_id, handler);
        menu.m_is_root = false;
        @m_child = menu;
        return true;
    }

    bool Button(string& text) {
        return ButtonExt(text, null);
    }

    bool ButtonExt(string& text, string@ ext) {
        if( m_state == uint(-1) ) {
            m_buttons.insertLast(text);
            m_buttons_ext.insertLast(ext);
            return false;
        }
        return m_state == uint(m_buttons.find(text));
    }

    // Private:
    
    void CalcPagination() {
        uint count = m_buttons.length();
        if( count > 0 ) {
            m_page_max = (count-1)/BUTTONS_PER_PAGE_USEFUL;
            if( m_page > m_page_max) {
                m_page = 0;
            } else if (m_page < 0) {
                m_page = m_page_max;
            }
        }

        if( count <= BUTTONS_PER_PAGE  ) {
            this_page_first = 0;
            this_page_last = count;
            this_page_count = count;
            this_multipage = false;
        } else {
            this_page_first = m_page*BUTTONS_PER_PAGE_USEFUL;
            this_page_last = MIN(this_page_first+BUTTONS_PER_PAGE_USEFUL, count);
            this_page_count = this_page_last-this_page_first;
            this_multipage = true;
        }
    }
    void Draw() {
        if( m_child !is null ) {
            m_child.Draw();
            return;
        }

        Critter@ cr = GetCritter(m_cr_id);
        if(cr is null || cr.IsNpc()) {
            return;
        }

        m_state = uint(-1);
        m_buttons.resize(0);
        m_buttons_ext.resize(0);
        bool keep_open = m_handler.MenuUpdate(cr, this);

        if( keep_open ) {
            CalcPagination();
            uint i=0;
            uint buttons_total = this_page_count + (this_multipage ? BUTTONS_PER_PAGE_UTILITY : 0);
            cr.ShowScreen( SCREEN_DIALOGBOX, buttons_total, "answer_dialog_box" );

            for(uint j = this_page_first; j < this_page_last; j++) {
                cr.Say( SAY_DIALOGBOX_BUTTON( i++ ), m_handler.ButtonDecorator(m_buttons[j], m_buttons_ext[j]) );
            }

            string@ text = null;
                        
            if( this_multipage ) {
                @text = m_handler.ButtonNextPage(m_page, m_page_max);
                cr.Say( SAY_DIALOGBOX_BUTTON( i++ ), (text is null) ? "Дальше ->" : text);
            
                @text = m_handler.ButtonPrevPage(m_page, m_page_max);
                cr.Say( SAY_DIALOGBOX_BUTTON( i++ ), (text is null) ? "<- Назад" : text);
            }

            @text = m_handler.ButtonCancel();
            if( text !is null ) {
                cr.Say( SAY_DIALOGBOX_BUTTON( i++ ), text );
            }

            @text = m_handler.Description(cr);
            if( text !is null ) {
                cr.Say( SAY_DIALOGBOX_TEXT, text );
            }

            m_handler.OnMenuDraw(cr);
        } else {
            cr.ShowScreen(SCREEN_CLOSE, 0, null);
        }
    }
    bool Update(uint answerI) {
        if( m_child !is null ) {
            if( !m_child.Update(answerI) ) {
                @m_child = null;
                Draw();
            }
            return true;
        }

        Critter@ cr = GetCritter(m_cr_id);
        if(cr is null || cr.IsNpc()) {
            return false;
        }

        if( this_multipage  ) {
            if( answerI >= this_page_count ) {
                if( answerI == this_page_count ) {
                    m_page += 1;
                } else if( answerI == this_page_count + 1 ) {
                    m_page -= 1;
                }

                Draw();
                return true;
            }
            m_state = this_page_first+answerI;
        } else {
            m_state = answerI;
        }

        bool keep_open = m_handler.MenuUpdate(cr, this);

        if( keep_open ) {
            Draw();
        } else if (m_is_root) {
            Forget();
        } else {
            return false;
        }
        return true;
    }
    void Forget() {
        Menu@ old_menu = null;
        string@ key = ""+m_cr_id;
        if( menus.get(key, @old_menu) && old_menu.m_name == m_name) {
            menus.delete(key);
        }
    }
}

dictionary menus;

//export
iDialogBox@ OpenMenu(Critter& cr, string& name, iMenuHandler& handler) {
    string@ key = ""+cr.Id;
    Menu@ menu = Menu(name, cr.Id, handler);
    menus.set(key, @menu);

    Menu@ menu2 = null;
    menus.get(key, @menu2);
    menu2.Draw();
    
    return menu2;
}

string _debug_menu(Menu& menu) {
    if(menu.m_page != 0) {
        int human_readable = menu.m_page%(menu.m_page_max+1) + 1;
        return menu.m_name + ", c."+human_readable;
    } else {
        return menu.m_name;
    }    
}

//export
bool RestoreMenu(Critter& cr) {
    string@ key = ""+cr.Id;
    Menu@ menu = null;
    menus.get(key, @menu);
    if(menu !is null) {
        menu.Draw();
        return true;
    }
    return false;
}

//export
string DebugMenu(Critter& cr) {
    string@ key = ""+cr.Id;
    Menu@ menu = null;
    menus.get(key, @menu);
    if( menu is null) {
        return "Нет меню";
    }
    string path = _debug_menu(menu);
    while(true) {
        @menu = menu.m_child;
        if( menu is null ) {
            break;
        }
        path += " > " + _debug_menu(menu);
    }
    return path;
}

// движковый колбэк
void answer_dialog_box( Critter& cr, uint answerI, string& answerS )
{
    Menu@ menu = null;
    string@ key = ""+cr.Id;
    if( menus.get(key, @menu) ) {
        menu.Update(answerI);
    }
}
