#define __SUCK_LESS__

#include "_defines.fos"
#include "_math.fos"
#include "_dialogbox.fos"


#define BUTTONS_PER_PAGE_USEFUL (17)
#define BUTTONS_PER_PAGE_UTILITY (2)
#define BUTTONS_PER_PAGE ((BUTTONS_PER_PAGE_USEFUL+BUTTONS_PER_PAGE_UTILITY))

import string Centering( string list ) from "mio_control";

 enum MyEnum {
    eValue0,
    eValue2 = 2,
    eValue3,
    eValue200 = eValue2 * 100
 }

class Menu: iDialogBox {
    uint m_cr_id;
    uint m_state;
    string m_name;
    string[] m_buttons;
    string[] m_buttons_ext;
    bool m_align;
    string m_description;
    string m_cancel_text;
    int m_page;
    iMenuHandler@ m_handler;

    bool this_multipage;
    uint this_page_first;
    uint this_page_last;
    uint this_page_count;

    Menu(string& name, uint cr_id, iMenuHandler& handler) {
        m_cr_id = cr_id;
        m_state = uint(-1);
        m_name = name;
        m_page = 0;
        m_align = false;
        @m_handler = handler;
    }

    // Public Interface:

    bool Button(string& text) {
        return ButtonExt(text, "");
    }

    bool ButtonExt(string& text, string& ext) {
        if( m_state == uint(-1) ) {
            m_buttons.insertLast(text);
            m_buttons_ext.insertLast(ext);
            return false;
        }
        return m_state == uint(m_buttons.find(text));
    }

    void Align(bool centering) {
        m_align = centering;
    }

    void Description( string& description ) {
        if( m_state == uint(-1) ) {
            m_description = description;
        }
	}
    void Cancel( string& text ) {
        if( m_state == uint(-1) ) {
            m_cancel_text = text;
        }
	}

    // Private:

    string Aligned(string& text) {
        if( m_align ) {
            return Centering(text);
        } else {
            return text;
        }
    }
    
    void CalcPagination() {
        uint count = m_buttons.length();
        if( count > 0 ) {
            uint max_page = (count-1)/BUTTONS_PER_PAGE_USEFUL;
            if( m_page > max_page) {
                m_page = 0;
            } else if (m_page < 0) {
                m_page = max_page;
            }
        }

        if( count <= BUTTONS_PER_PAGE  ) {
            this_page_first = 0;
            this_page_last = count;
            this_page_count = count;
            this_multipage = false;
        } else {
            this_page_first = m_page*BUTTONS_PER_PAGE_USEFUL;
            this_page_last = MIN(this_page_first+BUTTONS_PER_PAGE_USEFUL, count);
            this_page_count = this_page_last-this_page_first;
            this_multipage = true;
        }
    }
    void Draw() {
        Critter@ cr = GetCritter(m_cr_id);
        if(cr is null || cr.IsNpc()) {
            return;
        }

        m_state = uint(-1);
        m_buttons.resize(0);
        m_buttons_ext.resize(0);
        bool keep_open = m_handler.MenuUpdate(cr, this);

        if( keep_open ) {
            CalcPagination();
            uint i=0;
            uint buttons_total = this_page_count + (this_multipage ? BUTTONS_PER_PAGE_UTILITY : 0);
            cr.ShowScreen( SCREEN_DIALOGBOX, buttons_total, "answer_dialog_box" );

            for(uint j = this_page_first; j < this_page_last; j++) {
                cr.Say( SAY_DIALOGBOX_BUTTON( i++ ), Aligned(m_buttons[j] + m_buttons_ext[j]) );
            }

            if( this_multipage ) {
                cr.Say( SAY_DIALOGBOX_BUTTON( i++ ), "Дальше ->" );
                cr.Say( SAY_DIALOGBOX_BUTTON( i++ ), "<- Назад" );
            }

            if( m_cancel_text.length() > 0 ) {
                cr.Say( SAY_DIALOGBOX_BUTTON( i++ ), Aligned(m_cancel_text) );
            }
			else {
				cr.Say( SAY_DIALOGBOX_BUTTON( i++ ), Aligned("ОТМЕНА") );
			}
            if( m_description.length() > 0 ) {
                cr.Say( SAY_DIALOGBOX_TEXT, m_description );
            }
        } else {
            cr.ShowScreen(SCREEN_CLOSE, 0, null);
        }
    }
    void Update(uint answerI) {
        Critter@ cr = GetCritter(m_cr_id);
        if(cr is null || cr.IsNpc()) {
            return;
        }

        if( this_multipage  ) {
            if( answerI >= this_page_count ) {
                if( answerI == this_page_count ) {
                    m_page += 1;
                } else if( answerI == this_page_count + 1 ) {
                    m_page -= 1;
                }

                Draw();
                return;
            }
            m_state = this_page_first+answerI;
        } else {
            m_state = answerI;
        }

        bool keep_open = m_handler.MenuUpdate(cr, this);

        if( keep_open ) {
            Draw();
        } else {
            Forget();
        }
    }
    void Forget() {
        Menu@ old_menu = null;
        string@ key = ""+m_cr_id;
        if( menus.get(key, @old_menu) && old_menu.m_name == m_name) {
            menus.delete(key);
        }
    }
}

dictionary menus;

//export
iDialogBox@ OpenMenu(Critter& cr, string& name, iMenuHandler& handler) {
    string@ key = ""+cr.Id;
    Menu@ menu = Menu(name, cr.Id, handler);
    menu.Draw();

    menus.set(key, @menu);

    Menu@ menu2 = null;
    menus.get(key, @menu2);
    return menu2;
}

// движковый колбэк
void answer_dialog_box( Critter& cr, uint answerI, string& answerS )
{
    Menu@ menu = null;
    string@ key = ""+cr.Id;
    if( menus.get(key, @menu) ) {
        menu.Update(answerI);
    }
}
