// temprorary interactive objects for sutter
// powermagic

#include "_utils.fos"
#include "_ltp.fos"
#include "STAT_MODS_H.fos"

import void DropBleed( Critter& cr ) from "critter_status";
import void DropToxic( Critter& cr ) from "critter_status";

import void Prolonged_Doc ( Critter& targetCr, uint16 doctime, uint16 damage ) from "heal";
import void Prolonged_heal ( Critter& targetCr, uint16 sk ) from "heal";

import void RottenFood( Map@ map ) from "rotting";
import void RottenFood( Critter& cr ) from "rotting";

import void Cleaning( Critter& player, uint soap_pid, int water_source ) from "main";
import void ProccessDrink( Critter& cr, Critter& target, Item& item ) from "food";

#define Switch 									Val2
#define REMAINING_CHARGE					 	Val3
#define MissingPart 							Val4
#define Repair 									Val5
#define Research 								Val6
#define Multiplier 								Val7

#define DATA_POWER	            ( 24 )
#define DATA_DYSPNEA            ( 25 )

#define REMAINING_USES							Val0 	// Кол-во оставшихся использований
#define EXTRA_WEIGHT							Val2	// Дополнительный вес жидкости

void WaterPumpInit( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_SKILL, "_WaterPumpSkill" );
    item.SetEvent( ITEM_EVENT_USE_ON_ME, "_WaterPumpOnMe" );
}

const uint[] ALLamapPids = { MAP_SUTTER_CENTER_DN, MAP_SUTTER_CENTER_DN_2, MAP_PHOENIX_DN, MAP_PHOENIX_DN, MAP_MARIP_1, MAP_MARIP_2, MAP_MARIP_3, MAP_MARIP_4};
const uint[] Phoenix_mapPids = { /*MAP_PHOENIX_DN */ };
const uint[] mapPids = { 
	/*MAP_SUTTER_CENTER, */ 		//88
	MAP_SUTTER_CENTER_DN, 			//89
	MAP_SUTTER_CENTER_DN_2, 		//59
	/*MAP_SUTTER_CENTER_UP, 		//90
	MAP_SUTTER_CENTER_UP_1,*/ 		//91
	MAP_PHOENIX_DN, 				//31
	MAP_MARIP_1,  					//28
	MAP_MARIP_2,  					//29
	MAP_MARIP_3,  					//32
	MAP_MARIP_4  					//33
};
const uint[] mapLight = { MAP_SUTTER_CENTER, MAP_SUTTER_CENTER_DN, MAP_SUTTER_CENTER_DN_2, MAP_PHOENIX_DN, MAP_MARIP_1, MAP_MARIP_2, MAP_MARIP_3, MAP_MARIP_4  };

int getPowerValue( Critter& cr )
{
	uint map_pid = cr.GetMap().GetProtoId();

	GameVar@ power = GetGlobalVar( GVAR_Sutter_Power );
	
	if( map_pid == MAP_PHOENIX_DN ) 
		@power = GetGlobalVar( GVAR_Phoenix_Power );

	int power_value = power.GetValue();
	
	uint[] autonomus_maps = { 24, 356 };
	if( autonomus_maps.find( map_pid ) != -1 )
		power_value = 1; //Автономным картам энергия не нужна.
	
	return power_value;
}

void WaterpumpMenu( Critter& cr, Item& item )
{
	string state = ( item.Switch > 0 ? "в" : "вы" ) + "ключена, индикатор показывает " + item.REMAINING_CHARGE;
	
	bool isBroken = false;
	
	if ( item.Research > 0 ) 
	{
		state += ". Требуется внимательный осмотр";
		isBroken = true;
	}
	else
	if ( item.Repair > 0 )
	{
		state += ". Требуется ремонт";
		isBroken = true;
	}
	else
	if ( item.MissingPart > 0 )
	{
		state += ". Требуется деталь";
		isBroken = true;
	}
	
	
	string function = "map_sutter_objects@answer_Waterpump" + ( isBroken ? "Maintenance" : "Menu" );
	string action = ( item.Switch > 0 ? "вы" : "в" ) + "ключить";
	string[] data = { function, "Помпа " + state + ", выберите действие:", action };
	
	if( !isBroken )
	{ //TODO: Сделать возможность набрать воду/попить/помыться из сломанной помпы, но со штрафами.
		data.insertLast( "набрать воды" );
		data.insertLast( "попить" );
		data.insertLast( "помыться" );
	}
	else
	{ //TODO: Добавить кнопку "вставить деталь".
		data.insertLast( "осмотреть" );
		data.insertLast( "починить" );
	}
	
	DIALOG_MENU( cr, data );
	cr.ParamBase[ CR_VAL0 ] = item.Id;
}

void answer_WaterpumpMaintenance( Critter& cr, uint answerI, string& answerS )
{
	Item@ item = GetItem( cr.ParamBase[ CR_VAL0 ] );
	
	if( !valid( item ) )
	{
		cr.Say( SAY_NETMSG, "Помпа уже вся заржавела, из этого ничего не вышло." );
		return;
	}

	switch( answerI )
	{
		case( 0 ): switchWaterpump( cr, item ); break;
		case( 1 ): check_science( item, cr ); break;	
		case( 2 ): check_repair( item, cr ); break;
	}
	
	WaterpumpMenu( cr, item );
}

void answer_WaterpumpMenu( Critter& cr, uint answerI, string& answerS )
{
	Item@ item = GetItem( cr.ParamBase[ CR_VAL0 ] );
	
	if( !valid( item ) )
	{
		cr.Say( SAY_NETMSG, "Помпа уже вся заржавела, что-то пошло не так." );
		return;
	}

	if( answerI == 0 )
	{
		switchWaterpump( cr, item );
		return;
	}
	
	if( item.REMAINING_CHARGE < 1 )
	{
		cr.Say( SAY_NETMSG, "Воды больше нет." );
		return;
	}
	
	if( answerI == 1 )
	{
		cr.ParamBase[ CR_VAL0 ] = item.Id;
		start_pouring( cr );
		return;
	}

	switch( answerI )
	{
		case(2): 
		{
			Item@ consumedDrink = cr.AddItem( PID_GLASS_BOTTLE_FULL_PRT, 1 );
			consumedDrink.REMAINING_USES = 2;
			ProccessDrink( cr, cr, consumedDrink );
	
			_SubItem( consumedDrink, 1 );
			break;
		}
		case(3): Cleaning( cr, 0, -1 );	break;
	}
	
	WaterpumpMenu( cr, item );
	item.REMAINING_CHARGE --;
}

void setAnimState( Item& item, bool state )
{
	if( state )
	{	
		SETFLAG(item.Flags, ITEM_SHOW_ANIM);
		UNSETFLAG(item.Flags, ITEM_SHOW_ANIM_EXT);
	}
	else
	{
		UNSETFLAG(item.Flags, ITEM_SHOW_ANIM);
		SETFLAG(item.Flags, ITEM_SHOW_ANIM_EXT);
	}

	item.Update();
	item.Animate(0,0);
}

void switchWaterpump( Critter& cr, Item& item )
{
	if( getPowerValue(cr) <= 0 )
	{
		cr.Say( SAY_NETMSG, "Энергоснабжение отключено. Сначала запустите генератор." );
		return;
	}
	
	bool isOn = item.Switch > 0;

	item.Switch = isOn ? 0 : 1;//Выключаем включенное и наоборот.
	isOn = item.Switch > 0;

	setAnimState( item, isOn );
	
	string state = ( isOn ? "В" : "Вы" ) + "ключено";
	string action = ( isOn ? "" : "не " ) + "очищается";

	cr.Say( SAY_NETMSG, state + ", вода " + action + "." );
}

void waterpumpInfo( Critter& cr, Item& item )
{
	string state = ( item.Switch > 0 ? "в" : "вы" ) + "ключена, индикатор показывает " + item.REMAINING_CHARGE;
	cr.Say( SAY_NETMSG, "Помпа " + state + "." );

	check_science( item, cr );
}

bool _WaterPumpSkill( Item& item, Critter& cr, int skill )
{
    switch( skill )
	{
		case( SKILL_PICK_ON_GROUND ): WaterpumpMenu( cr, item ); break;
		case( SK_SCIENCE ): waterpumpInfo( cr, item ); break;
		case( SK_REPAIR ): check_repair( item, cr ); break;
	}

	return true;
}

bool _WaterPumpOnMe( Item& item, Critter& cr, Item@ usedItem )
{
	cr.ParamBase[ CR_VAL0 ] = item.Id;
	start_pouring( cr );
	return true;
}

bool ltp_inited = false;
void ltp_init()
{
	LTPREG( LTP_POURING, process_pouring )
	ltp_inited = true;
}

bool start_pouring( Critter& cr )
{
	if(!ltp_inited) { 
		ltp_init();
	}
	
	Map@ map = cr.GetMap();		
	Item@ target = GetItem( cr.ParamBase[ CR_VAL0 ] );
	
	if( valid( target ) ) {
		
		if( target.REMAINING_CHARGE < 1 ) {
			cr.Say( SAY_NETMSG, "|0xFFFF00 Воды больше нет." );
			return false;
		}
	
		if( target.Switch < 1 ) {
			cr.Say( SAY_NETMSG, "|0xFFFF00 Помпа отключена. Включите ее сначала." );
			return false;
		}
	
		if( getPowerValue(cr) <= 0 ) {
			cr.Say( SAY_NETMSG, "|0xFFFF00 Энергия отключена. Включите генератор." );
			return false;
		}
		
		if( !hasItem( cr, PID_BOTTLE_GLASS, SLOT_HAND1 ) && !hasItem( cr, PID_GLASS_BOTTLE_FULL_PRT, SLOT_HAND1 ) ) { cr.Say( SAY_NETMSG, "|0xFFFF00 У вас нет подходящей тары в руках." ); return false;
		}
		
		uint hit_pause = ACTION_PAUSE_BASE - (cr.Stat[ST_AGILITY] * ACTION_PAUSE_BONUS_RATE );
		uint action_pause = CLAMP( hit_pause, ACTION_PAUSE_MIN, ACTION_PAUSE_MAX );
		map.PlaySound( "homebrew_pouring.ogg", cr.HexX, cr.HexY, 5 );
		CreateTimeEvent( AFTER( REAL_MS( 1000 ) ), "e_TiredenessTimeout", cr.Id, true);	
		
		StartProcess( cr, LTP_POURING, 0, 0, target.Id, action_pause );
		return true;
	}
	return false;
}

uint process_pouring( Critter@ cr, int& param0, int& param1, int& param2 )
{
    LTPROCESS( cr, param0, LTP_POURING )
	uint hit_pause = ACTION_PAUSE_BASE - ( cr.Stat[ST_AGILITY] * ACTION_PAUSE_BONUS_RATE );
	uint action_pause = CLAMP( hit_pause, ACTION_PAUSE_MIN, ACTION_PAUSE_MAX );
  	Item@ target = GetItem( param2 );
	
  	if( valid( target ) ) {
		
      	if( ( !hasItem( cr, PID_BOTTLE_GLASS ) && !hasItem( cr, PID_GLASS_BOTTLE_FULL_PRT ) ) || target.REMAINING_CHARGE < 1 ) {
			string TXT = ( !hasItem( cr, PID_BOTTLE_GLASS ) || !hasItem( cr, PID_GLASS_BOTTLE_FULL_PRT ) ) ? " У Вас закончилась тара." : " Вы разлили всю воду по бутылкам.";
			cr.Say( SAY_NETMSG, "|0xFFFF00" + TXT );
			return 0;
		}
		
		_CritAnimateUse(cr);
		uint autoemote = Random( 1, 10 );
		if( autoemote == 10 ) { cr.Say( SAY_EMOTE, "Наполняет бутылку" );
		}
		
		if( hasItem( cr, PID_GLASS_BOTTLE_FULL_PRT ) ) {
			
			Item@ waterBottlePrt = getItem( cr, PID_GLASS_BOTTLE_FULL_PRT );
			if( waterBottlePrt.REMAINING_USES < waterBottlePrt.Proto.Partial_Item ) {
				
				target.REMAINING_CHARGE --;
				waterBottlePrt.REMAINING_USES ++;
				waterBottlePrt.EXTRA_WEIGHT = waterBottlePrt.REMAINING_USES * 100;

				Map@ map = cr.GetMap();
				map.PlaySound( "homebrew_pouring.ogg", cr.HexX, cr.HexY, 5 );
								
				waterBottlePrt.Update();
				
			} else {
			
				Item@ waterBottle = cr.AddItem( PID_GLASS_BOTTLE_FULL, 1 );
				
				_SubItem( waterBottlePrt , 1 );
				
				cr.Say( SAY_NETMSG, "|0xFFFF00 Вы полностью наполнили бутылку водой" );
				
				waterBottle.Update();
			}

			CreateTimeEvent( AFTER( REAL_MS( 1000 ) ), "e_TiredenessTimeout", cr.Id, true);
			
			return action_pause;
			
		} else {
		
			Item@ bottle = cr.GetItem( PID_BOTTLE_GLASS, -1 );
			_SubItem( bottle , 1 );
		
			Item@ waterBottlePrt = cr.AddItem( PID_GLASS_BOTTLE_FULL_PRT, 1 );
			
			Item@ hands = cr.GetItem( 0, SLOT_HAND1 );
			if( valid( hands ) ) {
				cr.MoveItem( hands.Id, hands.GetCount(), SLOT_INV );
			}
			
			cr.MoveItem( waterBottlePrt.Id, waterBottlePrt.GetCount(), SLOT_HAND1 );
		
			target.REMAINING_CHARGE --;
			waterBottlePrt.REMAINING_USES ++;
			waterBottlePrt.EXTRA_WEIGHT = waterBottlePrt.REMAINING_USES * 100;

			Map@ map = cr.GetMap();
			map.PlaySound( "homebrew_pouring.ogg", cr.HexX, cr.HexY, 5 );
				
			waterBottlePrt.Update();
		}
		
		CreateTimeEvent( AFTER( REAL_MS( 1000 ) ), "e_TiredenessTimeout", cr.Id, true);
		
		return action_pause;
    }
	return 0;
}

uint e_TiredenessTimeout(uint[]@ values)
{
	Critter@ cr = GetCritter( values[0] ); 
	uint fatigue_per_action = ACTION_FATIGUE_BASE - ( cr.Stat[ST_ENDURANCE] * ACTION_FATIGUE_RATE );
	uint fatigue = CLAMP( fatigue_per_action, ACTION_FATIGUE_MIN, ACTION_FATIGUE_MAX);
	cr.TimeoutBase[ TO_TIREDNESS ] = __FullSecond + cr.Timeout[ TO_TIREDNESS ] + REAL_SECOND( fatigue );
	return 0;
}

void WattsInit( Item& item, bool firstTime )
{
    // item.SetEvent(ITEM_EVENT_SKILL, "_WaterPumpSkill");
    item.SetEvent( ITEM_EVENT_SKILL, "_WattsSkill" );
    item.SetEvent( ITEM_EVENT_USE_ON_ME, "_WattsOnMe" );
}

bool _WattsSkill( Item& item, Critter& cr, int skill )
{
    if( skill == SKILL_PICK_ON_GROUND )
    {
		GameVar@ power = GetGlobalVar( GVAR_Sutter_Power );
		if ( cr.GetMap().GetProtoId() == MAP_PHOENIX_DN ) @ power = GetGlobalVar( GVAR_Phoenix_Power );

		uint8 offpower = item.Val1;
        uint8 switcher = item.Switch;
		
        uint16 parts = item.MissingPart;
        uint16 repair = item.Repair;
		uint16 science = item.Research;
		
		if ( science > 0 ) {cr.Say( SAY_NETMSG, "Требуется внимательный осмотр." ); return true;}
		if ( parts > 0 ) {cr.Say( SAY_NETMSG, "Требуется деталь:" ); cr.SayMsg( SAY_NETMSG, TEXTMSG_ITEM, parts*100 ); return true;}
		if ( repair > 0 ) {cr.Say( SAY_NETMSG, "Требуется ремонт." ); return true;}		

        if( power.GetValue() > 0 || offpower > 0)
        {
            int val = switcher;
            val = ( val > 0 ? 0 : 1 );

            item.Switch = val;

            string msg = "";

            if( val > 0 )
            {
                SETFLAG(item.Flags, ITEM_SHOW_ANIM);
				
                msg = "включен";
				power.opAddAssign( offpower );
				item.Val1=0;
            }
            else
            {
                UNSETFLAG(item.Flags, ITEM_SHOW_ANIM);
				
                msg = "выключен";
				item.Val1=power.GetValue();				
				power.opAssign( 0 );
            }
			
			SETFLAG( item.Flags, ITEM_HIDDEN );
			item.Update();
			uint[] values = { item.Id };
			CreateTimeEvent( __FullSecond + 1, "e_ChangeAnims", values, true );

			if ( cr.GetMap().GetProtoId() == MAP_PHOENIX_DN ) WattsReleasePhoenix( val );
            else WattsRelease( val );

            cr.Say( SAY_NETMSG, "Генератор " + msg + "." );
        }
        else
        {
            cr.Say( SAY_NETMSG, "Кончился заряд. Зарядите генератор." );
        }
    }
    else if( skill == SK_SCIENCE )
    {
		if ( !check_science( item, cr )) return true;

		GameVar@ power = GetGlobalVar( GVAR_Sutter_Power );
		if ( cr.GetMap().GetProtoId() == 31 ) @ power = GetGlobalVar( GVAR_Phoenix_Power );

        uint8  switcher = item.Switch;

        int    val = switcher;

        string msg = "", addMsg = "";

        if( val > 0 )
        		
		{
            msg = "включен";
            addMsg = " Уровень заряда генератора : " + power.GetValue() + " .";
        }
        else
        {
            msg = "выключен";
        }

        cr.Say( SAY_NETMSG, "Сейчас " + msg + "." + addMsg );
    }
    else if( skill == SK_REPAIR && item.Repair >0)
    {
		if ( !check_repair( item, cr )) return true;
	}	

    return true;
}

bool _WattsOnMe( Item& item, Critter& cr, Item@ usedItem )
{
    if( usedItem is null)
		return false;
		
	if ( !check_parts( item, cr, usedItem )) return true;

	if( usedItem.GetProtoId() != PID_MICRO_FUSION_CELL )
        return false;
		
    uint8  switcher = item.Switch;

	if ( switcher == 0 ) item.Val1+=20;
	else
		{
		GameVar@ power = GetGlobalVar( GVAR_Sutter_Power );
		if ( cr.GetMap().GetProtoId() == MAP_PHOENIX_DN ) @ power = GetGlobalVar( GVAR_Phoenix_Power );
		power.opAddAssign(20);
		}

    _SubItem( usedItem, 1 );

    cr.Say( SAY_NETMSG, "Вы подзарядили генератор." );

    return true;
}

void WattsRelease( int val )
{
    for( uint8 i = 0; i < mapPids.length(); ++i )
    {
        Map @ map = GetMapByPid( mapPids[ i ], 0 );
        if( map is null )
            continue;
	
		map.SetData(DATA_POWER, val); 		//for elevators and doors


		Item@[] door;
		map.GetItemsByType( ITEM_TYPE_DOOR, door );

		for( uint8 ii = 0, jj = door.length(); ii < jj; ++ii )
		{
			Item @ item = door[ ii ];

			if( item is null )
				continue;

			if( IsDoorAutomatic( item.GetProtoId() ) )
			{
				item.Research = val;
			}
		}
	}
	
    for( uint8 i = 0, j = mapLight.length(); i < j; ++i )
    {
        Map @ map = GetMapByPid( mapLight[ i ], 0 );
        if( map is null )
            continue;

        Item@[] light;

        map.GetItems( PID_OBJECT_LIGHT, light );

        for( uint8 ii = 0, jj = light.length(); ii < jj; ++ii )
        {
            Item @ item = light[ ii ];
            if( item is null )
                continue;

            bool switcher = ( val > 0 );

            if( switcher )
            {
                // UNSETFLAG(item.Flags, ITEM_HIDDEN);
                // SETFLAG(item.Flags, ITEM_LIGHT);
                // item.LightDistance = 6;
                item.LightIntensity = 100;
            }
            else
            {
                // SETFLAG(item.Flags, ITEM_HIDDEN);
                // UNSETFLAG(item.Flags, ITEM_LIGHT);
                // item.LightDistance = 0;
                item.LightIntensity = -1;
            }
            item.Update();
        }
    }
}

void WattsReleasePhoenix( int val )
{
    for( uint8 i = 0; i < Phoenix_mapPids.length(); ++i )
    {
        Map @ map = GetMapByPid( Phoenix_mapPids[ i ], 0 );
        if( map is null )
            continue;
	
		map.SetData(DATA_POWER, val); 		//for elevators and doors
    }
	
    for( uint8 i = 0, j = Phoenix_mapPids.length(); i < j; ++i )
    {
        Map @ map = GetMapByPid( Phoenix_mapPids[ i ], 0 );
        if( map is null )
            continue;

        Item@[] light;

        map.GetItems( PID_OBJECT_LIGHT, light );

        for( uint8 ii = 0, jj = light.length(); ii < jj; ++ii )
        {
            Item @ item = light[ ii ];
            if( item is null )
                continue;

            bool switcher = ( val > 0 );

            if( switcher )
            {
                item.LightIntensity = 100;
            }
            else
            {
                item.LightIntensity = -1;
            }
            item.Update();
        }
    }
}

// void TurnOnAir

bool IsDoorAutomatic( uint pid )
{
    bool automat = ( pid == 2142 || pid == 2143 || pid == 3169 || pid == 3170 || pid == 4763 || pid == 4765 );

    return automat;
}

void AirLockInit( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_SKILL, "_AirLockSkill" );
    item.SetEvent( ITEM_EVENT_USE_ON_ME, "_AirLockOnMe" );
}

bool _AirLockSkill( Item& item, Critter& cr, int skill )
{
    if( skill == SKILL_PICK_ON_GROUND )
    {
		GameVar@ power = GetGlobalVar( GVAR_Sutter_Power );
		if ( cr.GetMap().GetProtoId() == MAP_PHOENIX_DN ) @ power = GetGlobalVar( GVAR_Phoenix_Power );

        uint16 parts = item.MissingPart;
        uint16 repair = item.Repair;
		uint16 science = item.Research;
		
		if ( science > 0 ) {cr.Say( SAY_NETMSG, "Требуется внимательный осмотр." ); return true;}
		if ( parts > 0 ) {cr.Say( SAY_NETMSG, "Требуется деталь:" ); cr.SayMsg( SAY_NETMSG, TEXTMSG_ITEM, parts*100 ); return true;}
		if ( repair > 0 ) {cr.Say( SAY_NETMSG, "Требуется ремонт." ); return true;}		
		
        uint8 switcher = item.Switch;

        if( power.GetValue() > 0 )
        {
            int val = switcher;
            val = ( val > 0 ? 0 : 1 );

            string msg = "";

            if( val > 0 )
            {
                SETFLAG(item.Flags, ITEM_SHOW_ANIM);
                msg = "Включено";
            }
            else
            {
                UNSETFLAG(item.Flags, ITEM_SHOW_ANIM);
                msg = "Выключено";
            }

			SETFLAG( item.Flags, ITEM_HIDDEN );
			item.Update();
			uint[] values = { item.Id };
			CreateTimeEvent( __FullSecond + 1, "e_ChangeAnims", values, true );
			
            item.Switch = val;
            cr.Say( SAY_NETMSG, "" + msg + ". Воздух " + ( val > 0 ? "" : "не" ) + " поступает." );
        }
        else
        {
            cr.Say( SAY_NETMSG, "Энергия отключена. Включите генератор." );
        }
    }
    else if( skill == SK_SCIENCE )
    {
		if ( !check_science( item, cr )) return true;
		
		uint8  switcher = item.Switch;

        int    val = switcher;

        string msg = "";

        if( val > 0 )
        {
            msg = "включено";
        }
        else
        {
            msg = "выключено";
        }

        cr.Say( SAY_NETMSG, "Сейчас " + msg + "." );
    }
    else if( skill == SK_REPAIR && item.Repair >0)
    {
		if ( !check_repair( item, cr )) return true;
	}	

    return true;
}

bool _AirLockOnMe( Item& item, Critter& cr, Item@ usedItem )
{
    if( usedItem is null )
        return false;

    uint pid = usedItem.GetProtoId();
	
	if ( !check_parts( item, cr, usedItem )) return true;
	
    return false;
}

void DocInit( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_SKILL, "_DocSkill" );
    item.SetEvent( ITEM_EVENT_USE_ON_ME, "_DocOnMe" );
}

bool _DocSkill( Item& item, Critter& cr, int skill )
{
    if( skill == SKILL_PICK_ON_GROUND )
    {
		GameVar@ power = GetGlobalVar( GVAR_Sutter_Power );
		if ( cr.GetMap().GetProtoId() == MAP_PHOENIX_DN ) @ power = GetGlobalVar( GVAR_Phoenix_Power );

        uint16 parts = item.MissingPart;
        uint16 repair = item.Repair;
		uint16 science = item.Research;
		
		if ( science > 0 ) {cr.Say( SAY_NETMSG, "Требуется внимательный осмотр." ); return true;}
		if ( parts > 0 ) {cr.Say( SAY_NETMSG, "Требуется деталь:" ); cr.SayMsg( SAY_NETMSG, TEXTMSG_ITEM, parts*100 ); return true;}
		if ( repair > 0 ) {cr.Say( SAY_NETMSG, "Требуется ремонт." ); return true;}		
		
        uint8 charge = item.REMAINING_CHARGE;

        if( power.GetValue() > 0 )
        {
            if( charge > 0 )
            {
                DocHeal( cr );

                charge--;
                charge = CLAMP( charge, 0, 100 );
                item.REMAINING_CHARGE = charge;
            }
            else
            {
                cr.Say( SAY_NETMSG, "Закончился биогель, обновите резервуар." );
            }
        }
        else
        {
            cr.Say( SAY_NETMSG, "Энергия отключена. Включите генератор." );
        }
    }
    else if( skill == SK_SCIENCE )
    {
		if ( !check_science( item, cr )) return true;
		
		GameVar@ power = GetGlobalVar( GVAR_Sutter_Power );
		if ( cr.GetMap().GetProtoId() == 31 ) @ power = GetGlobalVar( GVAR_Phoenix_Power );

        uint8  charge = item.REMAINING_CHARGE;

        string msg = "", addMsg = "";

        if( power.GetValue() > 0 )
        {
            msg = "включено";
            addMsg = " Биогеля хватит на " + charge + " операций.";
        }
        else
        {
            msg = "выключено";
        }

        cr.Say( SAY_NETMSG, "Сейчас " + msg + "." + addMsg );
    }
    else if( skill == SK_REPAIR && item.Repair >0)
    {
		if ( !check_repair( item, cr )) return true;
	}	

    return true;
}

bool _DocOnMe( Item& item, Critter& cr, Item@ usedItem )
{
    if( usedItem is null)
        return false;

	if ( !check_parts( item, cr, usedItem )) return true;
	
    if( usedItem.GetProtoId() != PID_BIO_GEL )
        return false;

	GameVar@ power = GetGlobalVar( GVAR_Sutter_Power );

    uint8 charge = item.REMAINING_CHARGE;

    if( charge == 0 )
    {

        item.REMAINING_CHARGE = 100;
        _SubItem( usedItem, 1 );

        cr.Say( SAY_NETMSG, "Вы залили биогель в резервуар." );
    }
    else
    {
        cr.Say( SAY_NETMSG, "Биогель пока не требуется." );
    }

    return true;
}

void DocHeal( Critter& cr )
{
	if ( !valid(cr) ) return;
	
    DropBleed( cr );
    DropToxic( cr );
    cr.StatBase[ ST_CRSTATUS ] = 0;	
	cr.EraseTimeEvents( CTE_HEAL );
	cr.EraseTimeEvents( CTE_DOC );	
	
    for( uint16 i = 502; i < 506; ++i )
    {
        if ( cr.ParamBase[ i ] != 0 ) Prolonged_Doc ( cr, Random (500, 1000), i );
    }

	Prolonged_heal ( cr, 300);
}

void LightInit( Item& item, bool firstTime )
{
    // item.SetEvent(ITEM_EVENT_SKILL, "_WaterPumpSkill");
    item.SetEvent( ITEM_EVENT_SKILL, "_LightSkill" );

    // item.LightDistance = 6;
    // item.LightColor = COLOR_DRED;
    // item.LightIntensity = 100;

    // SETFLAG(item.Flags, ITEM_COLORIZE);
    // SETFLAG(item.Flags, ITEM_ALWAYS_VIEW);
    // SETFLAG(item.Flags, ITEM_LIGHT);

    string picName = "art\\scenery\\whitePXL.frm";

    uint   hash = GetStrHash( picName );
    item.SetMapPic( hash );

    item.LightColor = 9999666;
    item.LightDistance = 6;

    item.LightIntensity = ( item.Val1 > 1 ? 0 : 100 );

    item.Update();
    // item.SetEvent(ITEM_EVENT_USE_ON_ME, "_DocOnMe");
}

bool _LightSkill( Item& item, Critter& cr, int skill )
{
    return true;
}

void ObjectTimeLoop()
{
	GameVar@ Phoenixpower = GetGlobalVar( GVAR_Phoenix_Power );
	GameVar@ power = GetGlobalVar( GVAR_Sutter_Power );
	
	if( Random (0, 23) == 0 )
	{
		if( Phoenixpower.GetValue() > 0 ) Phoenixpower.opSub( 1 );
		if( power.GetValue() > 0 ) power.opSub( 1 );	
	}

	Map@ map;
	
    for( uint i = 1; i < 10000; i++ )
	{
		uint[] ignored_map_pids = {
			92, 93, 94, 160, 161, 170, 380, 381, 382, 383, 400
		};
		
		if( ignored_map_pids.find( i ) != -1 )
			continue;
	
		@map = GetMapByPid( i, 0 );
		if(!valid(map)) continue;
		
        RottenFood( map );

		Critter@[] crs;
		if( map.GetCritters( 0, FIND_LIFE|FIND_ONLY_PLAYERS, crs ) > 0 )
			for( uint j = 0; j < crs.length(); j++ )
				RottenFood( crs[j] );
			
		if( mapPids.find(i) == -1 && Phoenix_mapPids.find(i) == -1 )
		{	//На этих картах не учитывается наличие энергии:
			Item@[] water;
			map.GetItems( PID_OBJECT_WATERPUMP, water );
			for( uint8 ii = 0, jj = water.length(); ii < jj; ++ii )
			{
				Item @ item = water[ ii ];

				if( item is null )
					continue;

				if( item.Switch > 0 )
				{
					int gain = item.Multiplier == 0 ? 1 : item.Multiplier;
					item.REMAINING_CHARGE = CLAMP( item.REMAINING_CHARGE + gain, 0, 100 );
				}
			}
			GameVar @ dyspnea = GetLocalVar( LMVAR_Dyspnea, map.Id );
			dyspnea.opAssign( 0 );
			map.SetData( DATA_DYSPNEA, 0 );
		}
	}

 	
    for( uint i = 0; i < Phoenix_mapPids.length(); i++ )
    {
        Map @ map = GetMapByPid( Phoenix_mapPids[ i ], 0 );
        if( map is null )
            continue;

        Item@[] water;

        map.GetItems( PID_OBJECT_WATERPUMP, water );

        for( uint ii = 0, jj = water.length(); ii < jj; ii++ )
        {
            Item @ item = water[ ii ];

            if( item is null )
                continue;

            uint8 switcher = item.Switch;
            uint8 water = item.REMAINING_CHARGE;

            if( Phoenixpower.GetValue() > 0 )
            {
				int gain = item.Multiplier == 0 ? 1 : item.Multiplier;
				item.REMAINING_CHARGE = CLAMP( item.REMAINING_CHARGE + gain, 0, 100 );
            }
        }
    }
}

void ProccessAir() {}

void ShowLight( Critter& cr, int x, int, int )
{
    Item@[] item;
    Map @ map = cr.GetMap();

    if( map is null )
        return;

    map.GetItems( PID_OBJECT_LIGHT, item );

    for( uint16 i = 0, j = item.length(); i < j; ++i )
    {
        string picName = "art\\scenery\\";

        if( x > 0 )
        {
            picName += "grid_wall.frm";
        }
        else
        {
            picName += "whitePXL.frm";
        }

        uint hash = GetStrHash( picName );
        item[ i ].SetMapPic( hash );

        cr.Say( SAY_NETMSG, "flag " + item[ i ].Flags );
    }

}
/*
   void DyspneaTimeLoop(){
        for(uint8 i = 0; i < mapPids.length(); ++i){
                Map @ map = GetMapByPid(mapPids[i], 0);
                if(map is null) continue;

                Critter@[] crs;
                if(map.GetCritters(0, FIND_LIFE|FIND_ONLY_PLAYERS, crs) > 0){
                        for(uint8 ii = 0, jj = crs.length(); ++ii){

                        }
                }
        }
   }*/
/* val1 - powerOn
 * Switch - switcher
 * Indicator - (power, water, charge)*/


void debugOnOff(Critter& cr, int val, int, int){
	Map @ map = cr.GetMap();
	
	if(map is null) return;
	
	Item@[] items;
	map.GetItems(PID_OBJECT_WATTS, items);
	
	for(uint8 i = 0, j = items.length(); i < j; ++i){
		items[i].Val1 = 1;
		if(items[i].Indicator <= 0){
			items[i].Indicator = 4;
		}
	}
	
	for( uint8 i = 0; i < mapPids.length(); ++i )
	{
        Map @ map = GetMapByPid( mapPids[ i ], 0 );
        if( map is null )
            continue;
	
		map.SetData(DATA_POWER, val); 		//for elevators

        Item@[] water;
        Item@[] air;
        Item@[] doc;
        Item@[] door;

        map.GetItems( PID_OBJECT_WATERPUMP, water );
        map.GetItems( PID_OBJECT_AIRLOCK, air );
        map.GetItems( PID_OBJECT_DOC, doc );

        map.GetItemsByType( ITEM_TYPE_DOOR, door );

        for( uint8 ii = 0, jj = water.length(); ii < jj; ++ii )
        {
            Item @ item = water[ ii ];

            if( item is null )
                continue;

            item.Val1 = val;
            item.Switch = val;

        }

        for( uint8 ii = 0, jj = air.length(); ii < jj; ++ii )
        {
            Item @ item = air[ ii ];

            if( item is null )
                continue;

            //	GameVar @ switcher = GetLocalVar(LIVAR_Object_Switcher, item.Id);
            //	GameVar @ powerOn = GetLocalVar(LIVAR_Object_PowerOn, item.Id);

            //	if(switcher is null || powerOn is null) continue;

            item.Val1 = val;
            item.Switch = val;
        }

        for( uint8 ii = 0, jj = doc.length(); ii < jj; ++ii )
        {
            Item @ item = doc[ ii ];

            if( item is null )
                continue;

            // GameVar @ switcher = GetLocalVar(LIVAR_Object_Switcher, item.Id);
            // GameVar @ powerOn = GetLocalVar(LIVAR_Object_PowerOn, item.Id);

            // if(switcher is null || powerOn is null) continue;

			item.Val1 = val;
			item.Switch = val;

        }

        for( uint8 ii = 0, jj = door.length(); ii < jj; ++ii )
        {
            Item @ item = door[ ii ];

            if( item is null )
                continue;

            if( IsDoorAutomatic( item.GetProtoId() ) )
            {
                item.Research = val;
            }
        }

    }

    for( uint8 i = 0, j = mapLight.length(); i < j; ++i )
    {
        Map @ map = GetMapByPid( mapLight[ i ], 0 );
        if( map is null )
            continue;

        Item@[] light;

        map.GetItems( PID_OBJECT_LIGHT, light );

        for( uint8 ii = 0, jj = light.length(); ii < jj; ++ii )
        {
            Item @ item = light[ ii ];

            if( item is null )
                continue;

            // if(IsDoorAutomatic(item.GetProtoId())){

            item.Val1 = val;
	    
            item.LightIntensity = (val > 0 ? 100 : 0);

            item.Update();
        }
    }
	
	
}

void spawn_autodoors(Critter& cr, int val, int, int)
{	
	for( uint8 i = 0; i < ALLamapPids.length(); ++i )
	{
        Map @ map = GetMapByPid( ALLamapPids[ i ], 0 );
        if( map is null )
            continue;
	
        Item@[] door;

        map.GetItemsByType( ITEM_TYPE_DOOR, door );

        for( uint8 ii = 0, jj = door.length(); ii < jj; ++ii )
        {
            Item @ item = door[ ii ];

            if( item is null )
                continue;

            if( IsDoorAutomatic( item.GetProtoId() ) )
            {
				uint16 x=item.HexX;
				uint16 y=item.HexY;			
				for( uint8 i = 0; i < 6; i++ )
				{
					map.MoveHexByDir( x, y, i, 1 );
					if ( !valid (map.GetItem( x, y, PID_AUTODOOR )) )
						{
						Item@ pedal = map.AddItem( x, y, PID_AUTODOOR, 1 );
						pedal.Val1 = item.Id;
						}
					x=item.HexX;
					y=item.HexY;	
				}
            
            }
        }

    }
}


void debugDyspnea(Critter& cr, int val, int, int){
	Map @ map = cr.GetMap();
	if(map is null) return;
	
	GameVar @ dyspnea = GetLocalVar( LMVAR_Dyspnea, map.Id );
        if(dyspnea is null) return;
	
	dyspnea.opAssign(CLAMP(val, 0, 100));
	map.SetData(DATA_DYSPNEA, CLAMP(val, 0, 1));
	
	
	return;
}

bool check_parts( Item& item, Critter& cr, Item@ usedItem )
{
    if( !valid( usedItem ) )
        return false;

    uint pid = usedItem.GetProtoId();
	
	if ( item.Research > 0 ) {cr.Say( SAY_NETMSG, "Пока еще непонятно в чем проблема." ); return false;}
	if ( item.MissingPart > 0 )
		{
		if ( int( pid ) == item.MissingPart )
			{
			cr.Say( SAY_NETMSG, "Вы установили требуемую деталь." );
			_SubItem( usedItem, 1 );
			item.MissingPart = 0;
			return true;
			}
		cr.Say( SAY_NETMSG, "Деталь не подходит." );
		return false;
		}
    return true;
}

bool check_repair( Item& item, Critter& cr )
{
	if( item.Research > 0 ) 
	{
		cr.Say( SAY_NETMSG, "Пока еще непонятно в чем проблема." ); 
		return true;
	}
	
	if( item.MissingPart > 0 && cr.CountItem( item.MissingPart ) == 0 ) 
	{
		cr.Say( SAY_NETMSG, "Пока еще нет нужной детали. Используйте науку, что бы понять что нужно." ); 
		return true;
	}
	
	if ( item.Repair > 0 )
	{
		if( cr.Skill[ SK_REPAIR ] < item.Repair ) 
			cr.Say( SAY_NETMSG, "Недостаточно навыка для того чтобы исправить проблему." ); 
		else
		{
			if( item.MissingPart > 0 )
			{
				cr.Say( SAY_NETMSG, "Вы определили неисправность и устранили ее, использовав необходимую деталь." );
				
				cr.DeleteItem( item.MissingPart, 1 );
				item.MissingPart = 0;
			}
			else
				cr.Say( SAY_NETMSG, "Вы определили неисправность и устранили ее." );
			
			item.Repair = 0;
		}
	}
	
    return true;
}

bool check_science( Item& item, Critter& cr)
{
	uint16 science = item.Research;
	uint16 parts = item.MissingPart;
	
	if( science > 0 )
	{
		if( cr.Skill[ SK_SCIENCE ] < science ) 
			cr.Say( SAY_NETMSG, "Недостаточно навыка для того чтобы определить проблему." );
		else
		{
			if( parts > 0 ) 
			{
				cr.Say( SAY_NETMSG, "Вы определили и пометили неисправность, осталось добавить деталь:" ); 
				cr.SayMsg( SAY_NETMSG, TEXTMSG_ITEM, parts * 100 );
			}
			else if( item.Repair > 0 )
				cr.Say( SAY_NETMSG, "Вы определили и пометили неисправность, остается применить практические навыки." );
			else 
				cr.Say( SAY_NETMSG, "Вы определили неисправность и устранили ее." );
			
			item.Research = 0;
		}
	}
	else
	{
		if( parts > 0 ) 
		{
			cr.Say( SAY_NETMSG, "Для починки необходима деталь:" ); 
			cr.SayMsg( SAY_NETMSG, TEXTMSG_ITEM, parts * 100 );
		}
	}

    return true;
}


uint e_ChangeAnims( uint[] @ values )
{
	if( !valid( values ) || values.length() != 1 ) return 0;
	
    Item@ item = GetItem( values[ 0 ] );
	if( !valid(item) ) return 0;

	if( FLAG(item.Flags, ITEM_SHOW_ANIM_EXT) )
		SETFLAG(item.Flags, ITEM_SHOW_ANIM_EXT);
	else
		UNSETFLAG(item.Flags, ITEM_SHOW_ANIM_EXT);
	
	UNSETFLAG( item.Flags, ITEM_HIDDEN );
	item.Update();
	return 0;
}
