#ifndef CRAFT
#define CRAFT

#include "_utils.fos"
#include "_ltp.fos"
#include "craft_h.fos"
#include "gathering_h.fos"
import bool HandsTied( Critter& cr ) from "handcuffs";
import void items_crafted( Item@[]& items, uint[]& itemsCount, Item@[]& resources, Critter& crafter ) from "main";

#define CRITTER_UNABLE_TO_CRAFT # (crafter)!valid(crafter) || crafter.IsBusy() || crafter.IsDead() || crafter.IsKnockout() || HandsTied(crafter) || IsTired(crafter) || crafter.IsInjured()
#define CRAFT_MIN_NUM (600)
#define CRAFT_MAX_NUM (9497)

dictionary craftData;

bool IsAbleCraftByParams(Critter& crafter, CraftItem& craft)
{
	uint[] params;
	int[] paramVals;
	bool[] paramOrs;
	craft.GetNeedParams(params, paramVals, paramOrs);

	for( uint i = 0, j = params.length(); i < j; i++ )
    {
        uint param = params[ i ];
        int val = paramVals[ i ];
        bool or_cmd = paramOrs[ i ];

        if( crafter.ParamBase[ param ] < val )
		{
			if(!or_cmd)
			{
				return false;
			}
			continue;
		}

        // Skip or
        if(or_cmd) for( ; i < j - 1 && paramOrs[ i ]; i++ );
    }
	return true;
}

void GetItemInBench(uint16 pid, Item@& itemPtr, uint count, Item@ bench)
{
	ProtoItem@ benchProto = GetProtoItem(bench.GetProtoId());
	if(benchProto.Type != ITEM_TYPE_CONTAINER)
	{
		return;
	}

    Item@[] temp;
	if(!FLAG( bench.LockerCondition, LOCKER_LOCKED ))
	{
		bench.GetItems(uint(-1), temp);
	}

    for(uint i = 0, len = temp.length(); i < len; i++)
    {
        if(temp[i].GetProtoId() == pid && temp[i].GetCount() >= count)
        {
            @itemPtr = temp[i];
			return;
        }
    }
}

bool CheckHasItemsList(Critter& crafter, Item@ bench, Item@[]@ list, uint[]@ listCount, uint16[]& resPids, uint[]& resCounts, bool[]& resOrs)
{
	for( uint i = 0, j = resPids.length(); i < j; i++ )
    {
        uint16 resPid = resPids[ i ];
        uint count = resCounts[ i ];
        bool or_cmd = resOrs[ i ];

		Item@ currRes = crafter.GetItem(resPid, -1);

        if( !valid(currRes) || currRes.GetCount() < count )
		{
			if(valid(bench))
			{
				GetItemInBench(resPid, currRes, count, bench);

				if(!valid(currRes))
				{
					return false;
				}
			}
			else if(!or_cmd)
			{
				return false;
			}
			else
			{
				continue;
			}
		}

		if(valid(list))
		{
			list.insertLast(currRes);
		}
		if(valid(listCount))
		{
			listCount.insertLast(count);
		}

        // Skip or
        if(or_cmd ) for( ; i < j - 1 && resOrs[ i ]; i++ );
    }

	return true;
}

bool ShouldGiveTimeout(Critter& crafter, CraftItem& craft)
{
	//For future - APAMk2
	return true;
}

bool ShouldGiveXP(Critter& crafter, CraftItem& craft)
{
	//For future - APAMk2
	return true;
}

void GetCraftOutput(Critter& crafter, CraftItem& craft, Item@[]& itemList, uint[]& countList)
{
	uint16[] itemPids;
	uint[] itemCounts;
	craft.GetOutItems(itemPids, itemCounts);
	for( uint i = 0, j = itemPids.length(); i < j; i++ )
    {
        uint16 pid = itemPids[ i ];
        uint count = itemCounts[ i ];
		ProtoItem@ proto = GetProtoItem(pid);
		if(!valid(proto))
		{
			return;
		}
        
		if(proto.Stackable)
		{
			Item@ crafted = crafter.AddItem(pid, count);
			if(valid(crafted))
			{
				itemList.insertLast(crafted);
				countList.insertLast(count);
			}
			continue;
		}

		for(uint currItemCount = 0; currItemCount < count; currItemCount++)
		{
			Item@ crafted = crafter.AddItem(pid, 1);
			if(valid(crafted))
			{
				itemList.insertLast(crafted);
				countList.insertLast(1);
			}
		}
    }
}

void ask_GetCraftItems( Critter& cr )
{
	cr.ShowScreen( SCREEN_DIALOGBOX, 8, "answer_GetCraftItems" );
	cr.Say( SAY_DIALOGBOX_TEXT, "Choose your option:" );
	cr.Say( SAY_DIALOGBOX_BUTTON( 0 ), "Tools" );
	cr.Say( SAY_DIALOGBOX_BUTTON( 1 ), "Tools X5" );
	cr.Say( SAY_DIALOGBOX_BUTTON( 2 ), "Consumables" );
	cr.Say( SAY_DIALOGBOX_BUTTON( 3 ), "Consumables X5" );
	cr.Say( SAY_DIALOGBOX_BUTTON( 4 ), "Consumables X25" );
	cr.Say( SAY_DIALOGBOX_BUTTON( 5 ), "Result" );
	cr.Say( SAY_DIALOGBOX_BUTTON( 6 ), "Result X5" );
	cr.Say( SAY_DIALOGBOX_BUTTON( 7 ), "Result X25" );
}

void answer_GetCraftItems( Critter& cr, uint answerI, string& answerS )
{
	uint craftNum = 0;
	if( !craftData.get("" + cr.Id + "n", craftNum) )
	{
		return;
	}

	craftData.delete("" + cr.Id + "n");
	CraftItem@ craft = GetCraftItem(craftNum);
	if( !valid( craft ) )
	{
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_SOMETHING_WENT_WRONG );
		return;
	}
	
	uint16[] pids;
	uint[] amount;
	bool[] ors;
	uint mult;

	switch( answerI )
	{
		case(0): if( craft.GetNeedTools( pids, amount, ors ) == 0 ) return;
			mult = 1; break;
		case(1): if( craft.GetNeedTools( pids, amount, ors ) == 0 ) return;
			mult = 5; break;
		case(2): if( craft.GetNeedItems( pids, amount, ors ) == 0 ) return;
			mult = 1; break;
		case(3): if( craft.GetNeedItems( pids, amount, ors ) == 0 ) return;
			mult = 5; break;
		case(4): if( craft.GetNeedItems( pids, amount, ors ) == 0 ) return;
			mult = 25; break;
		case(5): if( craft.GetOutItems( pids, amount ) == 0 ) return;
			mult = 1; break;
		case(6): if( craft.GetOutItems( pids, amount ) == 0 ) return;
			mult = 5; break;
		case(7): if( craft.GetOutItems( pids, amount ) == 0 ) return;
			mult = 25; break;
		default: return;
	}
	
	spawnItems( cr, mult, pids, amount );
}

void spawnItems( Critter& cr, uint mult, uint16[] pids, uint[] amount )
{
	if( mult == 0 )
	{
		return;
	}
	
	for( uint i = 0, count = pids.length(); i < count; i++ )
	{
		Item@ newitem = cr.AddItem( pids[i], amount[i] * mult );
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_YOU_CRAFTED_PID, "$proto@msg item " + ( pids[i] * 100 ) + "@$amount" + amount[i] * mult );
		
		// Complexity
		if( newitem.GetProtoId() == PID_HANDCUFFS || newitem.GetProtoId() == PID_SHACKLES )
		{
			newitem.LockerComplexity = cr.Skill[ SK_LOCKPICK ];
		}
		
		SayLogGM( cr, crInfo( cr ) + " Crafted " + itemDesc( newitem ) + " ammount: " + amount[i] * mult );
	}
}

bool TryCraft(Critter& crafter, uint craftNum, Item@ bench)
{
	craftData.delete("" + crafter.Id + "n");
	craftData.set("" + crafter.Id + "n", craftNum);
	if(isGM(crafter))
	{
		ask_GetCraftItems( crafter );
		return true;
	}

	if( CRITTER_UNABLE_TO_CRAFT(crafter) )
	{
		crafter.Say(SAY_NETMSG, "NOT ABLE TO CRAFT");
		return false;
	}

	CraftItem@ craft = GetCraftItem(craftNum);
	if(!valid(craft))
	{
		crafter.Say(SAY_NETMSG, "INVALID CRAFT");
		return false;
	}

	if(!IsAbleCraftByParams(crafter, craft))
	{	
		return false;
	}

	uint16[] resPids;
	uint[] resCounts;
	bool[] resOrs;
	craft.GetNeedTools(resPids, resCounts, resOrs);

	if(!CheckHasItemsList(crafter, bench, null, null, resPids, resCounts, resOrs))
	{
		crafter.Say(SAY_NETMSG, "NOT ENOUGH TOOLS");
		return false;
	}

	Item@[] subItems;
	uint[] subItemsCount;
	resPids.resize(0);
	resCounts.resize(0);
	resOrs.resize(0);
	craft.GetNeedItems(resPids, resCounts, resOrs);

	if(!CheckHasItemsList(crafter, bench, subItems, subItemsCount, resPids, resCounts, resOrs))
	{
		crafter.Say(SAY_NETMSG, "NOT ENOUGH RESOURCES");
		return false;
	}

	craftData.set("" + crafter.Id + "i", @subItems);
	craftData.set("" + crafter.Id + "c", @subItemsCount);
	startCraftProcess( crafter, bench );

	return true;
}

void makeCraft(Critter& crafter)
{
	uint craftNum = 0;
	if( !craftData.get("" + crafter.Id + "n", craftNum) )
	{
		return;
	}

	CraftItem@ craft = GetCraftItem(craftNum);
	if(!valid(craft))
	{
		crafter.Say(SAY_NETMSG, "INVALID CRAFT");
		return;
	}

	Item@[]@ subItems = null;
	uint[]@ subItemsCount = null;
	if( !craftData.get( "" + crafter.Id + "i", @subItems ) || !craftData.get( "" + crafter.Id + "c", @subItemsCount ) )
	{
		return;
	}

	craftData.delete("" + crafter.Id + "i");
	craftData.delete("" + crafter.Id + "c");
	craftData.delete("" + crafter.Id + "b");
	craftData.delete("" + crafter.Id + "n");

	Item@[] craftedItems;
	uint[] craftedItemsCounts;
	GetCraftOutput(crafter, craft, craftedItems, craftedItemsCounts);

	items_crafted( craftedItems, craftedItemsCounts, subItems, crafter );
	for(uint i = 0, len = subItems.length(); i < len; i++)
	{
		_SubItem(subItems[i], subItemsCount[i]);
	}

	if(ShouldGiveTimeout(crafter, craft))
	{
		crafter.TimeoutBase[TO_SK_SCIENCE] = __FullSecond + REAL_SECOND(60);
		crafter.TimeoutBase[TO_SK_REPAIR] = __FullSecond + REAL_SECOND(60);
	}
	
	if(ShouldGiveXP(crafter, craft))
	{
		if(craft.Experience > 0)
		{
			crafter.StatBase[ST_EXPERIENCE] += craft.Experience; 
		}
		else
		{
			crafter.StatBase[ST_EXPERIENCE] += __FixBoyDefaultExperience; 
		}
	}
}

// LTP SHIT GOES HERE

bool ltp_inited=false;

void ltp_init()
{
    LTPREG( LTP_CRAFT, process_craft );
    ltp_inited=true;
}

void startCraftProcess( Critter& cr, Item@ bench )
{
    if(!ltp_inited) ltp_init();

	cr.ParamBase[ ST_LTP_SEQUENCE_WAIT ] = 1000;
	cr.ParamBase[ ST_LTP_SEQUENCE ] = 10;
	if( valid( bench ) && !bench.Proto.GroundLevel )
	{
		cr.SetDir(GetDirection(cr.HexX, cr.HexY, bench.HexX, bench.HexY));
		cr.SetAnims( COND_LIFE, 0, ANIM2_REPAIR);
	}
	else
	{
		cr.SetAnims( COND_LIFE, 0, ANIM2_CROUCH);
	}

    StartProcess( cr, LTP_CRAFT, 0, 0, 0, cr.ParamBase[ ST_LTP_SEQUENCE_WAIT ] );
}

void stopCraftProcess( Critter& cr, int type, int time, int param )
{
    StopProcess( cr, true );
}

uint process_craft( Critter@ cr, int& param0, int&, int& )
{
    LTPROCESS( cr, param0, LTP_CRAFT )

    param0++;
    if( param0 > cr.ParamBase[ ST_LTP_SEQUENCE ] )
	{
		makeCraft(cr);
		cr.SetAnims( COND_LIFE, 0, ANIM2_IDLE);
		return 0;
	}

    return cr.ParamBase[ ST_LTP_SEQUENCE_WAIT ];
}

void unsafe_GetAvaiableCrafts( Critter& crafter, int, int, int, string@, int[]@ )
{
	int[] avaiableCrafts;
	for(int i = CRAFT_MIN_NUM; i <= CRAFT_MAX_NUM; i++ )
	{
		CraftItem@ craft = GetCraftItem(i);
		if(!valid(craft))
		{
			continue;
		}

		if(!IsAbleCraftByParams(crafter, craft))
		{	
			continue;
		}

		uint16[] resPids;
		uint[] resCounts;
		bool[] resOrs;
		craft.GetNeedTools(resPids, resCounts, resOrs);

		Item@ bench = null;
		craftData.get( "" + crafter.Id + "b", @bench );
		if(valid(bench) && GetDistantion(crafter.HexX, crafter.HexY, bench.HexX, bench.HexY) > 1)
		{
			craftData.delete("" + crafter.Id + "b");
			@bench = null;
		}

		if(!CheckHasItemsList(crafter, bench, null, null, resPids, resCounts, resOrs))
		{
			continue;
		}

		resPids.resize(0);
		resCounts.resize(0);
		resOrs.resize(0);
		craft.GetNeedItems(resPids, resCounts, resOrs);

		if(!CheckHasItemsList(crafter, bench, null, null, resPids, resCounts, resOrs))
		{
			continue;
		}
		
		avaiableCrafts.insertLast(i);
	}
	crafter.RunClientScript("client_screen_fixboy@UpdateAvaiableCrafts", 0, 0, 0, null, avaiableCrafts);
}

void unsafe_StartCraft( Critter& crafter, int craftNum, int, int, string@, int[]@ )
{
	if(!valid(crafter))
	{
		return;
	}
	Item@ bench = null;
	craftData.get( "" + crafter.Id + "b", @bench );
	TryCraft(crafter, craftNum, bench);
}

void OpenBenchCraft(Critter@ crafter, Item@ bench)
{
	if(!valid(bench))
	{
		return;
	}

	craftData.delete("" + crafter.Id + "b");
	craftData.set("" + crafter.Id + "b", @bench);
	crafter.RunClientScript("client_screen_fixboy@ShowScreen", 0, 0, 0, null, null);
}

void DebugCraft( Critter& crafter, int craftNum, int benchId, int )
{
	Item@ bench = GetItem(benchId);
	TryCraft(crafter, craftNum, bench);
}

#endif