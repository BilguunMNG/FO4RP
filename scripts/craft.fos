#ifndef CRAFT
#define CRAFT

#include "_utils.fos"
#include "_ltp.fos"
#include "craft_h.fos"
#include "gathering_h.fos"
import bool HandsTied( Critter& cr ) from "handcuffs";
import void items_crafted( Item@[]& items, uint[]& itemsCount, Item@[]& resources, Critter& crafter ) from "main";

#define CRITTER_UNABLE_TO_CRAFT # (crafter)!valid(crafter) || crafter.IsDead() || crafter.IsKnockout() || HandsTied(crafter)
#define CRAFT_MIN_NUM (600)
#define CRAFT_MAX_NUM (9497)

dictionary craftData;

bool IsAbleCraftByParams(Critter& crafter, CraftItem& craft)
{
	uint[] skills;
	int[] paramVals;
	bool[] paramOrs;
	craft.GetNeedParams( skills, paramVals, paramOrs);

	for( uint i = 0, j = skills.length(); i < j; i++ )
    {
        uint param = skills[ i ];
        int val = paramVals[ i ];
        bool or_cmd = paramOrs[ i ];

        if( crafter.ParamBase[ param ] < val )
		{
			if(!or_cmd)
			{
				return false;
			}
			
			continue;
		}

        // Skip or
        if( or_cmd )
		{
			for( ; i < j - 1 && paramOrs[ i ]; i++ );
		}
	}
	
	skills.resize(0);
	paramVals.resize(0);
	paramOrs.resize(0);
	
	return true;
}

bool CheckHasItemsList( Critter& crafter, Item@ bench, Item@[]@ list, uint[]@ listCount, uint16[]& resPids, uint[]& resCounts, bool[]& resOrs )
{
	Item@[] crafterInv;
	crafter.GetItems( -1, crafterInv );
	if( valid (bench ) && bench.GetType() == ITEM_TYPE_CONTAINER && !FLAG( bench.LockerCondition, LOCKER_LOCKED ))
	{
		bench.GetItems( uint(-1), crafterInv );
	}

	Item@[] currRes;
	uint[] currResCounts;
	uint itemCount = 0;
	Item@ currInvItem = null;
	
	for( uint i = 0, len = resPids.length(); i < len; i++ )
    {
        uint16 resPid = resPids[ i ];
        uint count = resCounts[ i ];
        bool or_cmd = resOrs[ i ];


		for( uint j = 0, max = crafterInv.length(); j < max; j++ )
		{
			@ currInvItem = crafterInv[j];
			if( valid( currInvItem ) )
			{
				uint16 pid =  currInvItem.GetProtoId();
				if( pid == resPid )
				{
					uint currCount = currInvItem.GetCount();
					currResCounts.insertLast( CLAMP(currCount, 0, count - itemCount ));
					itemCount = CLAMP( itemCount + currCount, 0, count );
					currRes.insertLast( currInvItem );
				}
			}
			
			if( itemCount >= count )
			{
				break;
			}
		}

		if( itemCount < count && !or_cmd )
		{
			return false;
		}
		else if( itemCount < count && or_cmd )
		{
			continue;
		}

		if( valid( list ) )
		{
			Item@ new_res = null;
			for( uint j = 0, max = currRes.length(); j < max; j++ )
			{
				@ new_res = currRes[j];
				if( valid( new_res ) )
				{
					list.insertLast( new_res );
				}
			}
		}
		
		if( valid( listCount ) )
		{
			for( uint j = 0, max = currResCounts.length(); j < max; j++ )
			{
				listCount.insertLast( currResCounts[j] );
			}
		}

        // Skip or
        if( or_cmd )
		{
			for( ; i < len - 1 && resOrs[ i ]; i++ );
		}
	}

	currRes.resize(0);
	currResCounts.resize(0);
	
	return true;
}

bool HookCraftCheck(Critter& crafter, CraftItem& craft)
{
	string scriptName = craft.GetScriptName();
	if(scriptName != "fix_boy@fix_Delayed")
	{
		if( IsTired( crafter ) )
		{
			return false;
		}
	}

	if(scriptName == "fix_boy@fix_Tribal" ||
	   scriptName == "fix_boy@fix_Ozher" ||
	   scriptName == "fix_boy@fix_None")
	{
		if( crafter.IsDmgTwoArm() )
		{ 
			crafter.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_INJURED_CANT_WORK );
			return false; 
		}
	}

	if(scriptName == "fix_boy@fix_Workbench" ||
	   scriptName == "fix_boy@fix_FreeHands" ||
	   scriptName == "fix_boy@fix_AmmoBench" ||
	   scriptName == "fix_boy@fix_LowTier" ||
	   scriptName == "fix_boy@fix_MidTier" ||
	   scriptName == "fix_boy@fix_HiTier")
	{
		if( crafter.IsInjured() )
		{ 
			crafter.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_INJURED_CANT_WORK );
			return false;
		}
	}

	return true;
}


void HookGiveTimeout(Critter& crafter, CraftItem& craft)
{
	string scriptName = craft.GetScriptName();
	if(scriptName == "fix_boy@fix_Delayed")
	{
		crafter.TimeoutBase[TO_SK_SCIENCE] = __FullSecond + REAL_SECOND(60);
		crafter.TimeoutBase[TO_SK_REPAIR] = __FullSecond + REAL_SECOND(60);
		return;
	}

	if(scriptName == "fix_boy@fix_LowTier")
	{
		crafter.TimeoutBase[ TO_SK_REPAIR ] = __FullSecond + REAL_SECOND( 10 );
		return;
	}

	if(scriptName == "fix_boy@fix_MidTier")
	{
		crafter.TimeoutBase[ TO_SK_REPAIR ] = __FullSecond + REAL_SECOND( 60 );
		return;
	}

	if(scriptName == "fix_boy@fix_HiTier")
	{
		crafter.TimeoutBase[ TO_SK_REPAIR ] = __FullSecond + REAL_SECOND( 180 );
		return;
	}
}

void HookGiveXP(Critter& crafter, CraftItem& craft)
{
	string scriptName = craft.GetScriptName();
	int xpAmount = 0;

	if(scriptName == "fix_boy@fix_Tribal")
	{
		xpAmount = 20;
	}
	
	if(scriptName == "fix_boy@fix_Ozher")
	{
		xpAmount = 25;
	}

	if(scriptName == "fix_boy@fix_Workbench")
	{
		xpAmount = 250;
	}

	if(scriptName == "fix_boy@fix_FreeHands")
	{
		xpAmount = 100;
	}

	if(scriptName == "fix_boy@fix_AmmoBench")
	{
		xpAmount = 50;
	}

	if(scriptName == "fix_boy@fix_LowTier")
	{
		xpAmount = 500;
	}

	if(scriptName == "fix_boy@fix_MidTier")
	{
		xpAmount = 1000;
	}

	if(scriptName == "fix_boy@fix_HiTier")
	{
		xpAmount = 5000;
	}

	crafter.StatBase[ST_EXPERIENCE] += xpAmount; 
}

void HookCraftSucc(Critter& crafter, CraftItem& craft)
{
	string scriptName = craft.GetScriptName();
	if(scriptName == "fix_boy@fix_Ozher")
	{
		uint count = crafter.CountItem( PID_KLK );
		if( count > 0 )
		{
			crafter.DeleteItem( PID_KLK, count );
		}
	}
}

void GetCraftOutput(Critter& crafter, CraftItem& craft, Item@[]& itemList, uint[]& countList)
{
	uint16[] itemPids;
	uint[] itemCounts;
	craft.GetOutItems(itemPids, itemCounts);
	for( uint i = 0, j = itemPids.length(); i < j; i++ )
    {
        uint16 pid = itemPids[ i ];
        uint count = itemCounts[ i ];
		ProtoItem@ proto = GetProtoItem(pid);
		if(!valid(proto))
		{
			return;
		}
        
		if(proto.Stackable)
		{
			Item@ crafted = crafter.AddItem(pid, count);
			if(valid(crafted))
			{
				itemList.insertLast(crafted);
				countList.insertLast(count);
			}
			continue;
		}

		for(uint currItemCount = 0; currItemCount < count; currItemCount++)
		{
			Item@ crafted = crafter.AddItem(pid, 1);
			if(valid(crafted))
			{
				itemList.insertLast(crafted);
				countList.insertLast(1);
			}
		}
    }
}

void ask_GetCraftItems( Critter& cr )
{
	cr.ShowScreen( SCREEN_DIALOGBOX, 8, "answer_GetCraftItems" );
	cr.Say( SAY_DIALOGBOX_TEXT, "Choose your option:" );
	cr.Say( SAY_DIALOGBOX_BUTTON( 0 ), "Tools" );
	cr.Say( SAY_DIALOGBOX_BUTTON( 1 ), "Tools X5" );
	cr.Say( SAY_DIALOGBOX_BUTTON( 2 ), "Consumables" );
	cr.Say( SAY_DIALOGBOX_BUTTON( 3 ), "Consumables X5" );
	cr.Say( SAY_DIALOGBOX_BUTTON( 4 ), "Consumables X25" );
	cr.Say( SAY_DIALOGBOX_BUTTON( 5 ), "Result" );
	cr.Say( SAY_DIALOGBOX_BUTTON( 6 ), "Result X5" );
	cr.Say( SAY_DIALOGBOX_BUTTON( 7 ), "Result X25" );
}

void answer_GetCraftItems( Critter& cr, uint answerI, string& answerS )
{
	uint craftNum = 0;
	if( !craftData.get("" + cr.Id + "n", craftNum) )
	{
		return;
	}

	craftData.delete("" + cr.Id + "n");
	CraftItem@ craft = GetCraftItem(craftNum);
	if( !valid( craft ) )
	{
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_SOMETHING_WENT_WRONG );
		return;
	}
	
	uint16[] pids;
	uint[] amount;
	bool[] ors;
	uint mult;

	switch( answerI )
	{
		case(0): if( craft.GetNeedTools( pids, amount, ors ) == 0 ) return;
			mult = 1; break;
		case(1): if( craft.GetNeedTools( pids, amount, ors ) == 0 ) return;
			mult = 5; break;
		case(2): if( craft.GetNeedItems( pids, amount, ors ) == 0 ) return;
			mult = 1; break;
		case(3): if( craft.GetNeedItems( pids, amount, ors ) == 0 ) return;
			mult = 5; break;
		case(4): if( craft.GetNeedItems( pids, amount, ors ) == 0 ) return;
			mult = 25; break;
		case(5): if( craft.GetOutItems( pids, amount ) == 0 ) return;
			mult = 1; break;
		case(6): if( craft.GetOutItems( pids, amount ) == 0 ) return;
			mult = 5; break;
		case(7): if( craft.GetOutItems( pids, amount ) == 0 ) return;
			mult = 25; break;
		default: return;
	}
	
	spawnItems( cr, mult, pids, amount );
}

void spawnItems( Critter& cr, uint mult, uint16[] pids, uint[] amount )
{
	if( mult == 0 )
	{
		return;
	}
	
	for( uint i = 0, count = pids.length(); i < count; i++ )
	{
		Item@ newitem = cr.AddItem( pids[i], amount[i] * mult );
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_YOU_CRAFTED_PID, "$proto@msg item " + ( pids[i] * 100 ) + "@$amount" + amount[i] * mult );
		
		// Complexity
		if( newitem.GetProtoId() == PID_HANDCUFFS || newitem.GetProtoId() == PID_SHACKLES )
		{
			newitem.LockerComplexity = cr.Skill[ SK_LOCKPICK ];
		}
		
		SayLogGM( cr, crInfo( cr ) + " Crafted " + itemDesc( newitem ) + " ammount: " + amount[i] * mult );
	}
}

bool TryCraft(Critter& crafter, uint craftNum, Item@ bench)
{
	craftData.delete("" + crafter.Id + "n");
	craftData.set("" + crafter.Id + "n", craftNum);
	if(isGM(crafter))
	{
		ask_GetCraftItems( crafter );
		return true;
	}

	CraftItem@ craft = GetCraftItem(craftNum);
	if(!valid(craft))
	{
		crafter.Say(SAY_NETMSG, "INVALID CRAFT");
		return false;
	}

	if( CRITTER_UNABLE_TO_CRAFT(crafter) && HookCraftCheck(crafter, craft) )
	{
		crafter.Say(SAY_NETMSG, "NOT ABLE TO CRAFT");
		return false;
	}

	if(!IsAbleCraftByParams(crafter, craft))
	{	
		return false;
	}

	uint16[] resPids;
	uint[] resCounts;
	bool[] resOrs;
	craft.GetNeedTools(resPids, resCounts, resOrs);

	if(!CheckHasItemsList(crafter, bench, null, null, resPids, resCounts, resOrs))
	{
		crafter.Say(SAY_NETMSG, "NOT ENOUGH TOOLS");
		return false;
	}

	Item@[] subItems;
	uint[] subItemsCount;
	resPids.resize(0);
	resCounts.resize(0);
	resOrs.resize(0);
	craft.GetNeedItems(resPids, resCounts, resOrs);

	if(!CheckHasItemsList(crafter, bench, subItems, subItemsCount, resPids, resCounts, resOrs))
	{
		crafter.Say(SAY_NETMSG, "NOT ENOUGH RESOURCES");
		return false;
	}

	craftData.set("" + crafter.Id + "i", @subItems);
	craftData.set("" + crafter.Id + "c", @subItemsCount);
	startCraftProcess( crafter, bench );

	return true;
}

void makeCraft(Critter& crafter)
{
	uint craftNum = 0;
	if( !craftData.get("" + crafter.Id + "n", craftNum) )
	{
		return;
	}

	CraftItem@ craft = GetCraftItem(craftNum);
	if(!valid(craft))
	{
		crafter.Say(SAY_NETMSG, "INVALID CRAFT");
		return;
	}

	Item@[]@ subItems = null;
	uint[]@ subItemsCount = null;
	if( !craftData.get( "" + crafter.Id + "i", @subItems ) || !craftData.get( "" + crafter.Id + "c", @subItemsCount ) )
	{
		return;
	}

	craftData.delete("" + crafter.Id + "i");
	craftData.delete("" + crafter.Id + "c");
	craftData.delete("" + crafter.Id + "b");
	craftData.delete("" + crafter.Id + "n");

	Item@[] craftedItems;
	uint[] craftedItemsCounts;
	GetCraftOutput(crafter, craft, craftedItems, craftedItemsCounts);

	items_crafted( craftedItems, craftedItemsCounts, subItems, crafter );
	for(uint i = 0, len = subItems.length(); i < len; i++)
	{
		_SubItem(subItems[i], subItemsCount[i]);
	}

	HookGiveTimeout(crafter, craft);
	HookGiveXP(crafter, craft);
	HookCraftSucc(crafter, craft);

	crafter.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, STR_EMOTE_CRAFT_SOMETHING );
}

// LTP SHIT GOES HERE

bool ltp_inited=false;

void ltp_init()
{
    LTPREG( LTP_CRAFT, process_craft );
    ltp_inited=true;
}

void startCraftProcess( Critter& cr, Item@ bench )
{
    if(!ltp_inited) ltp_init();

	cr.ParamBase[ ST_LTP_SEQUENCE_WAIT ] = 1000;
	cr.ParamBase[ ST_LTP_SEQUENCE ] = 10;
	if( valid( bench ) && !bench.Proto.GroundLevel )
	{
		cr.SetDir(GetDirection(cr.HexX, cr.HexY, bench.HexX, bench.HexY));
		cr.SetAnims( COND_LIFE, 0, ANIM2_REPAIR);
	}
	else
	{
		cr.SetAnims( COND_LIFE, 0, ANIM2_CROUCH);
	}

    StartProcess( cr, LTP_CRAFT, 0, 0, 0, cr.ParamBase[ ST_LTP_SEQUENCE_WAIT ] );
}

void stopCraftProcess( Critter& cr, int type, int time, int param )
{
    StopProcess( cr, true );
}

uint process_craft( Critter@ cr, int& param0, int&, int& )
{
    LTPROCESS( cr, param0, LTP_CRAFT )

    param0++;
    if( param0 > cr.ParamBase[ ST_LTP_SEQUENCE ] )
	{
		makeCraft(cr);
		cr.SetAnims( COND_LIFE, 0, ANIM2_IDLE);
		return 0;
	}

    return cr.ParamBase[ ST_LTP_SEQUENCE_WAIT ];
}

void unsafe_GetAvaiableCrafts( Critter& crafter, int, int, int, string@, int[]@ )
{
	int[] avaiableCrafts;
	for(int i = CRAFT_MIN_NUM; i <= CRAFT_MAX_NUM; i++ )
	{
		CraftItem@ craft = GetCraftItem(i);
		if(!valid(craft))
		{
			continue;
		}

		if(!IsAbleCraftByParams(crafter, craft))
		{	
			continue;
		}

		uint16[] resPids;
		uint[] resCounts;
		bool[] resOrs;
		craft.GetNeedTools(resPids, resCounts, resOrs);

		Item@ bench = null;
		craftData.get( "" + crafter.Id + "b", @bench );
		if(valid(bench) && GetDistantion(crafter.HexX, crafter.HexY, bench.HexX, bench.HexY) > 1)
		{
			craftData.delete("" + crafter.Id + "b");
			@bench = null;
		}

		if(!CheckHasItemsList(crafter, bench, null, null, resPids, resCounts, resOrs))
		{
			continue;
		}

		resPids.resize(0);
		resCounts.resize(0);
		resOrs.resize(0);
		craft.GetNeedItems(resPids, resCounts, resOrs);

		if(!CheckHasItemsList(crafter, bench, null, null, resPids, resCounts, resOrs))
		{
			continue;
		}
		
		avaiableCrafts.insertLast(i);
	}
	crafter.RunClientScript("client_screen_fixboy@UpdateAvaiableCrafts", 0, 0, 0, null, avaiableCrafts);
}

void unsafe_StartCraft( Critter& crafter, int craftNum, int, int, string@, int[]@ )
{
	if(!valid(crafter))
	{
		return;
	}
	Item@ bench = null;
	craftData.get( "" + crafter.Id + "b", @bench );
	TryCraft(crafter, craftNum, bench);
}

void unsafe_ForgetBench( Critter& crafter, int, int, int, string@, int[]@ )
{
	craftData.delete("" + crafter.Id + "b");
	unsafe_GetAvaiableCrafts( crafter, 0, 0, 0, null, null );
}

void OpenBenchCraft(Critter@ crafter, Item@ bench)
{
	if(!valid(bench))
	{
		return;
	}

	craftData.delete("" + crafter.Id + "b");
	craftData.set("" + crafter.Id + "b", @bench);
	crafter.RunClientScript("client_screen_fixboy@ShowScreen", 0, 0, 0, null, null);
}

void DebugCraft( Critter& crafter, int craftNum, int benchId, int )
{
	Item@ bench = GetItem(benchId);
	TryCraft(crafter, craftNum, bench);
}

#endif