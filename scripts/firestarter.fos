// Author: Anuri

#include "_macros.fos"
#include "FLAMMABLE_H.fos"

import void AskCooking( Critter& cr ) from "cooking";
import void ExplodeEx( Map& map, uint16 hexX, uint16 hexY, uint16 effectPid, uint effectRadius, uint damage, uint damageType, uint damageRadius, uint ownerId )  from "explode";
import void InjureCritter( Critter& cr, uint dmg, uint dmgType, uint8 dir, uint attackerId ) from "combat"; // Export
import void SayLog( Map@ map, string@ message ) from "general_unsafe"; //срет дебагом на локале

#define STATE					Val0 								// Статус 0 - потухло, 1 - горит
#define MAX_FUEL 				Val1 								// Макс допустимый заряд (верхний передел) 
#define CURRENT_FUEL			Val2 								// Текущий заряд
#define EVENT 					Val3 								// Для записи тайм-ивента горения костров и бочек, дыма и пара
#define FIRE_STR 				Val5 								// для горения дикого огня
#define FIRE_BURNING_TIME		REAL_SECOND( 39 ) 					// Время тика горения рукотворного огня
#define WILD_FIRE_BURNING_TIME 	REAL_SECOND( Random( 4, 10 ) )  	// Время тика горения дикого огня
#define EXPLOSION_TIMEOUT		Val6 								// Для записи тайм-ивента взрыва

const uint PIC_BARREL_ANIM_ON = GetStrHash( "art\\items\\firebarrel\\firebarrel.fofrm" );
const uint PIC_BARREL_FULL = GetStrHash( "art\\items\\firebarrel\\barrel_full.png" );

const uint16[] wreckage = { PID_HLAM_MEH, PID_HLAM2_MEH, PID_METAL_LIST_MEH };

bool FireCheck( Critter& cr, Item@ item, Item@ target ) //exported - проверки на разное перед началом работы
{
    Map@ map = cr.GetMap();
    if( !valid( map ) ) 
    {
        return false;
    }
	if( !valid( item ) || !valid(target) )
    {
        return false;
    }
	uint16 firePid = target.GetProtoId();
    if(	FireSource.find(firePid) == -1 )
    {
		return false;
    }

	uint16 itemPid = item.GetProtoId();
    if( FireFuel.find(itemPid) == -1 && Igniters.find(itemPid) == -1 && WaterSource.find(itemPid) == -1 )
    {
		BurnIt( cr, item, target );
		return true;
	}
	if( Igniters.find( item.GetProtoId() ) != -1  )
	{
		Ignite( cr, item, target );
		return true;
	}

	if( WaterSource.find( item.GetProtoId() ) != -1  )
	{
		Extinguish( cr, item, target );
		return true;
	}
	FeedTheFire( cr, item, target );
	return true;
}
//=============ПОДЖИГАНИЕ РУКОТВОРНОГО ОГНЯ===============//
bool Ignite( Critter& cr, Item& item, Item& target )
{
	Map@ map = cr.GetMap();
    if( !valid( map ) ) 
    {
        return false;
    }
	if( target.STATE == 1 )
	{
		cr.Say( SAY_NETMSG, "|0xFFFF00 Огонь уже вовсю полыхает." );
		return false;
	}
	if( target.CURRENT_FUEL == 0 )
	{
		cr.Say( SAY_NETMSG, "|0xFFFF00 Тут нечего разжигать, найдите подходящее топливо." );
		return false;
	}
	if( target.STATE == 0 && target.CURRENT_FUEL > 0 )
	{
		if( item.GetProtoId() == PID_FLINT && Random( 1, 300 ) > cr.Skill[SK_OUTDOORSMAN] )
		{
			_SubItem( item, 1 );
			cr.Say( SAY_NETMSG, "|0xFFFF00 Вы сточили поджиг." );
		}
		target.STATE++;
		_CritAnimateUse(cr);
		cr.Say( SAY_EMOTE, "Разжигает огонь" );
		if( target.GetProtoId() == PID_FIREBARREL )
		{
			target.PicMap = PIC_BARREL_ANIM_ON;
		}
		else
		{
			target.ChangeProto( PID_FIREPLACE2 );
			ProtoItem@ proto = GetProtoItem( PID_FIREPLACE2 );
			target.PicMap = proto.PicMap;			
		}
		target.SetEvent( ITEM_EVENT_WALK, "e_Hot" );
		setAnimState( target );
		uint[] values = {target.Id};
		target.EVENT = CreateTimeEvent( AFTER( REAL_SECOND( 0 ) ), "e_Burn", values, true );
		
		uint16 hx = target.HexX, hy = target.HexY;
		Item@[] itemsInFire;
		map.GetItems( target.HexX, target.HexY, itemsInFire );
		for( uint i = 0; i < itemsInFire.length(); i++ )
			FireUp( itemsInFire[i], WildFires[ Random( 0, WildFires.length() - 1 ) ], 1 );
	}
	return true;
}
//=============ТУШЕНИЕ ОГНЯ===============//
bool Extinguish( Critter& cr, Item& item, Item& target )
{
	Map@ map = cr.GetMap();
    if( !valid( map ) ) 
    {
        return false;
    }
	if( target.STATE == 0 && target.CURRENT_FUEL == 0)
	{
		_SubItem( item, 1 );
		if( item.GetProtoId() == PID_BOTTLE_FULL || item.GetProtoId() ==PID_BOTTLE_DIRTY_FULL )
			cr.AddItem( PID_BOTTLE_EMPTY, 1 );
		else
			cr.AddItem( PID_BOTTLE_GLASS, 1 );
		cr.Say( SAY_EMOTE, "Выливает воду" );
		map.PlaySound( "splash.ogg", target.HexX, target.HexY, 5 );
		cr.Say( SAY_NETMSG, "|0xFF0000 Вы попусту вылили воду, разве так стоит обращаться со столь ценной жидкостью?" );
		return false;
	}
	if( target.STATE == 0 && target.CURRENT_FUEL > 0)
	{
		_SubItem( item, 1 );
		if( item.GetProtoId() == PID_BOTTLE_FULL || item.GetProtoId() ==PID_BOTTLE_DIRTY_FULL )
			cr.AddItem( PID_BOTTLE_EMPTY, 1 );
		else
			cr.AddItem( PID_BOTTLE_GLASS, 1 );
		cr.Say( SAY_EMOTE, "Выливает воду" );
		map.PlaySound( "splash.ogg", target.HexX, target.HexY, 5 );
		cr.Say( SAY_NETMSG, "|0xFF0000 Вы залили водой топливо! Теперь часть непригодна для розжига..." );
		target.CURRENT_FUEL = MAX( target.CURRENT_FUEL - Random( 1800, 5400 ), 0 );
		return false;
	}
	if( target.STATE >= 1 )
	{
		target.STATE--;
		target.CURRENT_FUEL = MAX( target.CURRENT_FUEL - Random( 1800, 5400 ), 0 );
		cr.Say( SAY_EMOTE, "Тушит пламя" );
		map.PlaySound( "STEAM1.ACM", target.HexX, target.HexY, 5 );
		if( target.GetProtoId() == PID_FIREBARREL )
		{
			if( target.CURRENT_FUEL > 0 )
			{
				target.PicMap = PIC_BARREL_FULL;
			}	
			else
			{
				ProtoItem@ proto = GetProtoItem( PID_FIREBARREL );
				target.PicMap = proto.PicMap;
			}
		}
		else if( WildFires.find( target.GetProtoId() ) != -1 )
		{
			target.ChangeProto( Ashes[ Random( 0, Ashes.length() - 1 ) ] );
		}
		else 
		{
			target.ChangeProto( PID_FIREPLACE_OFF );
			ProtoItem@ proto = GetProtoItem( PID_FIREPLACE_OFF );
			target.PicMap = proto.PicMap;
		}

		_SubItem( item, 1 );
		if( item.GetProtoId() == PID_BOTTLE_FULL || item.GetProtoId() ==PID_BOTTLE_DIRTY_FULL )
			cr.AddItem( PID_BOTTLE_EMPTY, 1 );
		else
			cr.AddItem( PID_BOTTLE_GLASS, 1 );
		
		EraseTimeEvent( target.EVENT );
		target.EVENT = 0;
		setAnimState( target );
		Item@ fireFX = map.AddItem( target.HexX, target.HexY, PID_STEAM, 1 );
		uint[] values = {fireFX.Id};
		fireFX.EVENT = CreateTimeEvent( AFTER( REAL_SECOND( 2 ) ),"e_fireFX", values, true );
	}
	return true;
}
//=============ТАЙМ ИВЕНТ ДЛЯ ГОРЕНИЯ РУКОТВОРНОГО ОГНЯ===============//
uint e_Burn( uint[]@ values )
{
	uint itemId = values[0];
	Item@ target = GetItem( itemId );
	if( valid( target ) )    
	{
		target.CURRENT_FUEL = ( target.CURRENT_FUEL - 45 );
		if( target.CURRENT_FUEL > 0 )
		{
			uint16 hexX=0, hexY=0;
			Map @map = target.GetMapPosition( hexX, hexY );
			map.PlaySound( "campfire.ogg", target.HexX, target.HexY, 3 );
			return FIRE_BURNING_TIME;
		}
	
		target.STATE--;

		if( target.GetProtoId() == PID_FIREBARREL )
		{
			ProtoItem@ proto = GetProtoItem( PID_FIREBARREL );
			target.PicMap = proto.PicMap;
		}
		else
		{	
			uint ashPid = Ashes[ Random( 0, Ashes.length() - 1 ) ];
			target.ChangeProto( ashPid );
			ProtoItem@ proto = GetProtoItem( ashPid );
			target.PicMap = proto.PicMap;
		}
		setAnimState( target );
		target.Update();
		uint16 hexX=0, hexY=0;
		Map @map = target.GetMapPosition( hexX, hexY );
		map.PlaySound( "STEAM1.ACM", target.HexX, target.HexY, 5 );
		EraseTimeEvent( target.EVENT );
		target.EVENT = 0;
	}
	return 0;
}
//=======================ТАЙМ ИВЕНТ ДЛЯ УДАЛЕНИЯ СПЕЦЭФФЕКТОВ========================//
uint e_fireFX( uint[]@ values )
{
	uint itemId = values[0];
	Item@ e_fireFX = GetItem( itemId );
	if( valid( e_fireFX ) )  
	{
		DeleteItem( e_fireFX );
	}
return 0;
}
//=============ТЕХ ФУНКЦИЯ ДЛЯ ВКЛ\ВЫКЛ АНИМАЦИИ ОГНЯ===============//
void setAnimState( Item& target )
{
	if( target.STATE == 1 )
	{	
		UNSETFLAG( target.Flags, ITEM_SHOW_ANIM_EXT );
		SETFLAG( target.Flags, ITEM_LIGHT );
		SETFLAG( target.Flags, ITEM_CAN_USE );
		UNSETFLAG( target.Flags, ITEM_CAN_PICKUP );
	}
	else
	{
		SETFLAG( target.Flags, ITEM_SHOW_ANIM_EXT );
		UNSETFLAG( target.Flags, ITEM_LIGHT );
	}
	target.Update();
}
//===============ПОДБРАСЫВАНИЕ ТОПЛИВА В ОГОНЬ=====================//
bool FeedTheFire( Critter& cr, Item& item, Item& target )
{
	Map@ map = cr.GetMap();
	if( target.CURRENT_FUEL == target.MAX_FUEL)
	{	
		cr.Say( SAY_NETMSG, "|0xFFFF00 Горючее уже некуда подкладывать, дайте ему прогореть!" );
		return false;
	}
	_SubItem( item, 1 );
	_CritAnimateUse(cr);
	if( item.GetProtoId() == PID_COAL )
	{
		target.CURRENT_FUEL = MIN(target.CURRENT_FUEL + 5400, target.MAX_FUEL);
		cr.Say( SAY_EMOTE, "Подкладывает уголь" );
		map.PlaySound( "ROCK.ACM", target.HexX, target.HexY, 3 );
	}
	else
	{	
		target.CURRENT_FUEL = MIN(target.CURRENT_FUEL + 1800, target.MAX_FUEL);
		cr.Say( SAY_EMOTE, "Подкладывает топливо" );
		map.PlaySound( "BRDSWELL.ACM", target.HexX, target.HexY, 3 );
	}
	if( target.GetProtoId() == PID_FIREBARREL && target.CURRENT_FUEL > 0 && target.STATE == 0 )
	{
		target.PicMap = PIC_BARREL_FULL;
		target.Update();
	}
	int occupancy_rate = ( target.CURRENT_FUEL * 100 / target.MAX_FUEL );
	cr.Say( SAY_NETMSG, "|0xFFFF00 Кострище заполнено горючими материалами на " +occupancy_rate+ " %" );
	return true;
}
//===============СЖИГАНИЕ ВЕЩЕЙ В ОГНЕ=====================//
void BurnIt( Critter& cr, Item& item, Item& target )
{
	_CritAnimateUse(cr);
	Map@ map = cr.GetMap();
	uint destructablePid = item.GetProtoId();
	if( Destructables.find(destructablePid) == -1 && Explosives.find(destructablePid) == -1 || target.STATE == 0 )
	{	
		cr.Say( SAY_NETMSG, "|0xFF0000 Сжечь предмет не удалось." );
		return;
	}
	else if( Explosives.find(destructablePid) != -1 )
	{
		_SubItem( item, 1 );
		cr.Say( SAY_EMOTE, "Кидает странный предмет в огонь" );
		uint[] values = {target.Id};
		target.EXPLOSION_TIMEOUT = CreateTimeEvent( AFTER( REAL_SECOND( Random( 0, 10 ) ) ),"e_Explosives", values, true );
		return;
	}
	else
	{
		_SubItem( item, 1 );
		cr.Say( SAY_EMOTE, "Кидает предмет в огонь" );
		map.PlaySound( "WAI1XXX2.ACM", target.HexX, target.HexY, 3 );
		return;
	}
}
//============ТАЙМ-АУТ ДЛЯ ВЗРЫВА БРОШЕНОЙ В ОГОНЬ ВЗРЫВЧАТКИ==================//
uint e_Explosives( uint[]@ values )
{
	uint itemId = values[0];
	Item@ target = GetItem( itemId );
	if( valid( target ) )    
	{
		uint16 hexX=0, hexY=0;
		Map @map = target.GetMapPosition( hexX, hexY );
		ExplodeEx( map, hexX, hexY, PID_EXPLODE_ROCKET, 3, Random( 50, 100 ), DAMAGE_EXPLODE, 3, 0 );
		map.AddItem( hexX, hexY, Ashes[ Random( 0, Ashes.length() - 1 ) ], 1 );
		Item@ fireFX = map.AddItem( hexX, hexY, PID_SMOKE, 1 );
		uint[] values = {fireFX.Id};
		fireFX.EVENT = CreateTimeEvent( AFTER( REAL_SECOND( 2 ) ),"e_fireFX", values, true );
		if( target.GetProtoId() == PID_FIREBARREL )
		{
			uint16 randomDebree = Random( 2,5 );
			for( uint i = 0; i < randomDebree; i++ )
			{
				uint16 hx=0, hy=0;
				hx = target.HexX; hy = target.HexY;
				map.MoveHexByDir( hx, hy, Random( 1, 6 ), Random( 1, 3) );
				if( map.IsHexPassed( hx, hy ) )
				{
					map.AddItem( hx, hy, wreckage[ Random( 0, wreckage.length() ) ] , 1 );
				}
			}
		}
		EraseTimeEvent( target.EVENT );
		EraseTimeEvent( target.EXPLOSION_TIMEOUT);
		DeleteItem( target );
	}
	return 0;
}
//============ВОЗГОРАНИЕ ПРИ МЕТАНИИ МОЛОТОВЫХ==================//
bool spawnFire( Map@ map, int x, int y ) //exported учет тока в комбаче для молотова
{
	if(!valid(map)) return false;
	
	if( !map.IsHexPassed( x, y ) )
		return false;
	
	Item@[] heated;	
	map.GetItems( x, y, heated );
	
	for( uint i = 0; i < heated.length(); i++ )
		if( heated[i].GetProtoId() == PID_FIREBARREL || WildFires.find( heated[i].GetProtoId() ) != -1 )
			return false;
	
	Item@ fire = map.AddItem( x, y, WildFires[ Random( 0, WildFires.length() - 1 ) ], 1 );
	if( !valid( fire ) ) 
		return false;

	fire.SetEvent( ITEM_EVENT_WALK, "e_Hot" );	
	fire.FIRE_STR = 1; // сила огня - валка для тайм ивента возгорания
	uint[] values = { fire.Id, 0 };
	fire.EVENT = CreateTimeEvent( AFTER( REAL_SECOND( 2 ) ), "e_FireBurn", values, true );
	SayLog( map, " [Возгорание в координатах (" + fire.HexX + ", " + fire.HexY + " )]" );
	return true;
}
//================ВОЗГОРАНИЕ ПРЕДМЕТОВ РЯДОМ С ОГНЕМ===========================//
bool FireUp( Item& burningItem, uint pid, int strength ) //exported
{
	if( FireSource.find( pid ) == -1 ) 
		return false;
	
	uint firablePid = burningItem.GetProtoId();	
	if( FireFuel.find(firablePid) == -1 && Collaterals.find(firablePid) == -1 && Explosives.find(firablePid) == -1 )
		return false;
		
    Map@ map = GetMap( burningItem.MapId );
    if(!valid(map)) 
        return false;
	
	uint16 hx = burningItem.HexX, hy = burningItem.HexY;
	if( Explosives.find( burningItem.GetProtoId() ) != -1 )
	{
		ExplodeEx( map, hx, hy, PID_EXPLODE_ROCKET, 3, Random( 50, 100 ), DAMAGE_EXPLODE, 3, 0 );
		Item@[] destroyedItems;
		map.GetItems( hx, hy, destroyedItems );
		DeleteItems( destroyedItems );
		map.AddItem( hx, hy, Ashes[ Random( 0, Ashes.length() - 1 ) ], 1 );
	}		
	Item@ fire = map.AddItem( hx, hy, WildFires[ Random( 0, WildFires.length() - 1 ) ], 1 );
	map.PlaySound( "WAI1XXX2.ACM", hx, hy, 3 );
	fire.SetEvent( ITEM_EVENT_WALK, "e_Hot" );	
	if( valid( fire ) )
		DeleteItem( burningItem );
			
	fire.FIRE_STR = strength;
	uint[] values = { fire.Id, 0 };
	fire.EVENT = CreateTimeEvent( AFTER( REAL_SECOND( 2 ) ), "e_FireBurn", values, true );
	SayLog( map, " [Возгорание в координатах (" + fire.HexX + ", " + fire.HexY + " )]" );
	return true;
}

void e_Hot(Item& item, Critter& crit, bool entered, uint8 dir) 
{
	if( entered )
	{
		if( crit.GetTimeEvents( CTE_DYSPNEA, null, null, null ) == 0 )
			crit.AddTimeEvent( "cte_Hot", 0, CTE_DYSPNEA, 0 );
	}
	else crit.EraseTimeEvents( CTE_DYSPNEA );
}
//=============ПОДНИМАЕМ ТЕМПЕРАТУРУ КРИТЕРА==================//
uint cte_Hot( Critter& cr, int identifier, uint& rate )
{
	if( cr.IsDead() ) return 0;
	
	Map@ map = cr.GetMap();
	if( !valid( map ) ) return 0;
	
	bool isBurning = false;

	Item@[] fire;
	uint count = map.GetItems( cr.HexX, cr.HexY, fire );
	for( uint i = 0; i < count; i++ )
		if( FireSource.find( fire[i].GetProtoId() ) != -1 && fire[i].STATE == 1 )
		{
			isBurning = true;
			break;
		}
		
	if( !isBurning ) return 0;
	
	cr.ParamBase[CR_TEMP]++;
	InjureCritter( cr, cr.ParamBase[CR_TEMP], DAMAGE_FIRE, 0, 0 );
	rate++;
	return REAL_SECOND( 1 );
}
//==========ТАЙМ-ИВЕНТ ДЛЯ ГОРЕНИЯ ДИКОГО ОГНЯ===============//
uint e_FireBurn( uint[] @ values )
{
	if( !valid( values ) || values.length() != 2 ) return 0;
	
    Item@ item = GetItem( values[ 0 ] );
	if( !valid(item) ) return 0;

	if( item.FIRE_STR > 0 ) 
	{
        values[1]++;
		if( values[1] >= 60 ) 
		{ 
			values[1] = 0; 
			item.FIRE_STR -= Random( 0, 1); 
		}
		
		Map@ map = GetMap( item.MapId );
		if( !valid( map ) ) return 0;

		if( Random(0,1) == 0 ) 
		{
			uint16 hx = item.HexX, hy = item.HexY;
			Item@[] items;
			map.GetItems( item.HexX, item.HexY, items );
			for( uint i = 0; i < 6; i++ ) 
			{
				hx = item.HexX; hy = item.HexY;
				map.MoveHexByDir( hx, hy, i, 1 );
				map.GetItems( hx, hy, items );
			}
			for( uint i = 0; i < items.length(); i++ )
			FireUp( items[i], WildFires[ Random( 0, WildFires.length() - 1 ) ], 1 );
		}
		uint16 hx = item.HexX, hy = item.HexY;
		Item@ fireFX = map.AddItem( hx, hy, PID_SMOKE, 1 );
		map.PlaySound( "forest_fire2.ogg", hx, hy, 3 );
		uint[] values = {fireFX.Id};
		fireFX.EVENT = CreateTimeEvent( AFTER( REAL_SECOND( 2 ) ),"e_fireFX", values, true );

		Critter@[] targetCR;
		uint count = map.GetCrittersHex( item.HexX, item.HexY, 0, FIND_LIFE_AND_KO, targetCR );
		for( uint i = 0; i < count; i++ )
			if( targetCR[i].GetTimeEvents( CTE_DYSPNEA, null, null, null ) == 0 )
				targetCR[i].AddTimeEvent( "cte_Hot", 0, CTE_DYSPNEA, 0 );
		return WILD_FIRE_BURNING_TIME;
    }
	
	if( WildFires.find( item.GetProtoId() ) != -1 )   
	{
		item.ChangeProto( Ashes[ Random( 0, Ashes.length() - 1 ) ] );
		return 0;
	}
	item.STATE = 0;
	EraseTimeEvent( item.EVENT );
	item.EVENT = 0;
    return 0;
}