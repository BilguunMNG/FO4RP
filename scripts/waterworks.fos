// Author: Anuri

#include "_utils.fos"
#include "_ltp.fos"
#include "STAT_MODS_H.fos"

import bool checkTiredness( Critter& cr, int max, int add ) from "fix_boy";
import void ProccessDrink( Critter& cr, Critter& target, Item& item ) from "food";
import void Cleaning( Critter& player, uint soap_pid, int water_source ) from "main";

#define STATE 						Val0
#define MAX 						Val1
#define REMAINING_CHARGE			Val2
#define EVENT 						Val3
#define BREAK						Val4
#define BUCKET_POSITION				Val6

#define WATER_FILL_TIME 			REAL_MINUTE( Random( 15, 45 ) )

#define REMAINING_USES				Val0
#define DNA							Val1
#define EXTRA_WEIGHT				Val2

#define MAP_TIME_DATA   			( 1 )

const string[] WellReelSounds = { "wellReel1.ogg", "wellReel2.ogg" };

// Интерактивное меню ку3, точка входа main.fos
class MenuWell: CenteredMenuHandler {
    uint target_id;
    uint map_id;
	
    MenuWell(Item& target, Map& map) {
        target_id = target.Id;
        map_id = map.Id;
    }

    bool MenuUpdate( Critter& cr, iDialogBox& menu ) {
        Map@ map = GetMap( map_id );
        Item@ target = GetItem( target_id );
		Item@ bucket = target.GetItem( PID_EMPTY_BUCKET, 0 );
		Item@ bucket2 = target.GetItem( PID_WATER_BUCKET, 0 );
		Item@ chain = target.GetItem( PID_CHAIN, 0 );
		
        if( map is null || target is null ) {
            return false;
        }
	
		if( ( valid( bucket ) || valid( bucket2 ) || target.BUCKET_POSITION > 0 ) && valid( chain ) ) 
		{ 
			@ bucket = valid( bucket) ? bucket : bucket2;
			if( target.BUCKET_POSITION == 0 ) {
				if( menu.Button( "Опустить ведро" ) ) {
					target.BUCKET_POSITION = 9 - target.REMAINING_CHARGE / 100;
					target.REMAINING_CHARGE += bucket.REMAINING_USES;
					DeleteItem( bucket );
					PlayChainSound( map, target );
					return true;
				}
			} else {
				if( menu.Button( "Поднять ведро" ) ) {
					start_waterwell( cr, target );
					return false;
				}
			}
		}
		
		if( menu.Button( "Осмотреть колодец" ) ) {
			ShowContainer( cr, target, TRANSFER_HEX_CONT_UP );
			return false;
		}
		return true;
    }
	
	// UI менюхи
    string@ Description( Critter& cr ) {
		Item@ target = GetItem(target_id);
		string info;
		string bucket;
		string chain;
		string bucketPos;
		if( ( valid(target.GetItem( PID_EMPTY_BUCKET, 0 )) || valid(target.GetItem( PID_WATER_BUCKET, 0 ) ) || target.BUCKET_POSITION != 0 )) {
			
			target.BUCKET_POSITION > 0 ? bucket = "\nВедро спущено." : bucket = "\nВедро на месте.";
		} else {
			bucket = "\nВедра нет!";
		}

		if( valid( target.GetItem( PID_CHAIN, 0 ) ) ) {
			
		chain =	"\nЦепь на месте.";
		} else {
			chain = "\nВедро не чем привязать.";
		}
		
		if( target.BUCKET_POSITION != 0 ) {
			bucketPos = "\nПоложение ведра: " + target.BUCKET_POSITION;
		}
		
		info += "В колодце осталось: " + target.REMAINING_CHARGE;
		info += " " + bucket;
		info += " " + chain;
		info += " " + bucketPos;
        return info;
    }
	
    string@ ButtonCancel() {
        return ButtonDecorator( "Скрыть меню", null );
    }
	
    void OnMenuDraw(Critter& cr) {
        cr.Say(SAY_NETMSG, DebugMenu(cr));
    }
}

// точка входа из main.fos при юзе рукой
void StartMenuWell( Critter& cr, Item& target) // exported
{
    Map@ map = cr.GetMap();
    if( map is null ) {
        return;
    }

    iMenuHandler@ handler = MenuWell(target, map);
    iDialogBox@ menu = OpenMenu( cr, "Колодец", handler );
}

void PlayChainSound( Map& map, Item & target ) {
	map.PlaySound( "wellChain.ogg", target.HexX, target.HexY, 5 );
	uint[] values = {target.Id, map.Id};
	CreateTimeEvent( AFTER( REAL_SECOND( 3 ) ), "e_Splash", values, false );
}

uint e_Splash( uint[]@ values ) {
	
	int itemId = values[0];
	Item@ target = GetItem( itemId );
	int mapId = values[1];
	Map@ map = GetMap( mapId );
	map.PlaySound( "splash.ogg", target.HexX, target.HexY, 5 );
	return 0;
}

// LongTimeProcess
bool ltp_inited = false;
void ltp_init()
{
	LTPREG( LTP_WATERWELL, process_waterwell )
	ltp_inited = true;
}

bool start_waterwell( Critter& cr, Item& target )
{
	if(!ltp_inited) { 
		ltp_init();
	}
	
	Map@ map = cr.GetMap();		
	
	if( valid( target ) ) {
		
		if( target.REMAINING_CHARGE < 1 ) {
			cr.Say( SAY_NETMSG, "|0xFFFF00 Воды больше нет." );
			return false;
		}
		
		StartProcess( cr, LTP_WATERWELL, 0, 0, target.Id, 0 );
		return true;
	}
	return false;
}

uint process_waterwell( Critter@ cr, int& param0, int& param1, int& param2 )
{
 	LTPROCESS( cr, param0, LTP_WATERWELL )
	uint hit_pause = ACTION_PAUSE_BASE - ( cr.Stat[ST_AGILITY] * ACTION_PAUSE_BONUS_RATE );
	uint action_pause = CLAMP( hit_pause, ACTION_PAUSE_MIN, ACTION_PAUSE_MAX );
	Item@ target = GetItem( param2 );
	Map@ map = cr.GetMap();
	
  	if( valid( target ) && valid( map ) ) {
		
		_CritAnimateUse(cr);
		uint autoemote = Random( 1, 10 );
		if( autoemote == 10 ) { 
			cr.Say( SAY_EMOTE, "Крутит бабину" );
		}
		
		param0++;
		
		CreateTimeEvent( AFTER( REAL_MS( 1000 ) ), "e_TiredenessTimeout", cr.Id, true);
		
		target.BUCKET_POSITION --; 
		
		map.PlaySound( WellReelSounds[ Random( 0, WellReelSounds.length() -1 ) ], target.HexX, target.HexY, 5 );
		
		if ( target.BUCKET_POSITION != 0) {
			return action_pause;
		} else {
			Item@ fullBucket = target.AddItem( PID_WATER_BUCKET, 1, 0 );
			target.REMAINING_CHARGE -= fullBucket.Proto.Partial_Item;
			fullBucket.REMAINING_USES = fullBucket.Proto.Partial_Item;
			fullBucket.EXTRA_WEIGHT = fullBucket.REMAINING_USES * 100;
			fullBucket.DNA = PID_GLASS_BOTTLE_DIRTY_FULL;
			fullBucket.Update();
		}			
	}
	return 0;
}

uint e_TiredenessTimeout(uint[]@ values)
{
	Critter@ cr = GetCritter( values[0] ); 
	uint fatigue_per_action = ACTION_FATIGUE_BASE - ( cr.Stat[ST_ENDURANCE] * ACTION_FATIGUE_RATE );
	uint fatigue = CLAMP( fatigue_per_action, ACTION_FATIGUE_MIN, ACTION_FATIGUE_MAX);
	cr.TimeoutBase[ TO_TIREDNESS ] = __FullSecond + cr.Timeout[ TO_TIREDNESS ] + REAL_SECOND( fatigue );
	return 0;
}

//~run waterworks _WellsInit 0 0 0
void _WellsInit(Critter& player, int param0, int param1, int param2)
{
	FoceWellsCharge();
}

//import void FoceWellsCharge() from "waterworks";
void FoceWellsCharge()
{
    Map@[] maps;
    for( int i = 0, iend = GetAllMaps( 0, maps ); i < iend; i++)
	{   
		CheckMapWellEvent( maps[i] );
	}
}

bool CheckMapWellEvent( Map& map )
{
	Item@[] activeWells;
	for( int i = 0, iend = Wells.length(); i < iend; i++ ) {
		map.GetItems( Wells[i], activeWells );
	}
	
	if( activeWells.length != 0 ) {
		
		for( int i = 0, iend = activeWells.length(); i < iend; i++ ) {
			Item@ well = activeWells[i];
			uint[] values = { well.Id };
			well.EVENT = CreateTimeEvent( AFTER( WATER_FILL_TIME ), "e_WellCharge", values, true );
			values.resize(0);
		}
	}

	activeWells.resize(0);
    return false;
} 

uint e_WellCharge( uint[] @ values ) 
{
	Item @ well = GetItem( values[ 0 ] );
	Map@ map = GetMap( well.MapId );
	
	map.SetText( well.HexX, well.HexY, COLOR_LGRAY, ":журчание воды:" );
	Log("Колодец на карте: "+map.Id + " активен");
	
	well.REMAINING_CHARGE += CLAMP( Random( 50, 100 ), 0, well.MAX );
	
	return WATER_FILL_TIME;
}