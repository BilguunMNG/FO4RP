#include "_utils.fos"
#include "_ltp.fos"

import uint8 checkSand( Map& map, uint16 tx, uint16 ty ) from "qmap_sand";
import uint8 checkWaterAround( Map& map, uint16 tx, uint16 ty, uint8 coast_flags, uint8 radius, bool smartRadius ) from "qmap_water";
import uint8 checkCoast( Map& map, uint16 tx, uint16 ty ) from "qmap_coast";
import uint8 checkWater( Map& map, uint16 tx, uint16 ty ) from "qmap_water";

#define HAS_BAIT 			Val0 	// есть приманка - записывает pid
#define DEPTH	 			Val1 	// Глубина
#define HAS_FISH 			Val2 	// есть ли рыба на крючке
#define EVENT				Val3	// Валка для тайм-ивента
#define FISH_SIZE			Val4 	// Тип пойманной рыбы
#define FISH_STAMINA		Val5 	// Усталость рыбы
#define FISH_ACTION			Val6 	// Текущее действие рыбы
#define BAIT_EATEN			Val7 	// Индикатор сожранной наживки
#define SHOW_FISH			Val8 	// Маркер для инфо-меню о показе размера рыбы
#define SHOW_ACTION			Val9 	// Маркер для инфо-меню о показе действий рыбы

#define ACTION_PULL			( 1 )	// Рыба тянет
#define ACTION_JINK			( 2 ) 	// Рыба дергается

const uint16[] Invalid_maps =   {};

/* ГЛУБИНЫ, НА КОТОРЫХ ВОДИТСЯ РЫБА, ПРИМАНКИ:
 1 PID_FISH_SMALLEST, PID_FISH_SMALL
 2 PID_FISH_SMALL, PID_FISH
 3 PID_FISH, PID_FISH_BIG
 4 PID_FISH_BIG, PID_FISH_BIGGEST
 
/* ПЕРЕЧЕНЬ ПРИМАНОК И РЕЗУЛЬТАТА:
 1 PID_MAGGOT 			- личинки 					- PID_FISH_SMALLEST, PID_FISH_SMALL
 2 PID_ROACH 			- рад-таракан 				- PID_FISH_SMALLEST, PID_FISH_SMALL
 3 PID_MANTIS_MEAT 		- лапа мантиса 				- PID_FISH_SMALLEST, PID_FISH_SMALL, PID_FISH
 4 PID_MUTMUSH 			- мутогриб 					- PID_FISH_SMALLEST, PID_FISH_SMALL, PID_FISH
 5 PID_RADCVET_SEED 	- семечко радцвета 			- PID_FISH_SMALL, PID_FISH
 6 PID_CORN_SEED 		- зерно кукурузы			- PID_FISH_SMALL, PID_FISH
 7 PID_RAD_MEAT 		- некачественное мясо 		- PID_FISH, PID_FISH_BIG
 8 PID_PLAYERS_EAR 		- ухо человека 				- PID_FISH, PID_FISH_BIG
 9 PID_THORAX 			- брюшко муравьиного льва	- PID_FISH, PID_FISH_BIG, PID_FISH_BIGGEST
 10 PID_FISH_SMALLEST 	- мелкая рыбешка 			- PID_FISH, PID_FISH_BIG, PID_FISH_BIGGEST
 11 PID_RAT_MEAT 		- тушка крысы 				- PID_FISH_BIG, PID_FISH_BIGGEST
 12 PID_MEAT 			- мясо 						- PID_FISH_BIG, PID_FISH_BIGGEST
 13 PID_MASTICATORS_EAR - ухо нигера 				- Вытащить болотника живьем
*/

class Fish
{
	uint16 pid;
	uint8 size;
	uint8 max_depth;
	uint stamina;
	uint16[] bait;
	
	Fish( uint16 pid, uint8 size, uint8 max_depth, uint stamina )
	{
        this.pid = pid;
        this.size = size;
        this.max_depth = max_depth;
        this.stamina = stamina;
	}
	
	bool likes( uint16 lure ) {
		return this.bait.find( lure ) != -1;
	}
}

class FishCollection
{
	Fish@[] fishes;
	FishCollection() 
	{
	}
  
	FishCollection@ fish( uint16 pid, uint8 size, uint8 max_depth, uint stamina ) 
	{
		this.fishes.insertLast( Fish( pid, size, max_depth, stamina ) );
		return this;
	}
  
	FishCollection@ bait( uint16 bait ) 
	{
		this.fishes[ this.fishes.length() - 1 ].bait.insertLast( bait );
		return this;
	}
	
	FishCollection@ get_by_depth( uint8 depth ) 
	{
		FishCollection result;
		for( uint i=0, len = this.fishes.length(); i<len; i++ ) {
			if(this.fishes[i].max_depth <= depth ) {
				result.fishes.insertLast( this.fishes[i] );
			}
		}
		return result;
	}
		
	FishCollection@ get_by_bait( uint16 lure ) 
	{
		FishCollection result;
		for( uint i=0, len = this.fishes.length(); i<len; i++ ) {
			if( this.fishes[i].likes(lure) ) {
				result.fishes.insertLast( this.fishes[i] );
			}
		}
		return result;
	}
	
	Fish@ get_random()
	{
		uint len = this.fishes.length();
		if( len > 0 ) {
				return this.fishes[ Random( 0, len-1 ) ];
		} else {
			return null; 
		}
	}
}

FishCollection@ fishes = FishCollection()
//             	 Pid,         size, max_depth, stamina, 						 preffered bait
	.fish( PID_FISH_SMALLEST,   1,		1,		200 ).bait( PID_MAGGOT ).bait( PID_ROACH ).bait( PID_MANTIS_MEAT ).bait( PID_MUTMUSH )
	.fish( PID_FISH_SMALL,      2,		2,		400 ).bait( PID_MAGGOT ).bait( PID_ROACH ).bait( PID_MANTIS_MEAT ).bait( PID_MUTMUSH ).bait( PID_RADCVET_SEED ).bait( PID_CORN_SEED )
	.fish( PID_FISH,			3,		3,		600 ).bait( PID_MANTIS_MEAT ).bait( PID_MUTMUSH ).bait( PID_RADCVET_SEED ).bait( PID_CORN_SEED ).bait( PID_RAD_MEAT ).bait( PID_PLAYERS_EAR ).bait( PID_THORAX ).bait( PID_FISH_SMALLEST )
	.fish( PID_FISH_BIG,      	4,		4,		800 ).bait( PID_RAD_MEAT ).bait( PID_PLAYERS_EAR ).bait( PID_THORAX ).bait( PID_FISH_SMALLEST ).bait( PID_RAT_MEAT ).bait( PID_MEAT )
	.fish( PID_FISH_BIGGEST,	5,		4,	   1000 ).bait( PID_THORAX ).bait( PID_FISH_SMALLEST ).bait( PID_RAT_MEAT ).bait( PID_MEAT );

Fish@ getFish( Item@ floater ) 
{
	uint depth = floater.DEPTH;
	uint16 baitPid = floater.HAS_BAIT;
	return fishes.get_by_depth( depth ).get_by_bait( baitPid ).get_random();
}

bool PrepareFishing( Critter& cr, Item& fishingRod, int hexX, int hexY )
{
	Map@ map = cr.GetMap();
    if( !valid( map ) ) { return false; }

	if( Invalid_maps.find( map.GetProtoId() ) != -1 ) { cr.Say( SAY_NETMSG, "|0xFFFF00 В этом месте рыбы, определенно нет." ); return false; }

	if( !valid( fishingRod ) ) { return false; }
	
	if( !hasItem( cr, PID_ROD_STRING_HOOK, SLOT_HAND1 ) ) { cr.Say( SAY_NETMSG, "|0xFFFF00 Возьмите снаряженную удочку в руку." ); return false; }
	
	if( fishingRod.HAS_BAIT <= 0 ) { cr.Say( SAY_NETMSG, "|0xFFFF00 Для ловли рыбы Вам потребуется наживка." ); return false; }

	if( GetDistantion( cr.HexX, cr.HexY, hexX, hexY ) > CLAMP( 2 + ( cr.SkillBase[ SK_FISHING ] / 50 ), 2, 8 ) ) { cr.Say( SAY_NETMSG, "|0xFFFF00 Вы не можете закинуть удочку так далеко." ); return false; }

	check_tiles( cr, fishingRod, hexX, hexY ); 
	
	return true;
}

void check_tiles( Critter& cr, Item& fishingRod, int hexX, int hexY ) 
{
	Map@ map = cr.GetMap();
	if( !valid( map ) ) { return; }
	
	uint8  water_flags = 0; 	

	water_flags = checkWater( map, H2T( hexX ), H2T( hexY ) );
	
	if( water_flags == 0 )
	{
		cr.Say( SAY_NETMSG, "|0xFFFF00 В месте приземления поплавка нет воды." );
		return;
	}
	
	Item@ floater = map.AddItem( hexX, hexY, PID_FLOATER, 1 );
	floater.HAS_BAIT = fishingRod.HAS_BAIT;
	floater.DEPTH = CheckDepth( map, floater );
	
	uint[] values = { floater.Id, cr.Id };
	floater.EVENT = CreateTimeEvent( AFTER( REAL_SECOND( 3 ) ), "e_floaterCheck", values, true );

	start_fishing( cr, fishingRod, floater, map );
}


bool ltp_inited = false;
void ltp_init()
{
    LTPREG( LTP_FISHING, process_fishing )
    ltp_inited = true;
}

bool start_fishing( Critter& cr, Item& fishingRod, Item& floater, Map& map )
{
    if( !ltp_inited )
        ltp_init();

   	femote_Gender( cr,  "закинул удочку", "закинулa удочку");
	map.PlaySound( "rod_throw.ogg", cr.HexX, cr.HexY, 5 );
	StartProcess( cr, LTP_FISHING, 0, floater.Id, fishingRod.Id, 1000 );
	cr.SetAnims( COND_LIFE, 0, ANIM2_WINDUP_UNARMED );
	return true;
}

uint process_fishing( Critter@ cr, int& param0, int& param1, int& param2 )
{
    LTPROCESS( cr, param0, LTP_FISHING )
    
	if( !valid( cr ) )  { return 0; }
	
	Map@ map = cr.GetMap();
	if( !valid( map ) ) { return 0; }
		
	Item@ floater = GetItem( param1 );
	if( !valid( floater ) )  { return 0; }
	
	Item@ fishingRod = GetItem( param2 );
	if( !valid( fishingRod ) )  { return 0; }
	
	if( param0 == 0 ) {
		map.PlaySound( "fishing_reel1.ogg", cr.HexX, cr.HexY, 2 );
        
		if( floater.HAS_FISH <= 0 ) {
			if( Random( 1, 100 ) > 90 ) { //сюда модификатор шанса поклевки от наживки ( можно добавить позже )
				floaterBite( cr, floater, fishingRod );
			}
			
		} else {
			if( Random( 1, 3 ) != 1 ) {
				floaterBite( cr, floater, fishingRod );
			}
		}
		
		return Random( 3, 6 ) * 1000;
		
	} else {
		cr.SetAnims(COND_LIFE, 0, ANIM2_IDLE);
		DeleteItem( floater );
		return 0;
	}
}

uint e_floaterCheck( uint[]@ values )
{
	uint itemId = values[0];
	Item@ floater = GetItem( itemId );
	if( !valid( floater ) ) { return 0;		
	}
	
	uint crtterId = values[1];
	Critter@ cr = GetCritter( crtterId );
	if( !valid( cr ) ) { 
		EraseTimeEvent( floater.EVENT );
		floater.EVENT = 0;
		DeleteItem( floater );
		return 0;		
	}

	if( cr.ParamBase[ ST_LTP_TIME ] == -1 || cr.ParamBase[ ST_LTP_TYPE_DIR_HEX ] == 0 || ( floater.HAS_BAIT == 0 && floater.HAS_FISH == 0 ) ) {
		
		if( floater.HAS_FISH > 0 ) {
			StartMenuFishing( cr, floater );
			return 0;
		}
		
		if( valid( cr ) ) {
			femote_Gender( cr,  "вытащил удочку", "вытащила удочку");
			FinishFishing( cr, floater );
		} else {
			EraseTimeEvent( floater.EVENT );
			floater.EVENT = 0;
			DeleteItem( floater );
		}				
		return 0;
	}
	return REAL_SECOND( 1 );
}

void floaterBite( Critter& cr, Item& floater, Item& fishingRod )
{
	if( !FLAG( floater.Flags, ITEM_HIDDEN ) ) {	
		SETFLAG( floater.Flags, ITEM_HIDDEN );
		uint[] values = { floater.Id, fishingRod.Id, cr.Id };
		
		if (floater.HAS_FISH == 0 && Random( 1, 2 ) == 2 ) {
			Fish@ fish = getFish( floater );
			if( valid( fish ) ) { 
				floater.HAS_FISH = fish.pid;
				floater.FISH_SIZE = fish.size;
				floater.FISH_STAMINA = fish.stamina;
				fishingRod.HAS_BAIT = 0;
				
				uint val = floater.DEPTH * 100 + 50;
				if( Random( 0, val ) < cr.SkillBase [ SK_FISHING ] ) {
					floater.SHOW_FISH = 1;
				}
				
				fishAction( cr, floater );
				CreateTimeEvent( AFTER( REAL_SECOND( 1 ) ), "e_hookedFish", values, true );
			}
		}
		CreateTimeEvent( AFTER( REAL_SECOND( 1 ) ), "e_floaterUp", values, true );
		
	} else {		
		UNSETFLAG( floater.Flags, ITEM_HIDDEN );
	}	
	floater.Update();
}

uint e_floaterUp( uint[]@ values)
{
	uint itemId = values[0];
	Item@ floater = GetItem( itemId );
	uint item2Id = values[1];
	Item@ fishingRod = GetItem( itemId );
	uint crtterId = values[2];
	Critter@ cr = GetCritter( crtterId );
	
	if( valid( floater) && valid( fishingRod ) ) { 
		floaterBite( cr, floater, fishingRod );
	}
	
	return 0;
}

uint e_hookedFish( uint[]@ values)
{
	uint itemId = values[0];
	Item@ floater = GetItem( itemId );
	if( !valid( floater) ) { return 0; }
	
	uint item2Id = values[1];
	Item@ fishingRod = GetItem( itemId );
	if( !valid( fishingRod ) ) { return 0; }
	
	
	if( floater.BAIT_EATEN != 1 ) {
		floater.BAIT_EATEN = 1;
		floater.HAS_BAIT = 0;
		fishingRod.HAS_BAIT = 0;
		
		if( floater.FISH_SIZE == 1 ) {
			return REAL_SECOND( 150 );
		}
		if( floater.FISH_SIZE == 2 ) {
			return REAL_SECOND( 120 );
		}
		if( floater.FISH_SIZE == 3 ) {
			return REAL_SECOND( 90 );
		}
		if( floater.FISH_SIZE == 4 ) {
			return REAL_SECOND( 60 );
		}
		if( floater.FISH_SIZE == 5 ) {
			return REAL_SECOND( 30 );
		}
	}
	
	floater.HAS_FISH = 0;
	return 0;
}

uint CheckDepth( Map& map, Item& floater ) 
{
	uint8 depth = 4;
	uint16 hexX = floater.HexX, hexY = floater.HexY;
	
	for( uint i = 0, len = 5; i < len; i++ ) {
		map.MoveHexByDir( hexX, hexY, i, 7 );
		if( checkWater( map, H2T( hexX ), H2T( hexY ) ) == 0 && ( checkCoast( map, H2T( hexX ), H2T( hexY ) ) != 0 || checkSand ( map, H2T( hexX ), H2T( hexY ) ) != 0 ) ) {
			depth--;
			//Log( "сонар нашел берег на 7, глубина: " + depth );
			//map.SetText( hexX, hexY, COLOR_LGRAY, ":отклик сонара 7:" );
			break;
		}
		hexX = floater.HexX;
		hexY = floater.HexY;
	}
	
	for( uint i = 0, len = 5; i < len; i++ ) {
		map.MoveHexByDir( hexX, hexY, i, 5 );
		if( checkWater( map, H2T( hexX ), H2T( hexY ) ) == 0 && ( checkCoast( map, H2T( hexX ), H2T( hexY ) ) != 0 || checkSand ( map, H2T( hexX ), H2T( hexY ) ) != 0 ) ) {
			depth--;
			//Log( "сонар нашел берег на 5, глубина: " + depth );
			//map.SetText( hexX, hexY, COLOR_LGRAY, ":отклик сонара 5:" );
			break;
		}
		hexX = floater.HexX;
		hexY = floater.HexY;
	}
	
	for( uint i = 0, len = 5; i < len; i++ ) {
		map.MoveHexByDir( hexX, hexY, i, 3 );
		if( checkWater( map, H2T( hexX ), H2T( hexY ) ) == 0 && ( checkCoast( map, H2T( hexX ), H2T( hexY ) ) != 0 || checkSand ( map, H2T( hexX ), H2T( hexY ) ) != 0 ) ) {
			depth--;
			//Log( "сонар нашел берег на 3, глубина: " + depth );
			//map.SetText( hexX, hexY, COLOR_LGRAY, ":отклик сонара 3:" );
			break;
		}
		hexX = floater.HexX;
		hexY = floater.HexY;
	}
	//Log( "Глубина: " + depth );
	return depth;
}

class MenuFishing: CenteredMenuHandler {
    uint target_id;
    uint map_id;
	
    MenuFishing( Item& floater, Map& map ) {
        target_id = floater.Id;
        map_id = map.Id;
    }

    bool MenuUpdate( Critter& cr, iDialogBox& menu ) {
        Map@ map = GetMap(map_id);
        Item@ floater = GetItem( target_id );
		
		if( menu.Button( "Тянуть" ) ) {
			if( floater.FISH_ACTION == ACTION_JINK ) {
				floater.FISH_STAMINA = floater.FISH_STAMINA + FisherResponseModifier( floater );
				cr.Say( SAY_NETMSG, "|0xFFFF00 Вы чувствуете натяжение лески, рыба сопротивляется!" ); 
			} else {
				floater.FISH_STAMINA = floater.FISH_STAMINA - FisherResponseModifier( floater );
				cr.Say( SAY_NETMSG, "|0xFFFF00 Рыба поддается." ); 
			}
			fishAction( cr, floater );
			return true;
		}
		if( menu.Button( "Подсекать" ) ) {
			if( floater.FISH_ACTION == ACTION_PULL ) {
				floater.FISH_STAMINA = floater.FISH_STAMINA + FisherResponseModifier( floater );
				cr.Say( SAY_NETMSG, "|0xFFFF00 Вы чувствуете натяжение лески, рыба сопротивляется!" ); 
			} else {
				floater.FISH_STAMINA = floater.FISH_STAMINA - FisherResponseModifier( floater );
				cr.Say( SAY_NETMSG, "|0xFFFF00 Рыба поддается." ); 
			}
			fishAction( cr, floater );
			return true;
		}
		if( menu.Button( "Вытаскивать" ) ) {
			if( PlayerSkill( cr ) >= floater.FISH_STAMINA ) {
				Profit( cr, floater );
				return false;
			} else {
				floater.FISH_STAMINA = floater.FISH_STAMINA + FisherResponseModifier( floater );
				cr.Say( SAY_NETMSG, "|0xFFFF00 Вы чувствуете натяжение лески, рыба сопротивляется!" ); 
				fishAction( cr, floater );
				return true;
			}
		}
		if( menu.Button( "Перерезать леску" ) ) {
			femote_Gender( cr,  "вытащил удочку", "вытащила удочку");
			FinishFishing( cr, floater );
			if( hasItem( cr, PID_ROD_STRING_HOOK, SLOT_HAND1 ) ) {
				SingleItemProtoChange( cr, PID_ROD, SLOT_HAND1 );
			}
			return false;
		}
		return true;
    }
	
	// UI менюхи
    string@ Description( Critter& cr ) {
		
		Item@ floater = GetItem( target_id );
		if( !valid( floater ) ) {
			string info = "Рыба сорвалась!";
			return info;
		}
		
		uint16 skill = PlayerSkill( cr );
		string PlayerSkill = skill;
		
		string info = "На крючке рыба!";
		string depth = floater.DEPTH;
		string fish_size = "Размер рыбы: "; 
		if( floater.SHOW_FISH == 1 ) {
			fish_size += GetMsgStr( 0, TEXTMSG_ITEM, floater.HAS_FISH * 100 );
		} else {
			fish_size += " Вы не можете определить.";
		}
		
		string stamina = floater.FISH_STAMINA;
		
		uint8 fish_action = floater.FISH_ACTION;
		string action = "Действия рыбы: ";
		if( floater.SHOW_ACTION == 1 ) {
			action += fish_action == 1 ? "Тянет леску" : "Беспорядочно мечется";
		} else {
			action += " Вы не можете определить.";
		}
		
		info += "\nГлубина: " + depth;
		info += "\n" + fish_size;
		//info += "\nВыносливость рыбы: " + stamina;
		info += "\n" + action;
		//info += "\n\nМой навык:" + PlayerSkill;
        return info;
    }

	bool ShouldRedraw( Critter& cr) {
		Item@ floater = GetItem(target_id);
		if( !valid( floater ) ) { return false; }
		
		if( floater.HAS_FISH > 0 ) {
			return true;
		} else {
			FinishFishing( cr, floater );
			if( hasItem( cr, PID_ROD_STRING_HOOK, SLOT_HAND1 ) ) { // ПРОВЕРИТЬ
				SingleItemProtoChange( cr, PID_ROD, SLOT_HAND1 );
			}
			return false;
		}
	}

    string@ ButtonCancel() {
        return ButtonDecorator( "Скрыть меню", null);
    }
}

// точка входа при прирывании процесса лтп, если на крючке есть рыба.
void StartMenuFishing( Critter& cr, Item& floater )
{
    Map@ map = cr.GetMap();
    if( map is null ) {
        return;
    }

    iMenuHandler@ handler = MenuFishing(floater, map);
    iDialogBox@ menu = OpenMenu( cr, "Рыбалка", handler );
}

void FinishFishing( Critter& cr, Item& floater ) 
{
	if( valid( floater ) ) {
		
		Item@ fishingRod = cr.GetItem( PID_ROD_STRING_HOOK, SLOT_HAND1 );
		if( valid( fishingRod ) && floater.BAIT_EATEN > 0 ) {
			fishingRod.HAS_BAIT = 0;
		}
				
		EraseTimeEvent( floater.EVENT );
		floater.EVENT = 0;
		DeleteItem( floater );
		
		if( valid( cr ) ) {
			cr.SetAnims(COND_LIFE, 0, ANIM2_IDLE);
		}
		
		Map@ map = cr.GetMap();
		if( valid( map ) ) {
			map.PlaySound( "fishing_reel1.ogg", cr.HexX, cr.HexY, 2 );
		}
	}
}

void SingleItemProtoChange( Critter& cr, uint16 pid, int slot = -1 )
{
	if( !valid( cr ) ) { return; }
	
	Item@ targetItem = cr.GetItem( 0, slot );
	if( valid( targetItem ) ) {
		cr.MoveItem( targetItem.Id, targetItem.GetCount(), SLOT_INV );
	}
	
	Item@ newItem = cr.AddItem( pid, 1 );
	if( valid( newItem ) ) {
		cr.MoveItem( newItem.Id, newItem.GetCount(), slot );
		
		targetItem.Val0 = newItem.Val0;
		targetItem.Val1 = newItem.Val1;
		targetItem.Val2 = newItem.Val2;
		targetItem.Val3 = newItem.Val3;
		targetItem.Val4 = newItem.Val4;
		targetItem.Val5 = newItem.Val5;
		targetItem.Val6 = newItem.Val6;
		targetItem.Val7 = newItem.Val7;
		targetItem.Val8 = newItem.Val8;
		targetItem.Val9 = newItem.Val9; 
	}
	
	_SubItem( targetItem, 1 );
}

uint PlayerSkill( Critter& cr )
{
	uint skill = 0;
	skill = skill + cr.ParamBase[ ST_STRENGTH ] + cr.ParamBase[ ST_AGILITY ] + cr.ParamBase[ ST_LUCK ] + cr.SkillBase [ SK_FISHING ];
 	return skill;
}

void Profit( Critter& cr, Item& floater )
{
	Map@ map = cr.GetMap();
	if( valid( map ) ) {
		map.PlaySound( "catch_fish.ogg", cr.HexX, cr.HexY, 5 );
	}
	
	string reward = GetMsgStr( 0, TEXTMSG_ITEM, floater.HAS_FISH * 100 );
		
	cr.Say( SAY_EMOTE, "Вытаскивает " + reward );
	
	cr.AddItem( floater.HAS_FISH, 1 );
	FinishFishing( cr, floater );
	raiseSkill( cr );
}

void fishAction( Critter& cr, Item& floater )
{
	floater.SHOW_ACTION = 0;
	if( Random( 1, 100 ) <= 5 ) {
		if( Random( 1, 100 ) > ( cr.Stat[ST_LUCK] * 2 ) ) {
			int chance = Random( 1, 100 );
			if( chance <= floater.FISH_SIZE * 10 ) {
				if( Random( 1, 3 ) == 1 ) {
					SingleItemProtoChange( cr, PID_ROD, SLOT_HAND1 );
					cr.Say( SAY_NETMSG, "|0xFFFF00 Давление резко ослабло, леска лопнула!" );
				} else {
					SingleItemProtoChange( cr, PID_ROD_STRING, SLOT_HAND1 );
					cr.Say( SAY_NETMSG, "|0xFFFF00 Давление резко ослабло, похоже, рыба сорвалась..." );
				}
			}
		}
		floater.BAIT_EATEN;
		FinishFishing( cr, floater );
	}
	
	uint val = floater.DEPTH * 100 + 50;
	if( Random( 0, val ) < cr.SkillBase [ SK_FISHING ] ) {
		floater.SHOW_ACTION = 1;
	}
	
	floater.FISH_ACTION = Random( ACTION_PULL, ACTION_JINK );
}

uint FisherResponseModifier( Item& floater )
{
	uint modifier = floater.FISH_STAMINA;
	modifier = CLAMP( ( modifier * 120 / 100 - modifier ), 0, modifier );
	return modifier;
}

void raiseSkill( Critter& cr )
{
	if( cr.ParamBase[ SK_FISHING ] <= 50 ) {
		cr.ParamBase[ SK_FISHING ] += 3;
		cr.Say( SAY_NETMSG, "|COLOR_GRAY Ваш навык рыбной ловли руды повысился." );
	} else if( cr.ParamBase[ SK_FISHING ] <= 100 ) {
		cr.ParamBase[ SK_FISHING ] += 2;
		cr.Say( SAY_NETMSG, "|COLOR_GRAY Ваш навык рыбной ловли руды повысился." );
	} else if( cr.ParamBase[ SK_FISHING ] <= 150 ) {
		cr.ParamBase[ SK_FISHING ] += 1;
		cr.Say( SAY_NETMSG, "|COLOR_GRAY Ваш навык рыбной ловли руды повысился." );
	} else if( cr.ParamBase[ SK_FISHING ] <= 200 ) {
		if( Random( 1, 3 ) != 1 ) {
			cr.ParamBase[ SK_FISHING ] += 1;
			cr.Say( SAY_NETMSG, "|COLOR_GRAY Ваш навык рыбной ловли руды повысился." );
		}
	} else if( cr.ParamBase[ SK_FISHING ] <= 250 ) {
		if( Random( 1, 2 ) != 1 ) {
			cr.ParamBase[ SK_FISHING ] += 1;
			cr.Say( SAY_NETMSG, "|COLOR_GRAY Ваш навык рыбной ловли руды повысился." );
		}
	} else if( cr.ParamBase[ SK_FISHING ] <= 299 ) {
		if( Random( 1, 3 ) == 3 ) {
			cr.ParamBase[ SK_FISHING ] += 1;
			cr.Say( SAY_NETMSG, "|COLOR_GRAY Ваш навык рыбной ловли руды повысился." );
		}
	} 
}