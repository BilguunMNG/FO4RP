#include "_utils.fos"
#include "_ltp.fos"

import uint8 checkSand( Map& map, uint16 tx, uint16 ty ) from "qmap_sand";
import uint8 checkWaterAround( Map& map, uint16 tx, uint16 ty, uint8 coast_flags, uint8 radius, bool smartRadius ) from "qmap_water";
import uint8 checkCoast( Map& map, uint16 tx, uint16 ty ) from "qmap_coast";
import uint8 checkWater( Map& map, uint16 tx, uint16 ty ) from "qmap_water";

#define HAS_BAIT 			Val0 // есть приманка + качество приманки
#define DEPTH	 			Val1 // √лубина
#define HAS_FISH 			Val2 // есть ли рыба на крючке
#define EVENT				Val3 // ¬алка дл€ тайм-ивента

const uint16[] Fishes = { PID_FISH_SMALLEST, PID_FISH_SMALL, PID_FISH, PID_FISH_BIG, PID_FISH_BIGGEST };
const uint16[] Invalid_maps = {};

bool PrepareFishing( Critter& cr, Item& fishingRod, int hexX, int hexY )
{
	Map@ map = cr.GetMap();
    if( !valid( map ) ) { return false; }

	if( Invalid_maps.find( map.GetProtoId() ) != -1 ) { cr.Say( SAY_NETMSG, "|0xFFFF00 ¬ этом месте рыбы, определенно нет." ); return false; }

	if( !valid( fishingRod ) ) { return false; }
	
	if( !hasItem( cr, PID_ROD_STRING_HOOK, SLOT_HAND1 ) ) { cr.Say( SAY_NETMSG, "|0xFFFF00 ¬озьмите снар€женную удочку в руку." ); return false; }
	
	if( fishingRod.HAS_BAIT <= 0 ) { cr.Say( SAY_NETMSG, "|0xFFFF00 ƒл€ ловли рыбы ¬ам потребуетс€ наживка." ); return false; }

	if( GetDistantion( cr.HexX, cr.HexY, hexX, hexY ) > CLAMP( 2 + ( cr.SkillBase[ SK_FISHING ] / 50 ), 2, 8 ) ) { cr.Say( SAY_NETMSG, "|0xFFFF00 ¬ы не можете закинуть удочку так далеко." ); return false; }

	check_tiles( cr, fishingRod, hexX, hexY ); 
	
	return true;
}

void check_tiles( Critter& cr, Item& fishingRod, int hexX, int hexY ) 
{
	Map@ map = cr.GetMap();
	if( !valid( map ) ) { return; }
	
	uint8  water_flags = 0; 	

	water_flags = checkWater( map, H2T( hexX ), H2T( hexY ) );
	
	if( water_flags == 0 )
	{
		cr.Say( SAY_NETMSG, "|0xFFFF00 ¬ месте приземлени€ поплавка нет воды." );
		return;
	}
	
	Item@ floater = map.AddItem( hexX, hexY, PID_FLOATER, 1 );
	floater.HAS_BAIT = fishingRod.HAS_BAIT;
	floater.DEPTH = CheckDepth( map, floater );
	
	uint[] values = { floater.Id, cr.Id };
	floater.EVENT = CreateTimeEvent( AFTER( REAL_SECOND( 3 ) ), "e_floaterCheck", values, true );

	start_fishing( cr, floater, map );
}


bool ltp_inited = false;
void ltp_init()
{
    LTPREG( LTP_FISHING, process_fishing )
    ltp_inited = true;
}

bool start_fishing( Critter& cr, Item& floater, Map& map )
{
    if( !ltp_inited )
        ltp_init();

   	femote_Gender( cr,  "закинул удочку", "закинулa удочку");
	map.PlaySound( "rod_throw.ogg", cr.HexX, cr.HexY, 5 );
	StartProcess( cr, LTP_FISHING, 0, floater.Id, 0, 1000 );
	cr.SetAnims( COND_LIFE, 0, ANIM2_WINDUP_UNARMED );
	return true;
}

uint process_fishing( Critter@ cr, int& param0, int& param1, int& param2 )
{
    LTPROCESS( cr, param0, LTP_FISHING )
    
	Map@ map = cr.GetMap();
	if( !valid( map ) ) { return 0; }
	
	Item@ floater = GetItem( param1 );
	
	if( param0 == 0 ) {
		map.PlaySound( "fishing_reel1.ogg", cr.HexX, cr.HexY, 2 );
        
		if( floater.HAS_FISH <= 0 ) {
			if( Random( 1, 10 ) == 10 ) { //сюда наживка и рыба
				floaterBite( floater );
			}
			
		} else {
			if( Random( 1, 3 ) != 1 ) {
				floaterBite( floater );
			}
		}
		
		return Random( 1, 3 ) * 1000;
		
	} else {
		cr.SetAnims(COND_LIFE, 0, ANIM2_IDLE);
		DeleteItem( floater );
		return 0;
	}
}

uint e_floaterCheck( uint[]@ values )
{
	uint itemId = values[0];
	uint crtterId = values[1];
	Item@ floater = GetItem( itemId );
	Critter@ cr = GetCritter( crtterId );
	if( valid( floater ) )  
	{
		if( !valid( cr ) || cr.ParamBase[ ST_LTP_TIME ] == -1 ) {
			
			EraseTimeEvent( floater.EVENT );
			floater.EVENT = 0;
			DeleteItem( floater );
			cr.SetAnims(COND_LIFE, 0, ANIM2_IDLE);
			Map@ map = cr.GetMap();
			if( valid( map ) && valid( cr ) ) {
				map.PlaySound( "fishing_reel1.ogg", cr.HexX, cr.HexY, 2 );
				femote_Gender( cr,  "вытащил удочку", "вытащила удочку");
			}
			return 0;
		}
	}
	return REAL_SECOND( 1 );
}

void floaterBite( Item& floater )
{
	if( !FLAG( floater.Flags, ITEM_HIDDEN ) ) {	
		SETFLAG( floater.Flags, ITEM_HIDDEN );
		uint[] values = { floater.Id };
		if( floater.HAS_FISH == 0 && Random( 1, 3 ) == 3 ) { 
			floater.HAS_FISH = 1; 
		}
		CreateTimeEvent( AFTER( REAL_SECOND( 1 ) ), "e_floaterUp", values, true );
	} else {		
		UNSETFLAG( floater.Flags, ITEM_HIDDEN );
	}	
	floater.Update();
}

uint e_floaterUp( uint[]@ values)
{
	uint itemId = values[0];
	Item@ floater = GetItem( itemId );
	floaterBite( floater );
	
	return 0;
}

uint CheckDepth( Map& map, Item& floater ) 
{
	uint8 depth = 4;
	uint16 hexX = floater.HexX, hexY = floater.HexY;
	
	for( uint i = 0, len = 5; i < len; i++ ) {
		map.MoveHexByDir( hexX, hexY, i, 7 );
		if( checkWater( map, H2T( hexX ), H2T( hexY ) ) == 0 && ( checkCoast( map, H2T( hexX ), H2T( hexY ) ) != 0 || checkSand ( map, H2T( hexX ), H2T( hexY ) ) != 0 ) ) {
			depth--;
			//Log( "сонар нашел берег на 7, глубина: " + depth );
			//map.SetText( hexX, hexY, COLOR_LGRAY, ":отклик сонара 7:" );
			break;
		}
		hexX = floater.HexX;
		hexY = floater.HexY;
	}
	
	for( uint i = 0, len = 5; i < len; i++ ) {
		map.MoveHexByDir( hexX, hexY, i, 5 );
		if( checkWater( map, H2T( hexX ), H2T( hexY ) ) == 0 && ( checkCoast( map, H2T( hexX ), H2T( hexY ) ) != 0 || checkSand ( map, H2T( hexX ), H2T( hexY ) ) != 0 ) ) {
			depth--;
			//Log( "сонар нашел берег на 5, глубина: " + depth );
			//map.SetText( hexX, hexY, COLOR_LGRAY, ":отклик сонара 5:" );
			break;
		}
		hexX = floater.HexX;
		hexY = floater.HexY;
	}
	
	for( uint i = 0, len = 5; i < len; i++ ) {
		map.MoveHexByDir( hexX, hexY, i, 3 );
		if( checkWater( map, H2T( hexX ), H2T( hexY ) ) == 0 && ( checkCoast( map, H2T( hexX ), H2T( hexY ) ) != 0 || checkSand ( map, H2T( hexX ), H2T( hexY ) ) != 0 ) ) {
			depth--;
			//Log( "сонар нашел берег на 3, глубина: " + depth );
			//map.SetText( hexX, hexY, COLOR_LGRAY, ":отклик сонара 3:" );
			break;
		}
		hexX = floater.HexX;
		hexY = floater.HexY;
	}
	
	return depth;
}
//map.PlaySound( "catch_fish.ogg", cr.HexX, cr.HexY, 5 );