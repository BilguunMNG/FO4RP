#ifndef COOKING
#define COOKING

#include "_utils.fos"
#include "cooking_h.fos"
#include "_ltp.fos"
#include "firestarter_h.fos"
#include "critter_skills_h.fos"

bool recipes_inited=false;

bool ltp_cooking_inited=false;
void ltp_cooking_init()
{
	LTPREG( LTP_COOKING, process_cooking )
    ltp_cooking_inited = true;
}

void start_cooking( Critter& cr, Item& fire, uint index, bool standing )
{
	if( !ltp_cooking_inited )
	{
		ltp_cooking_init();
	}
	
	cr.ParamBase[ ST_LTP_SEQUENCE_WAIT ] = 10000;
   	cr.ParamBase[ ST_LTP_SEQUENCE ] = 0;

 	if( !standing )
 	{
 		cr.SetAnims( COND_LIFE, 0, ANIM2_CROUCH );
	}
 	else
 	{
 		cr.SetAnims( COND_LIFE, 0, ANIM2_LEANING1 );
	}
	
	uint16 pid = fryDataProtoIds[index][0];
	
	cr.DeleteItem( pid, 1 );
		
	cr.SayMsg( SAY_EMOTE, TEXTMSG_TEXT, STR_FRYING_BEGIN );
	
	Map@ map = cr.GetMap();
	if( valid( map ) )
	{
		PlayGenericSound( map, cr.HexX, cr.HexY, "frying.mp3", 10 );
	}
	
 	StartProcess( cr, LTP_COOKING, 0, fire.Id, index, cr.ParamBase[ ST_LTP_SEQUENCE_WAIT ] );
 }

uint process_cooking( Critter@ cr, int& param0, int& fireId, int& index )
{
	LTPROCESSD( LTP_COOKING )
	param0++;
    
	if( param0 > cr.Param[ ST_LTP_SEQUENCE ] )
	{
		Item@ result = cr.AddItem( fryDataProtoIds[index][1], fryDataProtoIds[index][2] );
		if( valid(result) )
		{
			cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_FRY_SUCCESS, "$name" + STR_INSERT_ITEM_LINE( result.GetProtoId() * 100 ) );
			if( Random( 1, 100 ) <= fryCookingSkillChanceUp )
			{
				raiseSkill( cr, SK_COOKING );
			}
		}
		
		Item@ item = _CritGetItemHand( cr );
		Item@ fire = GetItem( fireId );
		bool standing = true;
		if( valid( fire ) )
		{
			uint16 pid = fire.GetProtoId();
			if( pid == PID_FIREPLACE2 || pid == PID_CHOPPED_FIREWOOD )
			{
				standing = false;
			}
			
			if( valid( item ) )
			{
				AskCooking( cr, fire, standing );
			}
		}

		cr.SetAnims( COND_LIFE, 0, ANIM2_IDLE );
		return 0;
	}
    
	return cr.ParamBase[ ST_LTP_SEQUENCE_WAIT ];
}

void AskCooking( Critter& cr, Item& fire, bool standing )
{
    Map@ map = cr.GetMap();
    if( !valid( map ) )
	{
        return;
    }
	
	if( !valid( fire ) )
	{
		return;
	}

    iMenuHandler@ handler = CookingMenuMain( map, fire, standing );
    iDialogBox@ menu = OpenMenu( cr, "Cooking", handler );
}

bool GetCraftToken( Critter& cr, Item& fire )
{
	cr.SayMsg( SAY_EMOTE, TEXTMSG_TEXT, STR_EMOTE_WARM_HANDS );
	SayLog( cr, crInfo( cr ) + " used fire token." );
	
	Map@ map = cr.GetMap();
	if( !valid( map ) )
	{
		return false;
	}
	
	Item@ Workplace;
	@Workplace = map.GetItem( cr.HexX, cr.HexY, PID_GRAPPLE_HOOK );
	
	if( !valid( Workplace ) )
	{
		@Workplace = cr.GetMap().AddItem( cr.HexX, cr.HexY, PID_GRAPPLE_HOOK, 1 );
	}
	
	if( !valid( Workplace ) )
	{
		return false;
	}
	
	Workplace.SetScript( "item@_WorkplaceInit" );
	
	if( cr.CountItem( PID_FIREPLACE_TOKEN ) == 0 )
	{
		cr.AddItem( PID_FIREPLACE_TOKEN, 1 );
	}
	
	cr.RunClientScript( "client_screen_fixboy@ShowScreen", 0, 0, 0, null, null );
	return true;
}

void PrepareFrying( Critter& cr, Item& fire, bool standing )
{
    Item@ item = _CritGetItemHand( cr );
    if( !valid( item ) )
    {
        cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_HOLD_MEAT );
        return;
    }

    for( uint i = 0, len = fryDataProtoIds.length(); i < len; i++ )
    {
        if( item.GetProtoId() == fryDataProtoIds[i][0] )
        {			
			start_cooking( cr, fire, i, standing );
			return;
        }
    }

    cr.SayMsg(SAY_NETMSG, TEXTMSG_TEXT, STR_WRONG_ITEM_TO_FRY);
}

bool BurnMeal(int skill, int value)
{
    int delta = skill - value;
    return (delta < 50) && (Random(1, 50) > delta);
}

void StartCookingMenu( Critter& cr )
{
    Map@ map = cr.GetMap();
    if( !valid(map) )
	{
        return;
    }

    iMenuHandler@ handler = CookingMenu( map );
    iDialogBox@ menu = OpenMenu( cr, "Cooking Book", handler );
}

bool CheckIngredients(Critter& cr, Recipe& recipe)
{
    for (uint b = 0; b < recipe.ingredients.length(); b++)
    {
        if (cr.CountItem(recipe.ingredients[b]) == 0)
        {
            cr.SayMsg(SAY_NETMSG, TEXTMSG_TEXT, recipe.missingMessages[b]);
            return false;
        }
    }
    return true;
}

void ProcessRecipe(Critter& cr, Recipe& recipe, int skill)
{
    for (uint c = 0; c < recipe.ingredients.length(); c++)
    {
        cr.DeleteItem(recipe.ingredients[c], recipe.ingredientsAmount[c]);
    }
    
	for (uint d = 0; d < recipe.wasteItems.length(); d++)
	{
		cr.AddItem(recipe.wasteItems[d], recipe.wasteItemsAmount[d]);
	}
   
    bool isFailed = BurnMeal(skill, recipe.skillRequirement);

    if (isFailed)
    {
        cr.SayMsg(SAY_NETMSG, TEXTMSG_TEXT, recipe.failMessage);
    }
    else
    {
        cr.AddItem(recipe.resultFood, 1);
        cr.SayMsg(SAY_NETMSG, TEXTMSG_TEXT, recipe.successMessage);        
        int skillNum = SK_COOKING;
        raiseSkill(cr, skillNum);
    }
}

class CookingMenuMain: CenteredMenuHandler
{
    uint map_id;
	uint level;
	uint fire_id;
	bool stand;
	
    CookingMenuMain( Map& map, Item& fire, bool standing )
	{
        map_id = map.Id;
		level = 0;
		fire_id = fire.Id;
		stand = standing;
	}

	bool MenuUpdate( Critter& cr, iDialogBox& menu )
	{
        Map@ map = GetMap( map_id );
		Item@ fire = GetItem( fire_id );

		if( menu.ButtonMsg( STR_FURNITURE_MENU_CRAFT ) )
		{
			GetCraftToken( cr, fire );
			return false;
		}
		
		if( menu.ButtonMsg( STR_RECIPE_MENU ) )
		{
			CookingMenu@ menu_cooking = CookingMenu( map );
			menu_cooking.level = level + 1;
			return menu.OpenChild( "Level " + menu_cooking.level, menu_cooking );
		}
		
		if( menu.ButtonMsg( STR_FIRE_MENU_FRY ) )
		{
			PrepareFrying( cr, fire, stand );	
			return false;
		}

		return true;
	}
	
	int getDescriptionFile()
    {
    	return TEXTMSG_TEXT;
    }

	int getDescriptionLine()
	{
		return STR_COOKING_MENU;
	}

    string@ Description( Critter& cr )
	{
		return null;
    }	
}

class CookingMenu: CenteredMenuHandler
{
    uint map_id;
	uint level;
	bool isFailed = false;
	int skill;	
	
    CookingMenu( Map& map )
	{
        map_id = map.Id;
		level = 1;
		skill = 0;
	}

	bool MenuUpdate(Critter& cr, iDialogBox& menu)
	{
		Map@ map = GetMap(map_id);
		skill = cr.Skill[SK_COOKING];
		
		if (!recipes_inited)
		{
			InitializeRecipes();
			recipes_inited = true;
		}
		
		for (uint i = 0; i < recipes.length(); i++)
		{
			Recipe recipe = recipes[i];
			if (recipe.skillRequirement > skill)
			{
				continue;
			}
			
			if (menu.ButtonMsg(recipe.foodName))
			{
				if (CheckIngredients(cr, recipe))
				{
					ProcessRecipe(cr, recipe, skill);
				}
			}
		}
		
		return true;
	}
	
	int getDescriptionFile()
    {
    	return TEXTMSG_TEXT;
    }

	int getDescriptionLine()
	{
		return STR_SELECT_RECIPE;
	}

    string@ Description( Critter& cr )
	{
		return null;
    }	
}

#endif // COOKING