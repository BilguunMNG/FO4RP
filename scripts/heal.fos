#ifndef HEAL
#define HEAL

#include "_utils.fos"
#include "heal_h.fos"
#include "food_h.fos"
#include "waterworks_h.fos"
#include "combat_h.fos"
#include "drugs_h.fos"
#include "critter_status_h.fos"
#include "speed_h.fos"
#include "poison_h.fos"
#include "_ltp.fos"
#include "gathering_h.fos"

void StartMenuDOC( Critter& healer, Critter& target )
{
	OpenMenu( healer, "DOC", MenuDOC( target ) );
}	

enum MenuDOC_stage
{
	tool = 1,
	antiseptik = 2,
	anestetik = 3,
	processing = 4
};

enum MenuDOC_tool
{
	none = 0,
	blade = 1,  
	clips = 2,
	multitool = 3,
	needle = 4
};

enum MenuDOC_antiseptik
{
	none = 0,
	booze = 1,
	spirit = 2,
	antiseptik = 3
};

enum MenuDOC_anestetik
{
	none = 0,
	booze = 1,
	spirit = 2,
	anestetik = 3
};

enum MenuCripple_stage
{
	main = 0,
	tool = 1
};

enum MenuCripple_tools
{
	none = 0,
	splint = 1,
	handmade = 2
};

class MenuDOC: CenteredMenuHandler 
{	
	Critter@ cr;
	Critter@ target;
	iDialogBox@ menu;
	
	string state;
	
	MenuDOC( Critter& target )
	{
		@this.target = @target;
	}

	bool check( uint pid, string success, string failed )
	{
		if( hasItem( cr, pid ) )
		{
			if( menu.Button( success ) )
			{
				return true;
			}
		}
		else
		{ 
			menu.Button( failed );
		}
		return false;
	}
	
	bool MenuUpdate( Critter& cr, iDialogBox& menu )
	{
		@this.cr = @cr;
		@this.menu = @menu;
	
		state = target.Stat[ ST_CURRENT_HP ] > 0 ? "Pulse normal" : "Weak pulse";

		if( damages.length() != damage_states.length() )
		{
			testInfo( cr, "damages.length("+damages.length()+") != damage_states.length("+damage_states.length()+")" );
			return false;
		}
		
		bool hasDamages = false;
		for( uint i = 0, l = damages.length(); i < l; i++ )
		{
			if( target.DamageBase[damages[i]] != 0 )
			{
				state += ", " + damage_states[i]; 
				hasDamages = true;
			}
		}
		
		if( cr.Stat[ST_POISONING_LEVEL] > 0 )
		{
			state += ", signs of poisoning";
			hasDamages = true;
		}
		
		if( cr.Stat[ST_RADIATION_LEVEL] > 0 )
		{
			state += ", signs of radiation sickness";
			hasDamages = true;
		}
		
		if( cr.Stat[ST_BLEED] > 0 )
		{
			state += ", bleeding";
			hasDamages = true;
		}
		
		state += ".";
		
		bool knife = ( _CritCountItem( cr, PID_KNIFE ) > 0 || _CritCountItem( cr, PID_COMBAT_KNIFE ) > 0 );

		if( FLAG( target.StatBase[ ST_CRSTATUS ], CR_STATUS_BULLET_OVER ) )
		{
			state += "\n" + "there is a bullet or a shard is in the wound, that requires to be removed before anything else is done.";
			if ( menu.Button( "Extraction" ) )
			{
				OpenMenu( cr, "BulletOver", MenuDOC_Bullet( target ) );
				return false;
			}
			return true;
		}

		if( FLAG( target.StatBase[ ST_CRSTATUS ], CR_STATUS_HEAVY_DMG ) )
		{
			state += "\n" + "Heavy wound that requires to be closed.";
			if ( menu.Button( "Surgery" ) )
			{
				OpenMenu( cr, "HeavyDamage", MenuDOC_Heavy( target ) );
				return false;
			}
			return true;
		}
			
		if( hasDamages && menu.Button( "Traumas" ) )
		{
			OpenMenu( cr, "Cripple", MenuDOC_Cripple( target ) );
			return false;
		}

		state += "\n" + "There is nothing requiring a doctor.";
		return true;
	}

	string@ Description( Critter& cr ) 
	{
		return state;
	}
}

class MenuDOC_Bullet: CenteredMenuHandler 
{	
	int stage;
	
	int tool;
	int antiseptik;
	int anestetik;
	
	Critter@ cr;
	Critter@ target;
	iDialogBox@ menu;
	
	MenuDOC_Bullet( Critter& target )
	{
		@this.target = @target;
		
		this.stage = MenuDOC_stage::tool;
		
		this.tool = MenuDOC_tool::none;
		this.antiseptik = MenuDOC_antiseptik::none;
		this.anestetik 	= MenuDOC_anestetik::none;
	}

	bool check( uint pid, string success, string failed )
	{
		if( hasItem( cr, pid ) ) {
			if( menu.Button( success ) ) {
				return true;
			}
		} else { menu.Button( failed );
		}
		
		return false;
	}
	
	bool MenuUpdate( Critter& cr, iDialogBox& menu )
	{
		@this.cr = @cr;
		@this.menu = @menu;
		
		string info = "Test info:\n"
					+ "Doctor #" + cr.Id 			+ "\n"
					+ "Patient #" + target.Id		+ "\n"
					+ "Stage #" + stage				+ "\n"
					+ "Antiseptik #" + antiseptik	+ "\n"
					+ "Anestetik #" + anestetik		+ "\n"

				;

		testInfo( cr, info );
		
		switch( stage )
		{
			case(MenuDOC_stage::tool):
			{
				if( check( PID_MEDCLIP, "tongs", "no tongs" ) )
				{
					tool  = MenuDOC_tool::clips;
					stage = MenuDOC_stage::antiseptik;	
				}
				
				if( check( PID_MULTI_TOOL, "multitool", "no multitool" ) )
				{
					tool  = MenuDOC_tool::multitool;
					stage = MenuDOC_stage::antiseptik;	
				}

				if( HasBlade( cr ) )
				{
					if( menu.Button( "pluck out" ) )
					{
						tool  = MenuDOC_tool::blade;
						stage = MenuDOC_stage::antiseptik;	
					}
				}
				else
				{
					menu.Button( "no blade" );
				}
				
				if( menu.Button( "Medical check" ) )
				{
					OpenMenu( cr, "DOC", MenuDOC( target ) );
					return false;
				}
			}
			return true;
			
			case(MenuDOC_stage::antiseptik):
			{
				
				if( check( PID_ROT_GUT_PRT, "use rot gut", "no rot gut" ) )
				{
					antiseptik  = MenuDOC_antiseptik::booze;
					stage 		= MenuDOC_stage::anestetik;	
				}
				
				if( check( PID_SPIRIT_PRT, "use spirit", "no spirit" ) )
				{
					antiseptik  = MenuDOC_antiseptik::spirit;
					stage 		= MenuDOC_stage::anestetik;	
				}
				
				if( check( PID_ANTISEPTIC, "use antiseptik", "no antiseptik" ) )
				{
					antiseptik  = MenuDOC_antiseptik::antiseptik;
					stage 		= MenuDOC_stage::anestetik;	
				}

				if( menu.Button( "without disinfecting" ) )
				{
					antiseptik  = MenuDOC_antiseptik::none;
					stage 		= MenuDOC_stage::anestetik;	
				}
				
				if( menu.Button( "Return" ) )
				{
					stage 		= MenuDOC_stage::tool;	
				}
			}
			return true;
			
			case(MenuDOC_stage::anestetik):
			{
				if( check( PID_ROT_GUT_PRT, "use rot gut", "no rot gut" ) )
				{
					anestetik   = MenuDOC_anestetik::booze;
					stage 	    = MenuDOC_stage::processing;	
				}
				
				if( check( PID_SPIRIT_PRT, "use spirit", "no spirit" ) )
				{
					anestetik   = MenuDOC_anestetik::spirit;
					stage 	    = MenuDOC_stage::processing;	
				}
				
				if( check( PID_ANESTETIC, "use anastetic", "no anastetic" ) )
				{
					anestetik   = MenuDOC_anestetik::anestetik;
					stage 		= MenuDOC_stage::processing;	
				}

				if( menu.Button( "no painkillers" ) )
				{
					anestetik   = MenuDOC_anestetik::none;
					stage 		= MenuDOC_stage::processing;	
				}
				
				if( menu.Button( "Return" ) )
				{
					stage 		= MenuDOC_stage::antiseptik;	
				}
			}
			return true;
			
			case(MenuDOC_stage::processing):
			{
				if( menu.Button( "Begin" ) )
				{
					if( cr.Timeout[ TO_SK_DOCTOR ] > 0 )
					{
						stage 		= MenuDOC_stage::tool;
						cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_TOO_TIRED );
						return true;
					}
					
					int chances = calculate_chances( true );
					int difficuty = Random( 0, 100 * HEALING_DIFFICULTY );
					testInfo( cr, "Actual roll was " + chances + " against " + difficuty + "%." );
			
					if( chances >= difficuty )
					{
						ChangeStatus( target, CR_STATUS_BULLET_OVER, 0, false );
						cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_DOCTOR_BULLET_SUCCESS );
					}
					else
					{
						cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_DOCTOR_BULLET_FAILED );
					}
					cr.TimeoutBase[ TO_SK_DOCTOR ] = DOCTOR_TIMEOUT( player );
					
					OpenMenu( cr, "DOC", MenuDOC( target ) );
					return false;
				}

				if( menu.Button( "Return" ) )
				{
					stage 		= MenuDOC_stage::anestetik;	
				}
			}
			return true;
		}
		
		return true;
	}

	int calculate_chances( bool actual_use )
	{
		int skill = cr.Skill[ SK_DOCTOR ];
		string skill_info = "DOC base [" + skill + "] ";
		
		int damage = 0;
		string damage_info = "Taken damage: ";
		
		switch( tool )
		{
			case(MenuDOC_tool::clips):
			{
				Item@ item_tool = getItem( cr, PID_MEDCLIP );
				if( !valid( item_tool ) )
				{
					tool = MenuDOC_tool::none;
				}
				else
				{
					skill += 100;
					skill_info += " + clips [100]";
				}						
			}
			break;

			case(MenuDOC_tool::multitool):
			{
				Item@ item_tool = getItem( cr, PID_MULTI_TOOL );
				if( !valid( item_tool ) )
				{
					tool = MenuDOC_tool::none;
				}
				else
				{
					skill += 0;
					skill_info += " + multitool [0]";

					int rng = Random( 10, 20 );
					damage += rng;
					damage_info += " + multitool [" + rng + "]";
				}						
			}
			break;

			case(MenuDOC_tool::blade):
			{
				if(  HasBlade( cr ) )
				{
					skill -= 100;
					skill_info += " - blades [100]";
					
					int rng = Random( 20, 40 );
					damage += rng;
					damage_info += " + blades [" + rng + "]";
				}						
			}
			break;
		}
		
		switch( antiseptik )
		{
			case(MenuDOC_antiseptik::booze):
			{
				Item@ item_antiseptik = getItem( cr, PID_ROT_GUT_PRT );
				if( !valid( item_antiseptik ) )
				{
					antiseptik = MenuDOC_antiseptik::none;
				}
				else
				{
					if( actual_use ) SpillOut( item_antiseptik );
					
					skill += 0;
					skill_info += " + booze [0]";
					
					damage += 0;
				}
			}
			break;
			
			case(MenuDOC_antiseptik::spirit):
			{
				Item@ item_antiseptik = getItem( cr, PID_SPIRIT_PRT );
				if( !valid( item_antiseptik ) )
				{
					antiseptik = MenuDOC_antiseptik::none;
				}
				else
				{
					if( actual_use ) SpillOut( item_antiseptik );
					
					skill += 50;
					skill_info += " + spirit [50]";
					
					damage += 0;
				}
			}
			break;
			
			case(MenuDOC_antiseptik::antiseptik):
			{
				Item@ item_antiseptik = getItem( cr, PID_ANTISEPTIC );
				if( !valid( item_antiseptik ) )
				{
					antiseptik = MenuDOC_antiseptik::none;
				}
				else
				{
					skill += 100;
					skill_info += " + antiseptik [100]";
					
					int rng = Random( 5, 10 );
					damage -= rng;
					damage_info += " - antiseptik [" + rng + "]";

					if( actual_use ) 
					{
						_SubItem( item_antiseptik, 1 );
						cr.AddItem( PID_PHIAL, 1 );
					}
				}
			}
			break;
			
			case(MenuDOC_antiseptik::none):
			{
				skill -= 100;
				skill_info += " - no antiseptik [100]";
					
				int rng = Random( 5, 10 );
				damage += rng;
				damage_info += " + no antiseptik [" + rng + "]";

				if( actual_use ) 
					cr.ParamBase[ CR_DIRTINESS ] += Random( 5, 10 );
			}
			break;
			
		}
		
		switch( anestetik )
		{
			case(MenuDOC_anestetik::booze):
			{
				Item@ item_anestetik = getItem( cr, PID_ROT_GUT_PRT );
				if( !valid( item_anestetik ) )
				{
					anestetik = MenuDOC_anestetik::none;
				}
				else
				{
					if( actual_use ) SpillOut( item_anestetik );
					
					skill += 25;
					skill_info += " + booze [25]";
					
					damage += 0;
				}
			}
			break;
			
			case(MenuDOC_anestetik::spirit):
			{
				Item@ item_anestetik = getItem( cr, PID_SPIRIT_PRT );
				if( !valid( item_anestetik ) )
				{
					anestetik = MenuDOC_anestetik::none;
				}
				else
				{
					if( actual_use ) SpillOut( item_anestetik );
					
					skill += 50;
					skill_info += " + spirit [50]";
					
					int rng = Random( 5, 20 );
					damage -= rng;
					damage_info += " - spirit [" + rng + "]";
				}
			}
			break;
			
			case(MenuDOC_anestetik::anestetik):
			{
				Item@ item_anestetik = getItem( cr, PID_ANESTETIC );
				if( !valid( item_anestetik ) )
				{
					anestetik = MenuDOC_anestetik::none;
				}
				else 
				{
					skill += 100;
					skill_info += " + anestetik [100]";
					
					int rng = Random( 15, 30 );
					damage -= rng;
					damage_info += " - anestetik [" + rng + "]";

					if( actual_use ) 
					{
						_SubItem( item_anestetik, 1 );
						cr.AddItem( PID_PHIAL, 1 );
					}
				}
			}
			break;
			
			case(MenuDOC_anestetik::none):
			{
				skill += 0;
				skill_info += " + no anestetik [0]";
					
				damage += 0;
			}
			break;
			
		}

		if( actual_use ) target.StatBase[ ST_CURRENT_HP ] -= damage;
		
		testInfo( cr, skill_info + " = " + skill + "." );
		testInfo( cr, damage_info + " = " + damage + "." );

		int luck = cr.Stat[ST_LUCK];
		int chances = ( skill + rollLuck( luck ) * HEALING_LUCK_DEPENDENCY );

		testInfo( cr,
			"skill [" + skill + "]" +
			" + rollLuck( luck[" + luck + "] )[" + rollLuck( luck ) + "]" + 
			" * HEALING_LUCK_DEPENDENCY [" + HEALING_LUCK_DEPENDENCY + "] " +
			"{" + chances + "}" +
				" > " +
			"Random( 0, 100 * HEALING_DIFFICULTY[" + HEALING_DIFFICULTY + "] )" +
			"\n\nChances are: " + float( chances / HEALING_DIFFICULTY ) + "%." +
			""
		);
		
		return chances;
	}

	string@ Description( Critter& cr ) 
	{
		switch( stage )
		{
			case(MenuDOC_stage::tool):
				return "Choosen tool:";
				
			case(MenuDOC_stage::antiseptik):
				return "Applied disenfection:"; 
			
			case(MenuDOC_stage::anestetik):
				return "Applied anastetic:"; 
			
			case(MenuDOC_stage::processing):
				return "You are ready to perform extraction of an alien object from the patient.\n\nExpected success rate is: |0xFFFFFF " + ( calculate_chances( false ) / HEALING_DIFFICULTY ) + "%|0x00FF00 "; 
		}
		
		return "[UNKNOWN STATE #" + stage + "]";
	}
}

class MenuDOC_Heavy: CenteredMenuHandler 
{	
	int stage;
	
	int tool;
	int antiseptik;
	int anestetik;
	
	Critter@ cr;
	Critter@ target;
	iDialogBox@ menu;
	
	MenuDOC_Heavy( Critter& target )
	{
		@this.target = @target;
		
		this.stage 		= MenuDOC_stage::tool;
		
		this.tool 		= MenuDOC_tool::none;
		this.antiseptik = MenuDOC_antiseptik::none;
		this.anestetik 	= MenuDOC_anestetik::none;
	}

	bool check( uint pid, string success, string failed )
	{
		if( hasItem( cr, pid ) )
		{
			if( menu.Button( success ) )
			{
				return true;
			}
		}
		else
		{
			menu.Button( failed );
		}
		return false;
	}
	
	bool MenuUpdate( Critter& cr, iDialogBox& menu )
	{
		@this.cr = @cr;
		@this.menu = @menu;
		
		string info = "Test info:\n"
					+ "Doctor #" + cr.Id 			+ "\n"
					+ "Patient #" + target.Id		+ "\n"
					+ "stage #" + stage				+ "\n"
					+ "antiseptik #" + antiseptik	+ "\n"
					+ "anestetik #" + anestetik		+ "\n"

				;
					
		testInfo( cr, info );
		
		switch( stage )
		{
			case(MenuDOC_stage::tool):
			{
				if( check( PID_MEDNEEDLE, "stich", "nothing to stich with" ) )
				{
					tool  = MenuDOC_tool::needle;
					stage = MenuDOC_stage::antiseptik;	
				}		

				if( HasBlade( cr ) )
				{
					if( menu.Button( "burn" ) )
					{
						tool  = MenuDOC_tool::blade;
						stage = MenuDOC_stage::antiseptik;	
					}
				}
				else menu.Button( "nothing to burn with" );
				
				if( menu.Button( "Medical check" ) )
				{
					OpenMenu( cr, "DOC", MenuDOC( target ) );
					return false;
				}
			}
			return true;
			
			case(MenuDOC_stage::antiseptik):
			{
				if( check( PID_ROT_GUT_PRT, "use rot gut", "no rot gut" ) )
				{
					antiseptik  = MenuDOC_antiseptik::booze;
					stage 		= MenuDOC_stage::anestetik;	
				}
				
				if( check( PID_SPIRIT_PRT, "use spirit", "no spirit" ) )
				{
					antiseptik  = MenuDOC_antiseptik::spirit;
					stage 		= MenuDOC_stage::anestetik;	
				}
				
				if( check( PID_ANTISEPTIC, "use antiseptik", "no antiseptik" ) )
				{
					antiseptik  = MenuDOC_antiseptik::antiseptik;
					stage 		= MenuDOC_stage::anestetik;	
				}

				if( menu.Button( "no disinfecting" ) ) 
				{
					antiseptik  = MenuDOC_antiseptik::none;
					stage 		= MenuDOC_stage::anestetik;	
				}
				
				if( menu.Button( "Return" ) )
					stage 		= MenuDOC_stage::tool;	
				
			}
			return true;
			
			case(MenuDOC_stage::anestetik):
			{
				if( check( PID_ROT_GUT_PRT, "use rot gut", "no rot gut" ) )
				{
					anestetik   = MenuDOC_anestetik::booze;
					stage 	    = MenuDOC_stage::processing;	
				}
				
				if( check( PID_SPIRIT_PRT, "use spirit", "no spirit" ) )
				{
					anestetik   = MenuDOC_anestetik::spirit;
					stage 	    = MenuDOC_stage::processing;	
				}
				
				if( check( PID_ANESTETIC, "use antiseptik", "no antiseptik" ) )
				{
					anestetik   = MenuDOC_anestetik::anestetik;
					stage 		= MenuDOC_stage::processing;	
				}

				if( menu.Button( "no painkillers" ) ) 
				{
					anestetik   = MenuDOC_anestetik::none;
					stage 		= MenuDOC_stage::processing;	
				}
				
				if( menu.Button( "Return" ) )
				{
					stage 		= MenuDOC_stage::antiseptik;	
				}
			}
			return true;
			
			case(MenuDOC_stage::processing):
			{
				if( menu.Button( "Begin" ) )
				{
					if( cr.Timeout[ TO_SK_DOCTOR ] > 0 )
					{
						stage 		= MenuDOC_stage::tool;
						
						cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_TOO_TIRED );
						return true;
					}
					
					int chances = calculate_chances( true );
					int difficuty = Random( 0, 100 * HEALING_DIFFICULTY );

					testInfo( cr, "Actual roll was " + chances + " against " + difficuty + "%." );
					
					if( chances >= difficuty )
					{
						ChangeStatus( target, CR_STATUS_HEAVY_DMG, 0, false );
						cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_DOCTOR_STICHED_WOUND );
					}
					else 
					{
						cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_DOCTOR_SURGERY_FAILED );
					}
					
					cr.TimeoutBase[ TO_SK_DOCTOR ] = DOCTOR_TIMEOUT( player );
					
					OpenMenu( cr, "DOC", MenuDOC( target ) );
					return false;
				}
				
				if( menu.Button( "Return" ) )
					stage 		= MenuDOC_stage::anestetik;	
			}
			return true;
		}
		
		return true;
	}
	
	int calculate_chances( bool actual_use )
	{
		int skill = cr.Skill[ SK_DOCTOR ];
		string skill_info = "DOC base [" + skill + "] ";
		
		int damage = 0;
		string damage_info = "Taken damage: ";
		uint action_info;
		
		switch( tool )
		{
			case(MenuDOC_tool::needle):
			{
				Item@ needle = getItem( cr, PID_MEDNEEDLE );
				Item@ thread = getItem( cr, PID_MEDTHREAD );
				if( !valid( needle ) || !valid( thread ) )
				{
					tool = MenuDOC_tool::none;
					stage 		= MenuDOC_stage::tool;
					
					cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_DOCTOR_NEED_NEEDLE );
					return 0;
				}
				else
				{
					skill += 100;
					skill_info += " + needle [100]";
					
					int rng = Random( 5, 10 );
					damage += rng;
					damage_info += " + needle [" + rng + "]";
					
					action_info = STR_DOCTOR_STICHED_WOUND;

					if( actual_use )
						_SubItem( thread, 1 );
				}						
			}
			break;

			case(MenuDOC_tool::blade):
			{
				if( HasBlade( cr ) && hasItems( cr, heatSources ) )
				{
					skill -= 100;
					skill_info += " - blades [100]";
					
					int rng = Random( 20, 40 );
					damage += rng;
					damage_info += " + blades [" + rng + "]";

					action_info = STR_DOCTOR_BURNED_WOUND;
				}
				else
				{
					tool = MenuDOC_tool::none;
					stage 		= MenuDOC_stage::tool;
					
					cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_DOCTOR_NEED_FIRE );
					return 0;
				}
			}
			break;
		}
		
		switch( antiseptik )
		{
			case(MenuDOC_antiseptik::booze):
			{
				Item@ item_antiseptik = getItem( cr, PID_ROT_GUT_PRT );
				if( !valid( item_antiseptik ) )
					antiseptik = MenuDOC_antiseptik::none;
				else
				{
					if( actual_use )
						SpillOut( item_antiseptik );
					
					skill += 25;
					skill_info += " + booze [25]";
					
					damage += 0;
				}
			}
			break;
			
			case(MenuDOC_antiseptik::spirit):
			{
				Item@ item_antiseptik = getItem( cr, PID_SPIRIT_PRT );
				if( !valid( item_antiseptik ) )
					antiseptik = MenuDOC_antiseptik::none;
				else
				{
					if( actual_use ) SpillOut( item_antiseptik );
					
					skill += 50;
					skill_info += " + spirit [50]";
					
					damage += 0;
				}
			}
			break;
			
			case(MenuDOC_antiseptik::antiseptik):
			{
				Item@ item_antiseptik = getItem( cr, PID_ANTISEPTIC );
				if( !valid( item_antiseptik ) )
					antiseptik = MenuDOC_antiseptik::none;
				else
				{
					skill += 100;
					skill_info += " + antiseptik [100]";
					
					int rng = Random( 5, 10 );
					damage -= rng;
					damage_info += " - antiseptik [" + rng + "]";

					if( actual_use ) 
					{
						_SubItem( item_antiseptik, 1 );
						cr.AddItem( PID_PHIAL, 1 );
					}
				}
			}
			break;
			
			case(MenuDOC_antiseptik::none):
			{
				skill -= 100;
				skill_info += " - no antiseptik [100]";
					
				int rng = Random( 5, 10 );
				damage += rng;
				damage_info += " + no antiseptik [" + rng + "]";

				if( actual_use ) cr.ParamBase[ CR_DIRTINESS ] += Random( 5, 10 );
			}
			break;
			
		}
		
		switch( anestetik )
		{
			case(MenuDOC_anestetik::booze):
			{
				Item@ item_anestetik = getItem( cr, PID_ROT_GUT_PRT );
				if( !valid( item_anestetik ) )
					anestetik = MenuDOC_anestetik::none;
				else
				{
					if( actual_use ) 
					{
						ApplyFoodEffects( target, item_anestetik );
						SpillOut( item_anestetik );
					}
					
					skill += 25;
					skill_info += " + booze [25]";
					
					damage += 0;
				}
			}
			break;
			
			case(MenuDOC_anestetik::spirit):
			{
				Item@ item_anestetik = getItem( cr, PID_SPIRIT_PRT );
				if( !valid( item_anestetik ) )
					anestetik = MenuDOC_anestetik::none;
				else
				{
					if( actual_use ) 
					{
						ApplyFoodEffects( target, item_anestetik );
						SpillOut( item_anestetik );
					}
					
					skill += 50;
					skill_info += " + spirit [50]";
					
					int rng = Random( 5, 20 );
					damage -= rng;
					damage_info += " - spirit [" + rng + "]";
				}
			}
			break;
			
			case(MenuDOC_anestetik::anestetik):
			{
				Item@ item_anestetik = getItem( cr, PID_ANESTETIC );
				if( !valid( item_anestetik ) )
					anestetik = MenuDOC_anestetik::none;
				else
				{
					skill += 100;
					skill_info += " + anestetik [100]";
					
					int rng = Random( 15, 30 );
					damage -= rng;
					damage_info += " - anestetik [" + rng + "]";

					if( actual_use ) 
					{
						_SubItem( item_anestetik, 1 );
						cr.AddItem( PID_PHIAL, 1 );
					}
				}
			}
			break;
			
			case(MenuDOC_anestetik::none):
			{
				skill += 0;
				skill_info += " + no anestetik [0]";
					
				damage += 0;
			}
			break;
			
		}

		if( actual_use ) 
			target.StatBase[ ST_CURRENT_HP ] -= damage;
		
		testInfo( cr, skill_info + " = " + skill + "." );
		testInfo( cr, damage_info + " = " + damage + "." );

		int luck = cr.Stat[ST_LUCK];
		int chances = ( skill + rollLuck( luck ) * HEALING_LUCK_DEPENDENCY );
		
		testInfo( cr,
			"skill [" + skill + "]" +
			" + rollLuck( luck[" + luck + "] )[" + rollLuck( luck ) + "]" + 
			" * HEALING_LUCK_DEPENDENCY [" + HEALING_LUCK_DEPENDENCY + "]" +
			"{" + chances + "}" +
				" > " +
			"Random( 0, 100 * HEALING_DIFFICULTY[" + HEALING_DIFFICULTY + "] )" +
			"\n\nChances are: " + float( chances / HEALING_DIFFICULTY ) + "%." +
			""
		);
		
		return chances;
	}

	string@ Description( Critter& cr ) 
	{
		switch( stage )
		{
			case(MenuDOC_stage::tool):
				return "Choosen tool:";
				
			case(MenuDOC_stage::antiseptik):
				return "Applied disenfection:"; 
			
			case(MenuDOC_stage::anestetik):
				return "Applied anastetic:"; 
			
			case(MenuDOC_stage::processing):
				return "You are ready to perform surgery on an open wound.\n\nExpected success rate is: |0xFFFFFF " + ( calculate_chances( false ) / HEALING_DIFFICULTY ) + "%|0x00FF00 "; 
		}
		
		return "[UNKNOWN STATE #" + stage + "]";
	}
}

class MenuDOC_Cripple: CenteredMenuHandler 
{	
	Critter@ cr;
	Critter@ target;
	iDialogBox@ menu;
	
	int stage;
	uint limb;
	string description;
	
	MenuDOC_Cripple( Critter& target )
	{
		this.stage = MenuCripple_stage::main;
		@this.target = @target;
	}

	bool check( uint pid, string success, string failed )
	{
		if( hasItem( cr, pid ) )
		{
			if( menu.Button( success ) )
			{
				return true;
			}
		}
		else
		{
			menu.Button( failed );
		}
		return false;
	}
	
	bool MenuUpdate( Critter& cr, iDialogBox& menu )
	{
		@this.cr = @cr;
		@this.menu = @menu;
		description = "";
		
		string info = "Test info:\n"
					+ "Doctor #" + cr.Id 			+ "\n"
					+ "Patient #" + target.Id		+ "\n"
				;
					
		testInfo( cr, info );
		
		switch( stage )
		{
			case( MenuCripple_stage::main ):
			{
				for( uint i = 0, l = damages.length(); i < l; i++ )
				{
					if( target.DamageBase[damages[i]] != 0 && menu.Button(damage_states[i]) )
					{
						stage = MenuCripple_stage::tool;
						limb = damages[i];
						return true;
					}
				}

				if( menu.Button("Return") )
				{
					OpenMenu( cr, "DOC", MenuDOC( target ) );
					return false;
				}
			}
			return true;
			
			case(MenuCripple_stage::tool):
			{
				uint[] rates;
				uint[] ids;
				uint8 countTimes = target.GetTimeEvents( CTE_DOC, ids, null, rates );
				for( uint8 i = 0; i < countTimes; i++ )
				{
					if( rates[i] == limb )
					{
						description += "This part is already being healed.\n";
						
						if( menu.Button( "Remove " + ( limb == DAMAGE_EYE ? "bandage" : "brace" ) ) )
						{
							target.EraseTimeEvent( ids[i] );
							stage = MenuCripple_stage::main;
							limb = 0;
						}

						if( menu.Button( "Return" ) )
						{
							stage = MenuCripple_stage::main;
							limb = 0;
						}

						return true;
					}
				}
				
				if( target.DamageBase[ limb ] == 0 )
				{
					description += "This part does not require healing.\n";
					
					if( menu.Button("Return") )
					{
						stage = MenuCripple_stage::main;
						limb = 0;
					}
					
					return true;
				}
				
				switch( limb )
				{
					case(DAMAGE_EYE):
					{
						if( check( PID_CRAFT_L_RAGS, "Use a patch", "No patch" ) )
						{
							Item@ bandage = getItem( cr, PID_CRAFT_L_RAGS );
							if( !valid( bandage ) ) return true;
							
							_SubItem( bandage, 1 );

							int docTime = MAX_LIMB_HEALING_TIME - cr.Skill[ SK_DOCTOR ] - target.Stat[ ST_ENDURANCE ] * HEALING_ENDURANCE_DEPENDENCY;
							docTime = CLAMP( docTime, 5, MAX_LIMB_HEALING_TIME );
							target.AddTimeEvent( "cte_Doc", REAL_MINUTE( docTime ), CTE_DOC, limb );
							cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_DOCTOR_EYE_PATCHED );
							
							testInfo( cr, "Time: " + MAX_LIMB_HEALING_TIME + " - " + ( cr.Skill[ SK_DOCTOR ] ) + " - " + ( target.Stat[ ST_ENDURANCE ] * HEALING_ENDURANCE_DEPENDENCY ) + " = " + docTime	);
							
							stage = MenuCripple_stage::main;
							limb = 0;
							
							return true;
						}

						if( check( PID_BANDAGE, "Use bandage", "No bandage" ) )
						{
							Item@ bandage = getItem( cr, PID_BANDAGE );
							if( !valid( bandage ) ) return true;
							
							_SubItem( bandage, 1 );

							int docTime = MAX_LIMB_HEALING_TIME - cr.Skill[ SK_DOCTOR ] * 2 - target.Stat[ ST_ENDURANCE ] * HEALING_ENDURANCE_DEPENDENCY;
							target.AddTimeEvent( "cte_Doc", REAL_MINUTE( CLAMP( docTime, 5, MAX_LIMB_HEALING_TIME ) ), CTE_DOC, limb );
							cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_DOCTOR_EYE_BANDAGED);

							testInfo( cr, "Time: " + MAX_LIMB_HEALING_TIME + " - " + ( cr.Skill[ SK_DOCTOR ] * 2 ) + " - " + ( target.Stat[ ST_ENDURANCE ] * HEALING_ENDURANCE_DEPENDENCY ) + " = " + docTime	);
							
							stage = MenuCripple_stage::main;
							limb = 0;

							return true;
						}
						
					}						
					return true;
					
					case( DAMAGE_RIGHT_ARM ):
					case( DAMAGE_LEFT_ARM ):
					case( DAMAGE_RIGHT_LEG ):
					case( DAMAGE_LEFT_LEG ):
					{
						if( hasItem( cr, PID_ROPE ) && hasItems( cr, makeshift_splints ) )
						{
							if( menu.Button( "Improvised brace" ) )
							{
								Item@ rope = getItem( cr, PID_ROPE );
								if( !valid( rope ) )
								{
									return true;
								}
								
								Item@[] splints = getItems( cr, makeshift_splints );
								if( splints.length() == 0 )
								{
									return true;
								}
								
								Item@ splint = splints[ Random( 0, splints.length() - 1 ) ];
								if( !valid( splint ) )
								{
									return true;
								}

								_SubItem( splint, 1 );
								_SubItem( rope, 1 );								

								int docTime = MAX_LIMB_HEALING_TIME - cr.Skill[ SK_DOCTOR ] - target.Stat[ ST_ENDURANCE ] * HEALING_ENDURANCE_DEPENDENCY;
								target.AddTimeEvent( "cte_Doc", REAL_MINUTE( CLAMP( docTime, 5, MAX_LIMB_HEALING_TIME ) ), CTE_DOC, limb );
								cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_DOCTOR_IMPROVISED_BRACE );
								
								testInfo( cr, "Time: " + MAX_LIMB_HEALING_TIME + " - " + ( cr.Skill[ SK_DOCTOR ] ) + " - " + ( target.Stat[ ST_ENDURANCE ] * HEALING_ENDURANCE_DEPENDENCY ) + " = " + docTime	);

								stage = MenuCripple_stage::main;
								limb = 0;
								
								return true;
							}
						}
						else
						{
							if( menu.Button( "Nothing to brace with" ) )
							{
								cr.SayMsg( SAY_NETMSG,  TEXTMSG_TEXT, STR_DOCTOR_NO_BRACE );
								return true;
							}
						}

						if( check( PID_MEDSPLINT, "Apply brace", "No brace" ) )
						{
							Item@ splint = getItem( cr, PID_MEDSPLINT );
							if( !valid( splint ) ) return true;
							
							_SubItem( splint, 1 );

							int docTime = MAX_LIMB_HEALING_TIME - cr.Skill[ SK_DOCTOR ] * 2 - target.Stat[ ST_ENDURANCE ] * HEALING_ENDURANCE_DEPENDENCY;
							target.AddTimeEvent( "cte_Doc", REAL_MINUTE( CLAMP( docTime, 5, MAX_LIMB_HEALING_TIME ) ), CTE_DOC, limb );
							cr.SayMsg( SAY_NETMSG,  TEXTMSG_TEXT, STR_DOCTOR_MEDICAL_BRACE );

							testInfo( cr, "Time: " + MAX_LIMB_HEALING_TIME + " - " + ( cr.Skill[ SK_DOCTOR ] * 2 ) + " - " + ( target.Stat[ ST_ENDURANCE ] * HEALING_ENDURANCE_DEPENDENCY ) + " = " + docTime	);
							
							stage = MenuCripple_stage::main;
							limb = 0;

							return true;
						}
						
						if( menu.Button( "Return" ) )
						{
							stage = MenuCripple_stage::main;
							limb = 0;

							return true;
						}
					}				
					return true;
				}
			}
			return true;
		}
		return true;
	}

	string@ Description( Critter& cr ) 
	{
		switch( stage )
		{
			case(MenuCripple_stage::main):
				return description + "Chose your action:";
				
			case(MenuCripple_stage::tool):
			{
				int max = MAX_LIMB_HEALING_TIME - cr.Skill[ SK_DOCTOR ] - target.Stat[ ST_ENDURANCE ] * HEALING_ENDURANCE_DEPENDENCY;
				max = CLAMP( max, 5, MAX_LIMB_HEALING_TIME );
				int min = MAX_LIMB_HEALING_TIME - cr.Skill[ SK_DOCTOR ] * 2 - target.Stat[ ST_ENDURANCE ] * HEALING_ENDURANCE_DEPENDENCY;
				min = CLAMP( min, 5, MAX_LIMB_HEALING_TIME );
				return description + "Choose healing method:\n\nApproximate time of healing the limb is from |0xFFFFFF " + min + " |0x00FF00 to |0xFFFFFF " + max + " |0x00FF00 minutes."; 
			}
		}
		
		return "[UNKNOWN STATE #" + stage + "]";
	}
}

bool ProccessDoctorSkill( Critter& cr, Critter& targetCr, bool alreadyAllowed )
{
	targetCr.StatBase[ST_VAR0] = cr.Id;
	cr.StatBase[ST_VAR0] = targetCr.Id;
	
	if(targetCr.Id != cr.Id && !targetCr.IsKnockout() && targetCr.Stat[ST_CURRENT_HP] > 0 && !alreadyAllowed && targetCr.IsPlayer ())
	{
		targetCr.ShowScreen( SCREEN_DIALOGBOX, 1, "answer_SelectAction" );
		targetCr.SayMsg( SAY_DIALOGBOX_TEXT, TEXTMSG_TEXT, STR_BEING_EXAMINED_PROMPT );
		targetCr.SayMsg( SAY_DIALOGBOX_BUTTON( 0 ), TEXTMSG_TEXT, STR_AGREE_EXAMINATION );
		targetCr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_BEING_EXAMINED );
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_WAITING_FOR_PATIENT );
	}
	else
	{
		answer_SelectAction(targetCr, 0, "");
	}
	
	return true;
}

void answer_SelectAction(Critter& targetCr, uint answerI, string& answerS)
{
	Critter@ cr = GetCritter( targetCr.StatBase[ST_VAR0] );
	if( !valid( cr ) )
	{
		return;
	}
	StartMenuDOC( cr, targetCr );
}

uint cte_Doc( Critter& cr, int identifier, uint& rate )
{
    cr.DamageBase[ rate ] = 0;
	
	uint[] effects =
	{
		STR_DOCTOR_EYE_HEALED,
		STR_DOCTOR_RIGHT_ARM_HEALED,
		STR_DOCTOR_LEFT_ARM_HEALED,
		STR_DOCTOR_RIGHT_LEG_HEALED,
		STR_DOCTOR_LEFT_LEG_HEALED		
	};
	
	cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, effects[ rate - DAMAGE_EYE ] );
	ChangeCritterSpeed(cr);
	
    return 0;
}

//Bandages
class BandageItem
{
	uint16 pid;
	uint8 value_heal;
	float healing_rate;
	uint8 sk_mod;
	uint8 value_bleed;
	string SoundName;
	
	BandageItem( uint16 pid, uint8 value_heal, float healing_rate, uint8 sk_mod, uint8 value_bleed, string SoundName )
	{
        this.pid = pid;
		this.value_heal = value_heal;
		this.healing_rate = healing_rate;
		this.sk_mod = sk_mod;
		this.value_bleed = value_bleed;
		this.SoundName = SoundName;
	}
}

class BandageItemCollection
{
	BandageItem@[] bandageItems;
	BandageItemCollection()
	{
	}
	
	BandageItemCollection@ bandageItem( uint16 pid, uint8 value_heal, float healing_rate, uint8 sk_mod, uint8 value_bleed, string SoundName ) 
	{
		this.bandageItems.insertLast( BandageItem( pid, value_heal, healing_rate, sk_mod, value_bleed, SoundName ) );
		return this;
	}
	
	BandageItem@ get_by_pid( uint16 pid ) 
	{
		for( uint i = 0, len = this.bandageItems.length(); i < len; i++ )
		{
			if( this.bandageItems[i].pid == pid )
			{
				return this.bandageItems[i];
			}
		}
		return null;
	}
}

BandageItemCollection@ bandageItems = BandageItemCollection()
//					    Pid   		value_heal,		healing_rate,		 sk_mod,	   value_bleed,		  SoundName
	.bandageItem( PID_BANDAGE,			20,				1.0f,				3,				6,			"bandage.ogg" 	)
	.bandageItem( PID_CRAFT_L_RAGS,		15,			  	0.5f,				5,				3,			"bandage.ogg"	);
	
BandageItem@ GetBandageItem( Item@ item )
{
    uint16 Pid = item.GetProtoId();
    return bandageItems.get_by_pid( Pid );
}

void UseBandageItem( Critter& cr, Critter& targetCr, Item& bandage )
{
	if( valid( bandage ) && valid( targetCr ) )
	{
		cr.TimeoutBase[ TO_SK_FIRST_AID ] = FIRST_AID_TIMEOUT( cr );
		start_Bandage( cr, targetCr, bandage );
	}
}

bool ltp_bandage_inited = false;
void ltp_bandage_init()
{
	LTPREG( LTP_FIRST_AID, process_Bandage )
	ltp_bandage_inited = true;
}

bool start_Bandage( Critter& cr, Critter& targetCr, Item& bandage )
{
	if( !ltp_bandage_inited )
	{
		ltp_bandage_init();
	}
	
	if( valid( targetCr ) && valid( bandage ) )
	{
		Map@ map = cr.GetMap();
		if( valid( map ) )
		{
			BandageItem@ bandageItem = GetBandageItem( bandage );
			if( valid( bandageItem ) )
			{
				PlayGenericSound( map, cr.HexX, cr.HexY, bandageItem.SoundName, 6 );
			}
		}
		
		uint hit_pause = ACTION_PAUSE_BASE - ( cr.Stat[ ST_AGILITY ] * ACTION_PAUSE_BONUS_RATE );
		uint action_pause = CLAMP( hit_pause, ACTION_PAUSE_MIN, ACTION_PAUSE_MAX );
		StartProcess( cr, LTP_FIRST_AID, 0, targetCr.Id, bandage.Id, action_pause );
		
		if( targetCr.IsKnockout() || cr.Id == targetCr.Id )
		{
			cr.SetAnims( COND_LIFE, 0, ANIM2_CROUCH );
		}
		else
		{
			cr.SetAnims( COND_LIFE, 0, ANIM2_BANDAGE );
		}
		return true;
	}
	return false;
}

uint process_Bandage( Critter@ cr, int& param0, int& param1, int& param2 )
{
	LTPROCESS( cr, param0, LTP_FIRST_AID )
	uint hit_pause = ACTION_PAUSE_BASE - ( cr.Stat[ ST_AGILITY ] * ACTION_PAUSE_BONUS_RATE );
	uint action_pause = CLAMP( hit_pause, ACTION_PAUSE_MIN, ACTION_PAUSE_MAX );
	
    Critter@ targetCr = GetCritter( param1 );
  	Item@ bandage = GetItem( param2 );
	Map@ map = cr.GetMap();
  	if( valid( targetCr ) && valid( bandage ) )
    {
		param0++;
	
		uint bandage_rate = ( cr.Skill[ SK_FIRST_AID ] / 10 ) + cr.Stat[ ST_AGILITY ] + cr.Stat[ ST_INTELLECT ];
		int difficuty = targetCr.Stat[ ST_CURRENT_HP ] >= 0 ? targetCr.Stat[ ST_MAX_LIFE ] - targetCr.Stat[ ST_CURRENT_HP ] : targetCr.Stat[ ST_MAX_LIFE ];
		int sequence_length = difficuty * 3 / bandage_rate;
		
		PlayGenericSound( map, cr.HexX, cr.HexY, "ROBE.mp3", 6 );
		
		//Log( "Bandage rate: " + bandage_rate + " Sequence length: " + sequence_length );
		if( param0 > sequence_length )
		{
			uint msgStr = cr.Id == targetCr.Id ? STR_EMOTE_BANDAGES_SELF : STR_EMOTE_BANDAGES_TERGET;
			cr.SayMsg( SAY_EMOTE, TEXTMSG_TEXT, msgStr );
			BandageResult( cr, targetCr, bandage );
			targetCr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_YOU_HAVE_BEEN_BANDAGES );
			cr.SetAnims(COND_LIFE, 0, ANIM2_IDLE);
			return 0;
		}
		return action_pause;
	}
	cr.SetAnims(COND_LIFE, 0, ANIM2_IDLE);
	return 0;
}

void BandageResult( Critter& cr, Critter& targetCr, Item& bandage )
{
	if( !valid( targetCr ) )
	{
		return;
	}
		
	if( !valid( bandage ) )
	{
		return;
	}

	BandageItem@ bandageItem = GetBandageItem( bandage );
	if( !valid( bandageItem ) )
	{
		return;
	}
	
	int heal_amount = bandageItem.value_heal + ( cr.Skill[ SK_FIRST_AID ] / bandageItem.sk_mod );
	int max_heal = targetCr.Stat[ ST_CURRENT_HP ] >= 0 ? targetCr.Stat[ ST_MAX_LIFE ] - targetCr.Stat[ ST_CURRENT_HP ] : targetCr.Stat[ ST_MAX_LIFE ];
	//Log( "cr.Skill[ SK_FIRST_AID ]: " + cr.Skill[ SK_FIRST_AID ] + " bandageItem.sk_mod: " + bandageItem.sk_mod + " heal_amount: " + heal_amount + " max_heal: " + max_heal );
	targetCr.ParamBase[ CR_BANDAGE_HEAL ] = CLAMP( targetCr.ParamBase[ CR_BANDAGE_HEAL ] + heal_amount, 0, max_heal );
	targetCr.StatBase[ ST_BLEED ] /= bandageItem.value_bleed;
	
	uint[] index;
	uint rate = uint( targetCr.Stat[ ST_HEALING_RATE ] * bandageItem.healing_rate );
	if( targetCr.GetTimeEvents( CTE_BANDAGE, index, null, null ) > 0 )
	{
		targetCr.ChangeTimeEvent( index[0], REAL_MINUTE( BANDAGE_HEALING_TIME ), rate );
	}
	else
	{
		targetCr.AddTimeEvent( "heal@cte_Bandage", REAL_MINUTE( BANDAGE_HEALING_TIME ), CTE_BANDAGE, rate );
	}
	_SubItem( bandage, 1 );
}

uint cte_Bandage( Critter& targetCr, int identifier, uint& rate )
{
	targetCr.ParamBase[ CR_BANDAGE_HEAL ] -= rate;
	targetCr.StatBase[ ST_CURRENT_HP ] += rate;
	targetCr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_BANDAGE_RESTORE_HP, "$rate" + rate );
	if( targetCr.Param[ CR_BANDAGE_HEAL ] <= 0 || targetCr.Stat[ ST_CURRENT_HP ] >= targetCr.Stat[ ST_MAX_LIFE ] )
	{
		targetCr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_BANDAGE_END );
		return 0;
    }

    ChangeCritterSpeed( targetCr );
	
    return REAL_MINUTE( BANDAGE_HEALING_TIME );
}

class HealingItem
{
	uint16 pid;
	uint8 instant_heal;
	uint8 value_heal;
	uint8 value_overdose;
	uint msg;
	bool ResurectItem;
	string SoundName;
	
	HealingItem( uint16 pid, uint8 instant_heal, uint8 value_heal, uint8 value_overdose, uint msg, bool ResurectItem, string SoundName )
	{
        this.pid = pid;
		this.instant_heal = instant_heal;
		this.value_heal = value_heal;
		this.value_overdose = value_overdose;
		this.msg = msg;
		this.ResurectItem = ResurectItem;
		this.SoundName = SoundName;
	}
}

class HealingItemCollection
{
	HealingItem@[] healingItems;
	HealingItemCollection()
	{
	}
	
	HealingItemCollection@ healingItem( uint16 pid, uint8 instant_heal, uint8 value_heal, uint8 value_overdose, uint msg, bool ResurectItem, string SoundName ) 
	{
		this.healingItems.insertLast( HealingItem( pid, instant_heal, value_heal, value_overdose, msg, ResurectItem, SoundName ) );
		return this;
	}
	
	HealingItem@ get_by_pid( uint16 pid ) 
	{
		for( uint i = 0, len = this.healingItems.length(); i < len; i++ )
		{
			if( this.healingItems[i].pid == pid )
			{
				return this.healingItems[i];
			}
		}
		return null;
	}
}

HealingItemCollection@ healingItems = HealingItemCollection()
//					    Pid         instant_heal,	value_heal,		value_overdose,	 			msg, 			 ResurectItem,			SoundName
	.healingItem( PID_TRAUMATIN,		100,			60,				75,				STR_EMOTE_INJECT_TRAUMATIN,	true,	 		 "Stimpack.ogg" 	)
	.healingItem( PID_SUPER_STIMPAK,	60,				100,			75,				STR_EMOTE_INJECT_SS, 		true,	 		 "Stimpack.ogg" 	)
	.healingItem( PID_STIMPAK,			30,				50,				30,				STR_EMOTE_INJECT_STIM, 		true,			 "Stimpack.ogg" 	)
	.healingItem( PID_HEALING_POWDER,	20,				30,				40,				STR_EMOTE_APPLY_HP, 	   	false,	  		 "powder_use.ogg"	);
	
HealingItem@ GetHealingItem( Item@ item )
{
    uint16 Pid = item.GetProtoId();
    return healingItems.get_by_pid( Pid );
}

void UseHealingItem( Critter& cr, Critter& targetCr, Item& item )
{
	if( valid( item ) )
	{
		HealingItem@ usedItem = GetHealingItem( item );
		
		if( valid( usedItem ) )
		{
			if( targetCr.IsDead() && usedItem.ResurectItem )
			{
				TryResurect( cr, targetCr );
			}
			else
			{
				cr.TimeoutBase[ TO_SK_FIRST_AID ] = FIRST_AID_TIMEOUT( cr );
				proccessHealItem( targetCr, usedItem );
			}
		}
		
		if( usedItem.pid != PID_HEALING_POWDER )
		{
			cr.AddItem( PID_HYPODERMIC_NEEDLE, 1 );
		}
		uint lineNumber = cr.Id == targetCr.Id ? usedItem.msg : usedItem.msg + 1;
		
		cr.SayMsg( SAY_EMOTE, TEXTMSG_COMBAT, lineNumber );
		
		Map@ map = cr.GetMap();
		if( valid( map ) )
		{
			PlayGenericSound( map, cr.HexX, cr.HexY, usedItem.SoundName, 5 );
		}
		
		_SubItem( item, 1 );
	}
}

void proccessHealItem( Critter& cr, HealingItem& usedItem )
{
	uint traitMul = 1;
	uint traitDiv = 1;
	
	if( cr.Trait[ TRAIT_CHEM_RELIANT ] != 0 )
	{
		traitMul = 13;
		traitDiv = 10;
	}
	
	if( cr.Trait[ TRAIT_CHEM_RESISTANT ] != 0 )
	{
		traitMul = 7;
		traitDiv = 10;
	}
	
	if( cr.ParamBase[ ST_GLOBAL_OVERDOSE ] < 100 )
	{
		cr.StatBase[ ST_CURRENT_HP ] += usedItem.instant_heal * traitMul / traitDiv;
		int healedAmount = usedItem.value_heal * traitMul / traitDiv;
		cr.AddTimeEvent( "cte_quickheal", 0, CTE_QUICKHEAL, healedAmount );
	}
	
	if( cr.Trait[TRAIT_FAST_METABOLISM] != 0 )
	{
		traitMul += 3;
		traitDiv = 10;
	}
		
	cr.ParamBase[ ST_GLOBAL_OVERDOSE ] += ( usedItem.value_overdose * traitMul / traitDiv );
	
	if( cr.ParamBase[ ST_GLOBAL_OVERDOSE ] > 100 && cr.IsPlayer() )
	{
		cr.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( true ), 100, cr.HexX, cr.HexY );
		int poisonAmount = ( usedItem.value_overdose * ( 100 - cr.Stat[ ST_POISON_RESISTANCE ] ) ) / 100;
		AffectPoison( cr, poisonAmount );
		cr.SayMsg( SAY_NETMSG, TEXTMSG_COMBAT, STR_HEALING_OVERDOSE );
	}

	if( cr.StatBase[ ST_GLOBAL_OVERDOSE ] > 0 && cr.GetTimeEvents( CTE_GLOBAL_OVERDOSE, null, null, null ) < 1 ) 
	{
		cr.AddTimeEvent( "gameplay@cte_Global_Overdose", REAL_SECOND( 0 ), CTE_GLOBAL_OVERDOSE, 0 );
	}
}

uint cte_quickheal( Critter& cr, int identifier, uint& rate ) 
{
	int heal = 5;
	if( heal > int( rate ) )
	{
		heal = rate;
	}
	bool isHealed = true;

	cr.StatBase[ ST_CURRENT_HP ] += heal;
	int16 aidTime = 5;
	
	rate -= heal;

	ChangeCritterSpeed (cr);
	
	bool repeat = true;
	if( rate <= 0 )
	{
		repeat = false;
	}
	return repeat ? aidTime : 0;
}

void TryResurect( Critter& cr, Critter& targetCr )
{
	if( targetCr.Stat[ST_MAX_LIFE] > 100 )
	{
		
		Map@ map = targetCr.GetMap();
		
		if( targetCr.ParamBase[ CR_DEATH_STAGE ] >= 50 )
		{
			cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_WASTED_ITEM );
			return;
		}
		
		for( int dx = -1; dx < 1; dx++ )
		{
			for( int dy = -1; dy < 1; dy++ )
			{
				if( map.IsHexPassed( targetCr.HexX + dx, targetCr.HexY + dy ) )
				{
					targetCr.TransitToHex( targetCr.HexX + dx, targetCr.HexY + dy, targetCr.Dir );
					break;
				}
			}
		}
		targetCr.ToLife();
		targetCr.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( true ), 1000, targetCr.HexX, targetCr.HexY );
		targetCr.StatBase[ ST_CURRENT_HP ] = __DeadHitPoints + 1;
		if( map.GetProtoId() != MAP_TLJ_ARENA1 && map.GetProtoId() != MAP_TLJ_ARENA2 )
		{
			targetCr.StatBase[ ST_MAX_LIFE ] -= 30;
		}
		
		if( targetCr.IsPlayer() )
		{
			targetCr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_RESURECTION_SUCCESS );
		}
	}
	else
	{
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_ITEM_WONT_HELP );		
	}
}

class MenuFirstAid: CenteredMenuHandler
{
    uint map_id;
	uint targetCr_id;
	
    MenuFirstAid( Map& map, Critter& targetCr )
	{
        map_id = map.Id;
		targetCr_id = targetCr.Id;
    }

    bool MenuUpdate( Critter& cr, iDialogBox& menu )
	{
        Map@ map = GetMap( map_id );
		Critter@ targetCr = GetCritter( targetCr_id );
		
        if( !valid( map ) || !valid( targetCr) )
		{
            return false;
        }
		
		if( hasItem( cr, PID_HEALING_POWDER ) && menu.Button( "Healing Powder" ) )
		{
			Item@ item = getItem( cr, PID_HEALING_POWDER );
			if( valid( item ) )
			{
				HealingItemApplied( cr, targetCr, item );
			}
			return false;
		}
		
		if( hasItem( cr, PID_STIMPAK ) && menu.Button( "Stimpack" ) )
		{
			Item@ item = getItem( cr, PID_STIMPAK );
			if( valid( item ) )
			{
				HealingItemApplied( cr, targetCr, item );
			}
			return false;
		}
		
		if( hasItem( cr, PID_SUPER_STIMPAK ) && menu.Button( "Superstim" ) )
		{
			Item@ item = getItem( cr, PID_SUPER_STIMPAK );
			if( valid( item ) )
			{
				HealingItemApplied( cr, targetCr, item );
			}
			return false;
		}
		
		if( hasItem( cr, PID_TRAUMATIN ) && menu.Button( "Traumatin" ) )
		{
			Item@ item = getItem( cr, PID_TRAUMATIN );
			if( valid( item ) )
			{
				HealingItemApplied( cr, targetCr, item );
			}
			return false;
		}
		
		if( hasItem( cr, PID_ANTIDOTE ) && menu.Button( "Antidote" ) )
		{
			Item@ item = getItem( cr, PID_ANTIDOTE );
			cr.Action( ACTION_USE_ITEM, 2, item );
			if( targetCr_id == cr.Id )
			{
				cr.SayMsg( SAY_EMOTE, TEXTMSG_TEXT, STR_EMOTE_MED_ITEM_CONSUMED, "$proto@msg item " + ( item.Proto.ProtoId * 100 ) + "@" );
				UseDrug( cr, item );
			}
			else
			{
				cr.SayMsg( SAY_EMOTE, TEXTMSG_TEXT, STR_EMOTE_MED_ITEM_USED_ON, "$proto@msg item " + ( item.Proto.ProtoId * 100 ) + "@" );
				UseDrugOn( cr, targetCr, item );
			}
			cr.ParamBase[ ST_CURRENT_AP ] -= 20 * 100;
			return false;
		}
		
		if( hasItem( cr, PID_CRAFT_L_RAGS, -1 ) && menu.Button( "Rags" ) )
		{
			Item@ item = getItem( cr, PID_CRAFT_L_RAGS );
			if( valid( item ) )
			{
				BandageItemApplied( cr, targetCr, item );
			}
			return false;
		}

		if( hasItem( cr, PID_BANDAGE, -1 ) && menu.Button( "Bandage" ) )
		{
			Item@ item = getItem( cr, PID_BANDAGE );
			if( valid( item ) )
			{
				BandageItemApplied( cr, targetCr, item );
			}
			return false;
		}
		return true;
    }
	
    string@ Description( Critter& cr )
	{
		string info = "First aid menu:";
		return info;
    }
	
    string@ ButtonCancel()
	{
        return ButtonDecorator( "Hide menu", null );
    }
}

void HealingItemApplied( Critter& cr, Critter& targetCr, Item& item )
{
	cr.Action( ACTION_USE_ITEM, 2, item );
	UseHealingItem( cr, targetCr, item );
	cr.ParamBase[ ST_CURRENT_AP ] -= 20 * 100;
}

void BandageItemApplied( Critter& cr, Critter& targetCr, Item& item )
{
	cr.Action( ACTION_USE_ITEM, 2, item );
	UseBandageItem( cr, targetCr, item );
	cr.ParamBase[ ST_CURRENT_AP ] -= 20 * 100;
}

void StartMenuFirstAid( Critter& cr, Critter& targetCr )
{
    Map@ map = cr.GetMap();
    if( map is null )
	{
        return;
    }

    iMenuHandler@ handler = MenuFirstAid( map, targetCr );
    iDialogBox@ menu = OpenMenu( cr, "", handler );
}

bool AskFirstAid( Critter& cr, Critter& targetCr, bool alreadyAllowed )
{
	targetCr.StatBase[ST_VAR0] = cr.Id;
	cr.StatBase[ST_VAR0] = targetCr.Id;
	
	if( targetCr.Id != cr.Id && !targetCr.IsKnockout() && targetCr.Stat[ST_CURRENT_HP] > 0 && !alreadyAllowed && targetCr.IsPlayer () )
	{
		targetCr.ShowScreen( SCREEN_DIALOGBOX, 1, "answer_SelectFAAction" );
		targetCr.SayMsg( SAY_DIALOGBOX_TEXT, TEXTMSG_TEXT, STR_BEING_EXAMINED_PROMPT );
		targetCr.SayMsg( SAY_DIALOGBOX_BUTTON( 0 ), TEXTMSG_TEXT, STR_AGREE_EXAMINATION );
		targetCr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_BEING_EXAMINED );
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_WAITING_FOR_PATIENT );
	}
	else
	{
		answer_SelectFAAction( targetCr, 0, "" );
	}
	
	return true;
}

void answer_SelectFAAction( Critter& targetCr, uint answerI, string& answerS )
{
	Critter@ cr = GetCritter( targetCr.StatBase[ST_VAR0] );
	if( !valid( cr ) ) 
	{
		return;
	}
	
	uint16 hx = cr.HexX, hy = cr.HexY;
	uint16 tx = targetCr.HexX, ty = targetCr.HexY;
	
	if( GetDistantion( hx, hy, tx, ty ) > 1 )
	{
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_PATIENT_TOO_FAR );
		targetCr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_DOCTOR_TOO_FAR );
		return;
	}
	StartMenuFirstAid( cr, targetCr );
}

bool AskHealingItem( Critter& cr, Critter& targetCr, Item& item, bool alreadyAllowed )
{
	targetCr.StatBase[ST_VAR0] = cr.Id;
	cr.StatBase[ST_VAR0] = targetCr.Id;
	cr.StatBase[ST_VAR1] = item.Id;
	
	if( targetCr.Id != cr.Id && !targetCr.IsKnockout() && targetCr.Stat[ST_CURRENT_HP] > 0 && !alreadyAllowed && targetCr.IsPlayer () )
	{
		targetCr.ShowScreen( SCREEN_DIALOGBOX, 1, "answer_UseHealingItem" );
		targetCr.SayMsg( SAY_DIALOGBOX_TEXT, TEXTMSG_TEXT, STR_MED_ITEM_USED_PROMPT, "$proto@msg item " + ( item.Proto.ProtoId * 100 ) + "@" );
		targetCr.SayMsg( SAY_DIALOGBOX_BUTTON( 0 ), TEXTMSG_TEXT, STR_AGREE_EXAMINATION );
		targetCr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_MED_ITEM_USED, "$proto@msg item " + ( item.Proto.ProtoId * 100 ) + "@" );
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_WAITING_FOR_PATIENT);
	}
	else
	{
		answer_SelectFAAction( targetCr, 0, "" );
	}
	
	return true;
}

void answer_UseHealingItem( Critter& targetCr, uint answerI, string& answerS )
{
	Critter@ cr = GetCritter( targetCr.StatBase[ST_VAR0] );
	Item@ item = GetItem( cr.StatBase[ST_VAR1] );
	if( !valid( cr ) ) 
	{
		return;
	}
	
	uint16 hx = cr.HexX, hy = cr.HexY;
	uint16 tx = targetCr.HexX, ty = targetCr.HexY;
	
	if( GetDistantion( hx, hy, tx, ty ) > 1 )
	{
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_PATIENT_TOO_FAR );
		targetCr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_DOCTOR_TOO_FAR );
		return;
	}
	
	if( bandage_items.find( item.GetProtoId() ) != -1 )
	{
		UseBandageItem( cr, targetCr, item );
	}
	else
	{
		UseHealingItem( cr, targetCr, item );
	}
}

#endif // HEAL