#ifndef CONSUMABLES_EFFECT
#define CONSUMABLES_EFFECT

#include "ParamChange.fos"

///Связывает имя, длительность и набор изменений которые будут применены/отменены у криттера.
///Убирает под капот проверки, имеет дефолтную заглушку "noEffect".

class Effect 
{
	uint time;
	string name;
	ParamChange@[] changes;
	
	Effect() { init(0); }
	Effect( uint time ) { init(time); }	
	
	void init( uint time ) 
	{
		name = "effect";
		this.time = time;
		changes.resize(0);
	}	
	
	Effect@ once( uint stat, int value ) 	  { return add( PermanentParamChange( stat, value ) ); }
	Effect@ setState( uint stat, int value )  { return add( ParamSet( 			  stat, value ) ); }
	Effect@ temporary( uint stat, int value ) { return add( ParamChange( 		  stat, value ) ); }	

	Effect@ add( ParamChange@ change )
	{
		changes.insertLast( change );
		
		return this;
	}	
	
	void apply( Critter& cr ) 
	{
		SayLog( cr, name + " apply to " + crInfo( cr ) );
		
		for( uint i = 0, len = changes.length(); i < len; i++ )
		{
			changes[i].apply( cr );
		}
	}	
	
	void undo( Critter& cr ) 
	{
		SayLog( cr, name + " undo to " + crInfo( cr ) );
		
		for( uint i = 0, len = changes.length(); i < len; i++ )
		{
			changes[i].undo( cr );
		}
	}	
	
	string toString() 
	{//Format: Effect(HH:MM:SS) affects: PARAM#INDEX (value)[PERMANENT], PARAM#INDEX (value), ...
		string result = "Effect(" + DeltaTime_HMS( time ) + ") affects: ";
		
		for( uint i = 0, len = changes.length(); i < len; i++ ) 
		{
			result += changes[i].toString();
			if( i + 1 < len ) result += ", ";
		}
		
		return result;
	}
}

class noEffect : Effect
{
	noEffect() { name = toString(); }
	void apply( Critter& cr ) override {}
	void undo( Critter& cr )  override {}
	string toString() override { return "[noEffect]"; }
}
#endif // CONSUMABLES_EFFECT