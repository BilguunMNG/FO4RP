
# define __MAIN_AI
# include "Ai.fosh"
# include "_global_events.fos"
# include "_macros.fos"
# include "Fractions.fosh"

import bool AddAttackPlane( Critter& critter, uint priority, Critter& target ) from "npc_planes";
import bool AddAttackPlane( Critter& critter, uint priority, Critter& target, int minHp ) from "npc_planes";

class _AiManager : iManagerModule, iAiManager, iManager_critter_init, iManager_critter_finish, iManager_critter_attacked, iManager_critter_idle
{
	_AiManager()
	{
		AddStartCallback( "ai", "Start" );
	}

	bool manager_init() override
	{
		Set( BaseAi() );
		return true;
	}
	
	bool global_critter_init( Critter& critter, bool firstTime ) override
	{
		if( critter.IsNpc() )
		{
			iAI@ result = BaseAi( critter );
			if( !Collector.exists( "" + critter.Id ) )
				Collector.set( "" + critter.Id, @result );
		}
		return true;
	}
	
	bool global_critter_finish( Critter& critter, bool toDelete ) override
	{
		if( critter.IsNpc() )
			Collector.delete( "" + critter.Id );
		return true;
	}
	
	bool global_critter_attacked( Critter& critter, Critter& attacker ) override
	{
		Critter@[] critters;
		for( uint i = 0, j = critter.GetCritters( true, FIND_LIFE_AND_KO | FIND_ONLY_NPC, critters ); i < j; i++ )
			npc_look_attack( critters[i], critter, attacker );
		
		return true;
	}
	
	void npc_look_attack( Critter& npc, Critter& critter, Critter& attacker )
	{
		iAI@ ai = Get(npc);
		if( ai !is null )
		{
			int critterPrior = ai.ProtectedRate( critter );
			int attackerPrior = ai.ProtectedRate( attacker );
			Critter@ target = null;
			
			switch( attackerPrior )
			{
			    case Relation_War:
				{
				    @target = attacker;
				} break;
			    case Relation_Dislike:
				{
				    if( critterPrior >= Relation_Like )
					@target = attacker;
				    else if( critterPrior == Relation_War )
					@target = critter;
				} break;
			    case Relation_Neutral:
				{
				    if( critterPrior == Relation_War )
					@target = critter;
				    else if( critterPrior == Relation_Ally )
					@target = attacker;
				} break;
			    case Relation_Like:
				{
				    if( critterPrior <= Relation_Dislike )
					@target = critter;
				    else if( critterPrior == Relation_Ally )
					@target = attacker;
				} break;
			    case Relation_Ally:
				{
				    if( critterPrior <= Relation_Neutral )
					@target = critter;
				} break;
			    default: break;
			}
			if( target !is null )
				npc_look_enemy( npc, target, ai );
		}
	}
	
	bool global_critter_idle( Critter& critter ) override
	{
		iAI@ ai = Get(critter);
		if( ai is null )
			return true;
			
		Critter@[] critters;
		uint countlook = critter.GetCritters( false, FIND_LIFE_AND_KO, critters );
		for( uint i = 0; i < countlook; i++ )
			npc_look_critter( critter, critters[i], ai );
		return true;
	}
	
	void npc_look_critter( Critter& npc, Critter& critter, iAI@ ai )
	{		
		// ToDo:
		if( ai.IsEnemy( critter ) )
			npc_look_enemy( npc, critter, ai );
	}
	
	void npc_look_enemy( Critter& npc, Critter& enemy, iAI@ ai )
	{
		if( ai !is null )
		{
			if( enemy.IsNpc() && ai.fraction !is null )
			{
				if( GetFraction( enemy ) is ai.fraction )
					return;
			}
			ai.AddAttackPlane( npc, enemy );
		}
	}
	
	iAI@ Get( Critter& critter ) override
	{
		if( critter.IsPlayer() ) return null;
		
		if( !Collector.exists( "" + critter.Id ) )
		{
			iAI@ result = BaseAi( critter );
			Collector.set( "" + critter.Id, @result );
			return result;
		}
		
		iAI@ result;
		Collector.get( "" + critter.Id, @result );
		return result;
	}
	
	void Set( iAI@ ai ) override
	{
		Collector.set( "ai_" + GetStrHash ( string( ai.Name ) ), @ai );
		Collector.set( "ai_" + ai.Name, @ai );
		List.insertLast( @ai );
	}
	
	void Set( Critter& critter, iAI@ ai )
	{
		
	}
	
	iAI@ Get( const string&in name ) override
	{
		iAI@ result;
		Collector.get( "ai_" + name, @result );
		return result;
	}
	
	iAI@ Get( uint nameHash ) override
	{
		iAI@ result;
		Collector.get( "ai_" + nameHash, @result );
		return result;
	}
	
	private iAI@[] List;
	private dictionary Collector;
}

 _AiManager master;
iAiManager@ get_AiManager()
{
	return @master;
}

class BaseAi : iAI
{
	BaseAi( Critter& critter )
	{
		Initialize( critter );
	}

	bool IsEnemy( Critter& target )	// if target is enemy return true else return false 
	{
		if( npc.GetProtoId() < 2200 && target.GetProtoId() >= 2200 )
			return true;
		if( @fraction is null )
			return false;
		return GetFractionRelation( fraction, target ).Value == Relation_War;
	}
	
	int ProtectedRate( Critter& target )		// return priority protection for target
	{
		if( @fraction is null )
			return 0;
		return GetFractionRelation( fraction, target ).Value;
	}
	
	void Initialize( Critter& critter )
	{
		@npc = critter;
		get_fraction();
	}
	
	uint GetWorkCritters( Critter@[] @critters, Critter& critter )	// get critters for further worked, return count critters
	{
		return 0;
	}
	
	uint GetTeamCritters( Critter& critter, Critter@[]@ critters )
	{
		return 0;
	}
	
	bool AddAttackPlane( Critter& critter, Critter& target )
	{
		return ::AddAttackPlane( critter, 0, target );
	}
	
	bool get_IsIdleWalk( )
	{
		return true;
	}
	
	bool get_IsControllerEnemy( )
	{
		return false;
	}
	
	const string get_Name( )
	{
		return "0";
	}
	
	iAI @Copy( Critter& critter )
	{
		return BaseAi( critter );
	}
	
	Fraction@ get_fraction( )
	{
		if( npc.Stat[ST_FACTION] != tempfractionname )
		{
			tempfractionname = npc.Stat[ST_FACTION];
			@_fraction = GetFraction( npc );
		}
		return _fraction;
	}
	
	int tempfractionname;
	Fraction@ _fraction;
	Critter@ npc;
}

void Start( )
{
	manager_add_module( cast<iManagerModule@>(@AiManager), "Ai", 0);
}
