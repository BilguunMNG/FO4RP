// Author: heX, cvet

/*
        Generic mob ai
        Только для мобов животных.
        Var6..Var9 заняты.
        рекомендуеться выставлять TeamId в диапазоне: 24..33
        33 - не групируется, это значит что мобы не будут помогать друг другу.
        также учтите что группа 0 тоже не группируется.

        TODO:
        сделать чтобы VarFear както уменьшался
        включать обработчик idle только если рядом есть игрок.
        таблица типа поведения монстров.
        трусость мобов - сначало нужно отбегать от атакующего, затем старатся приблизится к дому на расстоянии от атакующего.
        {
                атака тех кто атакует (нужно для блокировки чита 'бегун')
                при условии что злость(Fury) меньше X (нужно для блокировки 'pin-pong' чита)
                и текущий враг не на расстоянии поражения
                и новый враг на не слишком большой дистанции
        }
        отступление если игрок атакует из недостижимой точки (чит 'безопастной атаки').
        ? блокировка возвращения домой если мы уже стоим впритык к противнику и успешно атакуем его.
        ? отступать домой только если вся группа так решила.

        тест:
        DONE запрет атаковать всех из своей группы (ситуация вознимает если они блокируют проход)
        DONE трусость мобов - если то он не должен идти в атаку при атаке

        ok:
        DONE трусость мобов - отступление если мало жизней
        DONE скан при возвращении домой (Watch)
        DONE сброс VarX при респавне
        DONE трусость мобов - добавить отступление при больших потерях
        DONE блокировка GoHo если они уже дома
        DONE остановка преследования при большой дистанции - отладить (несрабатывает)
 */

#include "_colors.fos"
#include "_macros.fos"
#include "_npc_pids.fos"

import bool AddAttackPlane( Critter& npc, uint priority, Critter& target ) from "npc_planes";
import bool AddWalkPlane( Critter& npc, uint priority, uint16 hexX, uint16 hexY, uint8 dir, bool run, uint cut ) from "npc_planes";
import uint EraseAttackPlane( Critter& npc, Critter& target ) from "npc_planes";

import bool ChangeWildness( uint16 x, uint16 y, int delta ) from "globalmap_group";
import void ChangeMonsterCount( Critter& cr, bool increase ) from "globalmap_group";
import void ReduseWildByWildness( Critter& cr ) from "globalmap_group";

//#define DEBUG_MOB
#ifdef DEBUG_MOB
void LOG_MOB(Critter& cr, string& str) {
	if( cr.ParamBase[780] != 0 ) {
		Log(cr.Id + ": " + str);
	}
}
#endif
#ifndef DEBUG_MOB
#define LOG_MOB # (cr, str)
#endif

// OPTIONS:
#define DISTANCE_ATTACK          ( 10 ) // расстояние начала атаки
#define DISTANCE_GROUP_RADIUS    ( 15 ) // расстояние на котором группа видит друг друга (и помогает атаковать противника)
#define DISTANCE_AGGRO		  # (cr)	( ( cr.StatBase[ST_STRENGTH] + 2 ) * 2 )
#define DISTANCE_UNAGGRO	  # (cr)	( ( cr.StatBase[ST_STRENGTH] + 2 ) * 4 )
#define DISTANCE_GO_HOME         ( 15 ) // расстояние от дома при котором моб идет домой
#define MAX_FURY                 ( 2 )  // сколько раз нужно разозлить НПС чтобы он стал игнорить границы обитания
#define DISTANCE_HELP            ( 35 ) // расстояние помощи
#define TIME_TEST_GO_HOME        ( 10 ) // переодичность тестирования на возврат домой и отмену атаки

// номера сообщений
#define MSG_GROUP_ATTACK         ( 16001 )
#define MSG_GROUP_FURY           ( 16002 )

// переименования VarX (для удобства и абстрактности)
#define VarWandering             StatBase[ ST_VAR5 ]
#define VarAttacked              StatBase[ ST_VAR6 ]
#define VarFury                  StatBase[ ST_VAR7 ]
#define VarFear                  StatBase[ ST_VAR8 ]
#define VarMaxFear               StatBase[ ST_VAR9 ]

const uint16[] Pids_BestialMobs =
{
	NPC_PID_RegularRat,
	NPC_PID_Mantis,
	NPC_PID_Ant,
	NPC_PID_RegularPigRat,
	NPC_PID_Molerat,
	NPC_PID_MutatedMolerat,
	NPC_PID_SmallSilverGecko,
	NPC_PID_GoldenGecko,
	NPC_PID_WildDog,
	NPC_PID_SmallRadscorpion,
	NPC_PID_LargeRadscorpion,
	NPC_PID_Brahmin,
	// NPC_PID_SporePlant,	// - Отключил. У них нет ножек, нужен другой 'алгоритм'.
	NPC_PID_Alien,
	NPC_PID_SmDeathclaw,
	NPC_PID_Deathclaw,
	NPC_PID_ToughDeathclaw,
	NPC_PID_FireGecko,
	NPC_PID_Centaur,
	NPC_PID_Floater,
	NPC_PID_MirelurkWeak,
	
	NPC_PID_RegularRat2,
	NPC_PID_Mantis2,
	NPC_PID_Ant2,
	NPC_PID_Ant3,
	NPC_PID_RegularPigRat2,
	NPC_PID_Molerat2,
	NPC_PID_MutatedMolerat2,
	NPC_PID_SmallSilverGecko2,
	NPC_PID_GoldenGecko2,
	NPC_PID_WildDog2,
	NPC_PID_SmallRadscorpion2,
	NPC_PID_LargeRadscorpion2,
	NPC_PID_SmallBlackscorps,
	NPC_PID_LargeBlackscorps,
	NPC_PID_LargeCavescorps,
	NPC_PID_Brahmin2,
	NPC_PID_CaveGecko,
	
	NPC_PID_Alien2,
	NPC_PID_SmDeathclaw2,
	NPC_PID_Deathclaw2,
	NPC_PID_ToughDeathclaw2,
	NPC_PID_FireGecko2,
	NPC_PID_Bsti11,
	NPC_PID_Centaur2,
	NPC_PID_Floater2,
	NPC_PID_MirelurkWeak2
};

void GM_MobInit( Critter& npc ) // Export
{
    npc.SetScript( "_MobInit" );
}

void GM_MobBossInit( Critter& npc ) // Export
{
    npc.SetScript( "_BossMobInit" );
}

void GM_MobMinionInit( Critter& npc ) // Export
{
	npc.PerkBase[ PE_SILENT_RUNNING ] = 1;
    npc.SetScript( "_MinionMobInit" );
}

void _MobsMapInit( Map& map, bool firstTime )
{
    ActivateMobScript( map );
}

void _MobInit( Critter& npc, bool firstTime )
{
    npc.ModeBase[ MODE_NO_HOME ] = 1;

	npc.StatBase[ ST_REPLICATION_TIME ] = -1;

    //ResetVars( npc );

	//ST_TEAM_ID
    npc.ShowCritterDist1 = DISTANCE_AGGRO(npc);
	npc.SetEvent( CRITTER_EVENT_SHOW_CRITTER,   "_CritterBecameVisible" );
    npc.SetEvent( CRITTER_EVENT_SHOW_CRITTER_1, "_CritterInAggroRange" );
    npc.SetEvent( CRITTER_EVENT_HIDE_CRITTER, 	"_CritterOutOfSight" );
	npc.SetEvent( CRITTER_EVENT_HIDE_CRITTER_2, "_CritterOutOfAggroRange" );

	npc.ShowCritterDist2 = DISTANCE_UNAGGRO(npc);
    //npc.SetEvent( CRITTER_EVENT_SHOW_CRITTER_2, "_ShowPlayerFastAttack" );
    //npc.SetEvent( CRITTER_EVENT_HIDE_CRITTER_2, null ); //, "_HidePlayerFastAttack" );

	npc.ShowCritterDist3=0;
    //npc.SetEvent( CRITTER_EVENT_SHOW_CRITTER_3, null ); //"_ShowPlayerFastAttack" );
    //npc.SetEvent( CRITTER_EVENT_HIDE_CRITTER_3, "_HidePlayer" );

    npc.SetEvent( CRITTER_EVENT_IDLE,        "_Idle" );
    npc.SetEvent( CRITTER_EVENT_MESSAGE,     "_OnMessage" );
    npc.SetEvent( CRITTER_EVENT_PLANE_BEGIN, "_PlaneBegin" );
	npc.SetEvent( CRITTER_EVENT_PLANE_RUN, 	 "_PlaneRun" );
	npc.SetEvent( CRITTER_EVENT_PLANE_END, 	 "_PlaneEnd" );
	
    npc.SetEvent( CRITTER_EVENT_SMTH_DEAD,   null ); //"_Death" );
    npc.SetEvent( CRITTER_EVENT_DEAD,        "_MyDeath" ); //"_MyDeath");
    npc.SetEvent( CRITTER_EVENT_RESPAWN,     null ); //"_Respawn" );
    npc.SetEvent( CRITTER_EVENT_ATTACKED,    "_Attacked" );
}

void _CritterBecameVisible( Critter& self, Critter& target )
{
	uint dist = GetDistantion( self.HexX, self.HexY, target.HexX, target.HexY );
	if( int(dist) > DISTANCE_AGGRO(self) ) {
		return;
	}
    _ShowPlayer(self, target);
}
void _CritterInAggroRange( Critter& self, Critter& target )
{
	//uint dist = GetDistantion( self.HexX, self.HexY, target.HexX, target.HexY );
	if( not self.IsSee(target)) {
		return;
	}
    _ShowPlayer(self, target);
}

void _CritterOutOfSight( Critter& self, Critter& target )
{
	//keep chasing?
}

void _CritterOutOfAggroRange( Critter& self, Critter& target )
{
	self.EraseEnemyFromStack( target.Id );
	EraseAttackPlane( self, target );
}

void ActivateMobScript( Map& map ) // Export
{
    Critter@[] critters;
    for( uint i = 0, j = Pids_BestialMobs.length(); i < j; i++ )
        map.GetCritters( Pids_BestialMobs[ i ], FIND_ALL | FIND_ONLY_NPC, critters );

    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        if( critters[ i ].GetScriptId() == 0 && ( critters[ i ].Stat[ ST_TEAM_ID ] == 0 || ( critters[ i ].Stat[ ST_TEAM_ID ] >= 24 && critters[ i ].Stat[ ST_TEAM_ID ] <= 33 ) ) )
            critters[ i ].SetScript( "_MobInit" );
    }
}

void ResetVars( Critter& npc )
{
    npc.VarAttacked = 0;
    npc.VarFury = 0;
    npc.VarFear = 0;
    if( not ( npc.Stat[ ST_TEAM_ID ] == 0 || npc.Stat[ ST_TEAM_ID ] == 33 ) )
        npc.VarMaxFear = GetMyTeamCount( npc ) * 80 / 100;
    else
        npc.VarMaxFear = 10;
}

// Try go to home position
void TryGoHome( Critter& npc )
{
    if( npc.VarFury < MAX_FURY && npc.IsLife() )
    {
		LOG_MOB(npc, "TryGoHome, npc.VarFury < MAX_FURY && npc.IsLife()");
        uint   mapId = 0;
        uint16 homeX = 0;
        uint16 homeY = 0;
        uint8  dir = 0;
        npc.GetHomePos( mapId, homeX, homeY, dir );
        if( npc.GetMapId() == mapId && GetDistantion( homeX, homeY, npc.HexX, npc.HexY ) > DISTANCE_GO_HOME )
        {
			LOG_MOB(npc, "TryGoHome, npc.GetMapId() == mapId && GetDistantion( homeX, homeY, npc.HexX, npc.HexY ) > DISTANCE_GO_HOME");
            npc.DropPlanes();
            AddWalkPlane( npc, 0, homeX, homeY, dir, false, 0 );
        }
    }
}

// убегаем от когото
void AddPlaneEscape( Critter& npc, Critter& fromRunning )
{
    // TMP:
    TryGoHome( npc );
    // нужно взять угол от атакующего и бежать в противоположном направлении
    // причем нужно еще делать проверку на дистанцию
}

// собрать нпц по номеру группы
uint GetCrittersByTeam( Map& map, uint x, uint y, uint radius, int team )
{
    uint count = 0;
    Critter@[] critters;
    for( uint i = 0, j = map.GetCrittersHex( x, y, radius, FIND_LIFE | FIND_ONLY_NPC, critters ); i < j; i++ )
        if( critters[ i ].Stat[ ST_TEAM_ID ] == team )
            count++;
    return count;
}

uint GetMyTeamCount( Critter& npc )
{
	Map@ map = npc.GetMap();
	if( !valid( map ) ) return 0;
    return GetCrittersByTeam( map, npc.HexX, npc.HexY, DISTANCE_GROUP_RADIUS, npc.Stat[ ST_TEAM_ID ] );
}

// CRITTER_EVENT_SMTH_DEAD
// Когда криттер в области видимости умирает. См. CRITTER_EVENT_DEAD.
void _Death( Critter& npc, Critter& fromCrit, Critter@ killer )
{
    if( not valid( killer ) )
        return;
    if( npc.Stat[ ST_TEAM_ID ] == 0 || npc.Stat[ ST_TEAM_ID ] == 33 )
        return;

    if( npc.Stat[ ST_TEAM_ID ] == fromCrit.Stat[ ST_TEAM_ID ] )
    {
        // если убили когото из своей команды то пугаемся
        npc.VarFear++;
        if( npc.VarFear > npc.VarMaxFear )
        {
            // если слишком страшно то убегаем
            npc.DropPlanes();
            npc.EraseEnemyFromStack( killer.Id );
            AddPlaneEscape( npc, killer );
        }
    }
    else if( npc.Stat[ ST_TEAM_ID ] == killer.Stat[ ST_TEAM_ID ] )
    {
        // если ктото из своей команды убивает то поднимаем боевой дух (уменьшаем страх)
        npc.VarFear -= 2;
    }
}

// CRITTER_EVENT_DEAD
void _MyDeath( Critter& npc, Critter@ killer )
{
    npc.ClearEnemyStack();
	npc.AddTimeEvent ("cte_rotten", 0, CTE_ROTTEN, 0);
	
	//ChangeMonsterCount( npc, false );
    //ReduseWildByWildness( npc );
    //ChangeWildness(npc.WorldX/10, npc.WorldY/10, -5);
}

uint cte_rotten (Critter& cr, int identifier, uint& rate ) 
{
	if( cr.StatBase[ST_BODY_TYPE] == BT_ROBOT ) //Роботы лежат вечно.
		return 0;
	
	rate++;
	
	bool isPlant = cr.StatBase[ST_BODY_TYPE] == BT_PLANT;

	cr.StatBase[ ST_CURRENT_HP ]--;
	if( cr.Stat[ ST_CURRENT_HP ] < __DeadHitPoints - cr.Stat[ ST_MAX_LIFE ]  ) //Превращается в останки.
	{
		if( !isPlant )
		{
			Item@ bones;
			Map@ map = cr.GetMap();
			if( valid(map) )
				@bones = map.AddItem( cr.HexX, cr.HexY, Random( PID_BLOOD_BONES_1, PID_BLOOD_BONES_3 ), 1 );
			if( valid( bones) )
			{
				uint[] data = { bones.Id, rate };
				CreateTimeEvent( __FullSecond + REAL_SECOND( 60 ), "e_rotten_bones", data, true );
			}
		}
		DeleteNpc( cr );
		return 0;
	}
	if( cr.Stat[ ST_CURRENT_HP ] < __DeadHitPoints && !isPlant )
	{
		Map@ map = cr.GetMap();
		if( valid(map) )
			map.SetText( cr.HexX, cr.HexY, COLOR_SAND, "|0xFF828a96 :запах " + ( rate < 10 ? "крови" : "разложения" ) + ":" );
	}
	return REAL_SECOND( cr.Stat[ ST_MAX_LIFE ] ); //Чем крупней, тем дольше гниёт.
}

uint e_rotten_bones( uint[] @ values )
{
	if( !valid(values) || values.length() != 2 || values[0] == 0 )return 0;
	Item@ bones = GetItem( values[0] );
	if( !valid(bones) )return 0;
	
	values[1]++;
	
	bones.Val0 += Random( 1, 3 );
	if( bones.Val0 > 10 )
		DeleteItem( bones );
	
	Map@ map = GetMap( bones.MapId );
	if( valid(map) && bones.Accessory == ACCESSORY_HEX )
		map.SetText( bones.HexX, bones.HexY, COLOR_SAND, "|0xFF828a96 :запах " + ( values[1] < 10 ? "крови" : "разложения" ) + ":" );
	
	return REAL_MINUTE( Random( 5, 15 ) );
}


// CRITTER_EVENT_RESPAWN
void _Respawn( Critter& npc )
{
    // ResetVars(npc);
    DeleteNpc( npc );
}

import bool isGM( Critter& player ) from "gm";

// CRITTER_EVENT_SHOW_CRITTER
// Появился новый криттер в поле зрения.
void _ShowPlayer( Critter& npc, Critter& player )
{
    if( !player.IsPlayer() /* && player.StatBase[ST_BODY_TYPE] > 4*/ )
        return;

	LOG_MOB(npc, "_ShowPlayer");

    if( npc.StatBase[ ST_BASE_CRTYPE ] == player.StatBase[ ST_BASE_CRTYPE ] ) {
		LOG_MOB(npc, "_ShowPlayer, same base crtype");
		return;
	}

	if( int( player.Id ) == npc.StatBase [ST_FOLLOW_CRIT] || isGM( player ) )
	{
		LOG_MOB(npc, "_ShowPlayer, follow or gm");
        npc.EraseEnemyFromStack( player.Id );
        EraseAttackPlane( npc, player );
		return;
	}
	
	if( npc.StatBase[ ST_BODY_TYPE ] == BT_DOG )  //Псины.
	{
		uint dist = GetDistantion( player.HexX, player.HexY, npc.HexX, npc.HexY );
		if( int(dist) > 4 ) 
		{
			string[] emote = { "принюхивается", "рычит", "скалится", "лает" };
			int n = Random( 0, 2 ) + Random( 0, 1 );
			npc.Say( SAY_EMOTE_ON_HEAD, emote[n] );
			//npc.DropPlanes();
			npc.SetDir( GetDirection( npc.HexX, npc.HexY, player.HexX, player.HexY ) );
			return;
		}
	}
	LOG_MOB(npc, "_ShowPlayer, Attack");

	npc.SendMessage( MSG_GROUP_ATTACK, player.Id, MESSAGE_TO_WHO_SEES_ME );
	AddAttackPlane( npc, AI_PLANE_ATTACK_PRIORITY + 1, player );
}

// CRITTER_EVENT_HIDE_CRITTER
// Пропал криттер с поля зрения.
void _HidePlayer( Critter& npc, Critter& player )
{
    if( not player.IsPlayer() )
        return;

	LOG_MOB(npc, "_HidePlayer");
	
	uint[] weak_mobs = { BT_MANTI, BT_GIANT_ANT, BT_RAT, BT_RADSCORPION };
	if( weak_mobs.find( npc.StatBase[ ST_BODY_TYPE ] ) != -1 && ( npc.Stat[ ST_MAX_LIFE ] < 100 || ( npc.Stat[ ST_CURRENT_HP ] < npc.Stat[ ST_MAX_LIFE ] * 0.33 ) ) )
	{
		uint   mapId = 0;
		uint16 homeX = 0;
		uint16 homeY = 0;
		uint8  dir = 0;
		npc.GetHomePos( mapId, homeX, homeY, dir );
		
		if( npc.GetMapId() != mapId )
		{
			homeX = npc.HexX;
			homeY = npc.HexY;
		}
		
		uint dist = GetDistantion( homeX, homeY, npc.HexX, npc.HexY );
		if( dist > 20 )
		{
			npc.EraseEnemyFromStack( player.Id );
			EraseAttackPlane( npc, player );
		}
	}
}

// CRITTER_EVENT_SHOW_CRITTER
// Появился новый криттер в поле зрения.
void _ShowPlayerFastAttack( Critter& npc, Critter& player )
{
    if( not player.IsPlayer() )
        return;

	LOG_MOB(npc, "_ShowPlayerFastAttack");

	if( int( player.Id ) == npc.StatBase [ST_FOLLOW_CRIT] )
	{
        npc.EraseEnemyFromStack( player.Id );
        EraseAttackPlane( npc, player );
		return;
	}
	npc.DropPlanes();
    AddAttackPlane( npc, 0, player );
	//npc.ClearEnemyStack();
}

// CRITTER_EVENT_HIDE_CRITTER
// Пропал криттер с поля зрения.
void _HidePlayerFastAttack( Critter& npc, Critter& player )
{
    if( !player.IsPlayer() )
        return;
	LOG_MOB(npc, "_HidePlayerFastAttack");
    //EraseAttackPlane( npc, player );
}

// CRITTER_EVENT_MESSAGE
// Пришло сообщение отправленное с помощью Critter::SendMessage.
void _OnMessage( Critter& npc, Critter& fromCrit, int message, int value )
{
    if( npc.IsPlayer() )
        return;
    if( not npc.IsLife() )
        return;
    if( npc.Stat[ ST_TEAM_ID ] == 0 )
        return;                               // 0 группа не групируеться
    if( npc.Stat[ ST_TEAM_ID ] == 33 )
        return;                               // 33 группа не групируеться
    if( npc.Stat[ ST_TEAM_ID ] != fromCrit.Stat[ ST_TEAM_ID ] )
	{
		LOG_MOB(npc, "_OnMessage, ignore");
		if( npc.Param[ ST_NPC_ROLE ] == 100 )
			npc.Say( SAY_EMOTE_ON_HEAD, "Игнорит" );
        return;                               // ктото не из нашей группы
	}
	
	if( npc.Param[ ST_NPC_ROLE ] == 100 )
		npc.Say( SAY_EMOTE, "Саппортит #" + fromCrit.Id );

	LOG_MOB(npc, "_OnMessage, support "+fromCrit.Id);

    if( fromCrit.IsPlayer() )
    {
		LOG_MOB(npc, "_OnMessage, fromCrit.IsPlayer()");
        AddAttackPlane( npc, 10, fromCrit );
    }

    if( message == MSG_GROUP_ATTACK )
    {
		LOG_MOB(npc, "_OnMessage, MSG_GROUP_ATTACK");
        Critter@ target = ::GetCritter( value );
        if( not valid( target ) )
            return;
		uint dist = ::GetCrittersDistantion( npc, target ) ;
		uint max_dist = DISTANCE_UNAGGRO(npc);
		LOG_MOB(npc, "_OnMessage, dist: "+dist+" max_dist: "+max_dist);
        if( dist >= max_dist )
            return;
		LOG_MOB(npc, "_OnMessage, AddAttackPlane");
		//AddAttackPlane( npc, 0, target );
		AttackOrFind(npc, target);
    }
    else if( message == MSG_GROUP_FURY )
    {
        npc.VarFury++;
    }
}

// CRITTER_EVENT_IDLE
// Простой, вызывается каждые __CritterIdleTick секунд, для изменения времени вызывайте Critter::Wait в функции.
void _Idle( Critter& npc )
{
	if( npc.IsPlayer() ) //ХЗ как, но некоторые игровые чары ловили этот ивент на себя, в итоге движок ругался.
	{
		npc.SetEvent( CRITTER_EVENT_IDLE, null );
		return;
	}
	LOG_MOB(npc, "_Idle");

	if( npc.StatBase [ST_FOLLOW_CRIT] != 0 )
	{
		npc.DropPlanes();
		return;
	}
	
	if( npc.IsDead() || npc.IsKnockout() )
	{
		LOG_MOB(npc, "dead || knockout");
		return;
	}

	if( npc.IsBusy() || !npc.IsNoPlanes() )
	{
		LOG_MOB(npc, "_Idle, npc.IsBusy() || !npc.IsNoPlanes()");
		return;
	}
	
	if( npc.StatBase[ ST_BODY_TYPE ] == BT_DOG )  //Псины.
	{
		Map@ map = npc.GetMap();
		if( !valid(map) ) return;
		Critter@[] players;
		uint count = map.GetCrittersHex( npc.HexX, npc.HexY, 15, FIND_ONLY_PLAYERS | FIND_LIFE, players );
		Critter@ closest = null;
		uint min = 999;
		
		for( uint i = 0; i < count; i++ )
		{
			uint dist = GetDistantion( players[i].HexX, players[i].HexY, npc.HexX, npc.HexY );
			if( dist > 8 ) 
			{
				EraseAttackPlane( npc, players[i] );
				continue;
			}
			if( dist < 4 )
			{
				if( dist < min )
				{
					min = dist;
					@closest = @players[i];
				}
			}
			else 
				_ShowPlayer( npc, players[i] );
		}
		
		if( valid( closest ) )
		{
			npc.DropPlanes();
			npc.SendMessage( MSG_GROUP_ATTACK, closest.Id, MESSAGE_TO_WHO_SEES_ME );
			AddAttackPlane( npc, 0, closest );
			return;
		}
		else
			if( Random( 1, 100 ) == 100 ) 
				npc.Say( SAY_EMOTE_ON_HEAD, "воет" );
	}
	
	uint   mapId = 0;
	uint16 homeX = 0;
	uint16 homeY = 0;
	uint8  dir = 0;
	npc.GetHomePos( mapId, homeX, homeY, dir );
	
	if( npc.GetMapId() != mapId ) return; //Если не на домашней карте - не рыпаемся.
	
	if( npc.ModeBase[ MODE_NO_HOME ] == 1 )
	{
		LOG_MOB(npc, "_Idle, npc.ModeBase[ MODE_NO_HOME ] == 1");
		if( npc.VarWandering == 0 ) {
			uint dist = GetDistantion( homeX, homeY, npc.HexX, npc.HexY );

			if( int(dist) > DISTANCE_AGGRO(npc) ) //Топаем к гнезду, если загулялись.
			{
				LOG_MOB(npc, "_Idle, dist > 4");
				npc.DropPlanes();
				AddWalkPlane( npc, 0, homeX, homeY, dir, false, 0 );
			}
			else {
				LOG_MOB(npc, "_Idle, npc.MoveRandom()");
				npc.MoveRandom(); //Шароёбимся по родной лощине.
			}

			npc.VarWandering = 1;
		} else {
			npc.VarWandering = 0;
			npc.Wait(Random(1000, 3000));
		}
	}
	
	//AddWalkPlane( npc, 0, homeX + Random( -1, 1 ), homeY + Random( -1, 1 ), Random( 0, 5 ), false, 0 );
}

void _BossIdle( Critter& npc )
{
	LOG_MOB(npc, "_BossIdle");
	Map @ map = npc.GetMap();
	if( map.GetData( 0 ) <= 0 ) return; // не бродить без игроков на карте
	LOG_MOB(npc, "_BossIdle, no return");
	if( Random(0,9) == 0 )
	{
		LOG_MOB(npc, "_BossIdle, Random(0,9) == 0");
		uint16 HomeHx = npc.HexX + Random(-20,20);
		uint16 HomeHy = npc.HexY + Random(-20,20);	
		if( not map.IsHexPassed( HomeHx, HomeHy ) || map.GetPathLength( npc, HomeHx, HomeHy, 0 ) > 50 || GetDistantion( HomeHx, HomeHy, npc.HexX, npc.HexY ) <= DISTANCE_GO_HOME ) return;
		
		npc.SetHomePos( HomeHx, HomeHy, Random(0, 5) );
		TryGoHome(npc);
		//Log("leaderpatrol");
		if(npc.StatBase[ST_VAR2]!=0)
		{
			LOG_MOB(npc, "_BossIdle, leaderpatrol");
			uint[] minions = {npc.StatBase[ST_VAR2], npc.StatBase[ST_VAR3], npc.StatBase[ST_VAR4], npc.StatBase[ST_VAR5]};
			for(uint i=0,ii=minions.length();i<ii;i++)
				{
				if (minions[i]==0 || !valid(GetCritter(5000000 + minions[i])))
					{
					if(i<ii-1)
						{
						minions[i]=minions[i+1];
						minions[i+1]=0;
						}
					else minions[i]=0;
					}
				if (minions[i]==0) continue;
				Critter@ minion = GetCritter(5000000 + minions[i]);
				if (!valid(minion) || minion.IsKnockout() || minion.IsDead()) continue;
				else
					{
					if (5000000 + minion.StatBase[ST_VAR1]!= int( npc.Id ) )
						{
						if(i<ii-1)
							{
							minions[i]=minions[i+1];
							minions[i+1]=0;
							}
						else minions[i]=0;
						}
					else
						{
						minion.SetHomePos(HomeHx + Random(-5-i,5+i), HomeHy + Random(-5-i, 5+i), Random(0, 5));
						TryGoHome(minion);
						}
					}
				}
			npc.StatBase[ST_VAR2]=minions[0];
			npc.StatBase[ST_VAR3]=minions[1];
			npc.StatBase[ST_VAR4]=minions[2];
			npc.StatBase[ST_VAR5]=minions[3];
		}
	}
}

// CRITTER_EVENT_PLANE_BEGIN
// Когда движок создает план для Нпц. Вызывается и для потомков основного плана в том числе.
// int reason указывает причину начала плана (см. Plane begin/wait/end reasons в _defines.fos).
int _PlaneBegin( Critter& npc, NpcPlane& plane, int reason, Critter@ someCr, Item@ someItem )
{
	LOG_MOB(npc, "_PlaneBegin, type: "+plane.Type+ ", reason: "+reason);
    if( plane.Type == AI_PLANE_ATTACK )
    {
		LOG_MOB(npc, "_PlaneBegin, AI_PLANE_ATTACK");
        Critter@ target = ::GetCritter( plane.Attack_TargId );
        if( not valid( target ) ) {
			LOG_MOB(npc, "_PlaneBegin, not valid( target )");
			return PLANE_RUN_GLOBAL;
		}

        if( target.Stat[ ST_TEAM_ID ] == npc.Stat[ ST_TEAM_ID ] ) {
			LOG_MOB(npc, "_PlaneBegin, target.Stat[ ST_TEAM_ID ] == npc.Stat[ ST_TEAM_ID ]");
			return PLANE_DISCARD;                                                   // не атакуем всех из своей команды
		}

        if( reason == REASON_FOUND_IN_ENEMY_STACK || reason == REASON_FROM_SCRIPT )
        {
			LOG_MOB(npc, "_PlaneBegin, REASON_FOUND_IN_ENEMY_STACK || REASON_FROM_SCRIPT");
            uint distantion = ::GetCrittersDistantion( npc, target );
			bool can_see = npc.IsSee(target);
            if( int(distantion) <= DISTANCE_UNAGGRO(npc) )
            {
				LOG_MOB(npc, "_PlaneBegin, distantion <= DISTANCE_UNAGGRO(npc)");
                
				if( distantion > 1 ) {
					// анализ на дальность
					uint pathLength = npc.GetMap().GetPathLength( npc, target.HexX, target.HexY, 1 );
					// если пройти нельзя, то не идем
					if( pathLength == 0 ) {
						LOG_MOB(npc, "_PlaneBegin, pathLength == 0");
						return PLANE_DISCARD;
					}
					// если слишком далеко, то не идем
					if( pathLength > distantion * 3 ) {
						LOG_MOB(npc, "_PlaneBegin, pathLength > distantion * 3");
						return PLANE_DISCARD;
					}
				}

				//npc.SendMessage( MSG_GROUP_ATTACK, target.Id, MESSAGE_TO_WHO_SEES_ME );

				/*if( can_see ) {
					return PLANE_KEEP;
				} else {
					AddWalkPlane( npc, 0, target.HexX, target.HexY, Random( 0, 5 ), true, 1);
					return PLANE_KEEP;
				}*/
                return PLANE_KEEP;
            }
            else
            {
				LOG_MOB(npc, "_PlaneBegin, PLANE_DISCARD");
                // иначе запрещаем атаку
                return PLANE_DISCARD;
            }
        }
    } else if ( reason == REASON_FROM_SCRIPT ) {
		return PLANE_KEEP;
	}
    return PLANE_RUN_GLOBAL;
}

int _PlaneRun( Critter& npc, NpcPlane& plane, int reason, uint& r0, uint& r1, uint& r2 ) {
	LOG_MOB(npc, "_PlaneRun, type: "+plane.Type+ ", reason: "+reason);
	return PLANE_RUN_GLOBAL;
}

int _PlaneEnd( Critter& npc, NpcPlane& plane, int reason, Critter@ someCr, Item@ someItem ) {
	LOG_MOB(npc, "_PlaneEnd, type: "+plane.Type+ ", reason: "+reason);
	return PLANE_RUN_GLOBAL;
}

void AttackOrFind(Critter& self, Critter& target) {
	if( self.IsSee(target) ) {
		AddAttackPlane( self, 0, target );
	} else {
		AddWalkPlane( self, AI_PLANE_ATTACK_PRIORITY - 1, target.HexX, target.HexY, Random( 0, 5 ), true, 1);
	}
}


// CRITTER_EVENT_ATTACKED
bool _Attacked( Critter& npc, Critter& attacker )
{
	LOG_MOB(npc, "Attacked");
	if( int( attacker.Id ) == npc.StatBase [ST_FOLLOW_CRIT] )
	{
		LOG_MOB(npc, "Attackint( attacker.Id ) == npc.StatBase [ST_FOLLOW_CRIT]");
        npc.EraseEnemyFromStack( attacker.Id );
        EraseAttackPlane( npc, attacker );
		return true;
	}
    // npc.VarAttacked = attacker.Id;
    // npc.VarFury++;     // злимся
    // друзья тоже зляться!
    // npc.SendMessage( MSG_GROUP_FURY, attacker.Id, MESSAGE_TO_WHO_SEES_ME );
    // зовем друзей
    npc.SendMessage( MSG_GROUP_ATTACK, attacker.Id, MESSAGE_TO_WHO_SEES_ME );
	AttackOrFind(npc, attacker);

    // if( npc.VarFear <= npc.VarMaxFear && npc.Stat[ ST_CURRENT_HP ] < npc.Stat[ ST_MAX_LIFE ] / 5 )
        // npc.VarFear = npc.VarMaxFear + 1;
    // if( npc.VarFear > npc.VarMaxFear )
    // {
        // npc.ErasePlane( AI_PLANE_ATTACK, true );
        // AddPlaneEscape( npc, attacker );
    // }
    return true;     // Handle attacked processing
}

void _BossMobInit(Critter& npc, bool firstTime)
{
	npc.ModeBase[ MODE_NO_HOME ] = 1;
	npc.StatBase[ ST_REPLICATION_TIME ] = __FullSecond + REAL_HOUR( 2 );

	ResetVars(npc);

	npc.ShowCritterDist1 = DISTANCE_ATTACK;
	npc.SetEvent(CRITTER_EVENT_SHOW_CRITTER_1, "_ShowPlayer");
	npc.SetEvent(CRITTER_EVENT_HIDE_CRITTER  , "_HidePlayer");// отсутствие "_1" это не ошибка, так надо.

	npc.SetEvent(CRITTER_EVENT_IDLE,        "_BossIdle");
	npc.SetEvent(CRITTER_EVENT_MESSAGE,     "_OnMessage");
	npc.SetEvent(CRITTER_EVENT_PLANE_BEGIN, "_PlaneBegin");
	npc.SetEvent(CRITTER_EVENT_SMTH_DEAD,   "_Death");
	npc.SetEvent(CRITTER_EVENT_DEAD,        "_BossMyDeath");
	npc.SetEvent(CRITTER_EVENT_ATTACKED,    "_Attacked");
    npc.SetEvent(CRITTER_EVENT_RESPAWN,     "_Respawn" );	

	npc.StatBase[ST_VAR1] = npc.Id - 5000000;
}

void _MinionMobInit(Critter& npc, bool firstTime)
{
	npc.ModeBase[MODE_NO_HOME] = 1;
	npc.StatBase[ ST_REPLICATION_TIME ] = __FullSecond + REAL_HOUR( 2 );

	npc.ShowCritterDist1 = DISTANCE_ATTACK;
	npc.SetEvent(CRITTER_EVENT_SHOW_CRITTER_1, "_ShowPlayer");
	npc.SetEvent(CRITTER_EVENT_HIDE_CRITTER  , "_HidePlayer");// отсутствие "_1" это не ошибка, так надо.

	npc.SetEvent(CRITTER_EVENT_IDLE,        "_Idle");
	npc.SetEvent(CRITTER_EVENT_MESSAGE,     "_OnMessage");
	npc.SetEvent(CRITTER_EVENT_PLANE_BEGIN, "_PlaneBegin");
	npc.SetEvent(CRITTER_EVENT_SMTH_DEAD,   "_Death");
	npc.SetEvent(CRITTER_EVENT_DEAD,        "_MinionMyDeath");
	npc.SetEvent(CRITTER_EVENT_ATTACKED,    "_Attacked");
    npc.SetEvent(CRITTER_EVENT_RESPAWN,     "_Respawn" );	

	if (npc.StatBase[ST_VAR1]==0 || !valid(GetCritter( 5000000 + npc.StatBase[ST_VAR1]))) npc.AddTimeEvent( "cte_findboss",Random(10,100), 0 );
	ResetVars(npc);	
}

uint cte_findboss (Critter& npc, int identifier, uint& rate)
{
	Critter@[] critters;
	
	uint8 BossRADIUS = 10;
	
	if( npc.PerkBase[ PE_SILENT_RUNNING ] == 1 ) npc.GetMap().GetCrittersHex( npc.HexX, npc.HexY, BossRADIUS, FIND_LIFE | FIND_ONLY_NPC, critters);
	else npc.GetMap().GetCritters( npc.GetProtoId(), FIND_LIFE|FIND_ONLY_NPC, critters );
	bool noBoss = true;
	for(uint16 i = 0, j = critters.length(); i < j; i++)
		{
		if ( npc.GetProtoId() != critters[i].GetProtoId() ) continue;
		if ( npc.PerkBase[ PE_SILENT_RUNNING ] != 1 || npc.GetMap().GetPathLength( npc, critters[i].HexX, critters[i].HexY, 0 ) > 40 ) continue;
		int CrId = critters[i].Id - 5000000;
		int NpcId = npc.Id - 5000000;
		if( critters[i].StatBase[ST_VAR1] == CrId )
			{
			if (critters[i].StatBase[ST_VAR2]==0) {critters[i].StatBase[ST_VAR2]=NpcId; noBoss = false;}
			else if (critters[i].StatBase[ST_VAR3]==0) {critters[i].StatBase[ST_VAR3]=NpcId; noBoss = false;}
			else if (critters[i].StatBase[ST_VAR4]==0) {critters[i].StatBase[ST_VAR4]=NpcId; noBoss = false;}
			else if (critters[i].StatBase[ST_VAR5]==0) {critters[i].StatBase[ST_VAR5]=NpcId; noBoss = false;}
			else if (critters[i].StatBase[ST_VAR5]==0) {critters[i].StatBase[ST_VAR5]=NpcId; noBoss = false;}
			
			if(!noBoss)
				{
				npc.StatBase[ST_VAR1] = CrId;
				npc.StatBase[ ST_TEAM_ID ] = critters[ i ].StatBase[ ST_TEAM_ID ];
				//Log("foundBoss");
				break;
				}
			}
		}
	if (noBoss)	npc.SetScript("_BossMobInit");
	return 0;
}

// CRITTER_EVENT_DEAD
void _MinionMyDeath( Critter& npc, Critter@ killer )
{
    ChangeMonsterCount( npc, false );
    npc.ClearEnemyStack();     // моб забывает своих обидчиков
}

void _BossMyDeath(Critter& npc, Critter@ killer)
{
	ChangeMonsterCount(npc, false);
	npc.ClearEnemyStack(); // моб забывает своих обидчиков

	if(npc.StatBase[ST_VAR2]!=0)
		{
		uint[] minions = {npc.StatBase[ST_VAR2], npc.StatBase[ST_VAR3], npc.StatBase[ST_VAR4], npc.StatBase[ST_VAR5]};
		for(uint i=0,ii=minions.length();i<ii;i++)
			{
			if (minions[i]==0 || !valid(GetCritter(5000000 + minions[i])))
				{
				if(i<ii-1)
					{
					minions[i]=minions[i+1];
					minions[i+1]=0;
					}
				else minions[i]=0;
				}
			}
		if (minions[0]==0) return;
		Critter@ minion = GetCritter(minions[0]);
		if (!valid(minion)) return;
		minion.StatBase[ST_VAR1]=minion.Id - 5000000;
		minion.StatBase[ST_VAR2]=minions[1];
		minion.StatBase[ST_VAR3]=minions[2];
		minion.StatBase[ST_VAR4]=minions[3];
		minion.StatBase[ST_VAR5]=0;
		if (minion.IsDead())
			{
			_BossMyDeath(minion, killer);
			return;
			}
		minion.SetScript("_BossMobInit");
		for(uint i=0,ii=minions.length();i<ii;i++)
			{
			Critter@ minion_t = GetCritter(5000000 + minions[i]);
			if (valid(minion_t)) minion_t.StatBase[ST_VAR1]=minion.Id - 5000000;
			}
		}
}

uint16[] DefaultPidsOrder = {   NPC_PID_RegularRat, NPC_PID_Mantis, NPC_PID_Ant, NPC_PID_SporePlant, 
								NPC_PID_Brahmin, NPC_PID_WildDog, NPC_PID_WildDog /*wolfes*/, 
								NPC_PID_RegularPigRat, NPC_PID_Molerat, NPC_PID_SmallSilverGecko,
								NPC_PID_GoldenGecko, NPC_PID_FireGecko, NPC_PID_SmallRadscorpion,
								NPC_PID_LargeRadscorpion, NPC_PID_SmallRadscorpion /*black scorp*/,
								NPC_PID_Deathclaw, NPC_PID_MirelurkWeak, NPC_PID_Alien, NPC_PID_Alien /*mother alien*/,
								NPC_PID_Floater, NPC_PID_Centaur, NPC_PID_BanditMale /*tribal*/, 
								0 /*not implemented!*/, 0 /*not implemented!*/, NPC_PID_BanditMale /*raider*/
							};
							
uint16 NewPidToDefault(uint16 pid)
{
	if( pid < 1000 ) return pid; //Функция преобразует лишь новые пиды, не трогая старые.
	uint16 	start = 1000, 
			size = 30,
			resultPidNumber = ( pid - start ) / 30;
	if( resultPidNumber >= 0 && resultPidNumber < DefaultPidsOrder.length() )
		//Если в таблице 0 - тогда возвращает тот же пид.
		return ( DefaultPidsOrder[ resultPidNumber ] == 0 ? pid : DefaultPidsOrder[ resultPidNumber ] ); 
	else 
		return pid; //Функция преобразует лишь новые пиды, не трогая старые.
}

void _InitSkinningKnife( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_USE, "e_InitSkinningUse" );
}

bool e_InitSkinningUse( Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery )
{
	if( onCritter.StatBase[ ST_CURRENT_HP ] > 0 )
		return false;
	
	if( cr.GetTimeEvents( CTE_SKINNING, null, null, null ) > 0 || cr.TimeoutBase[ TO_BATTLE ] > int( __FullSecond ) )
	{
		cr.Say( SAY_NETMSG, "Вы итак заняты." );
		return false;
	}
	
	if( cr.Karma[ KARMA_BERSERKER ] == 0 && valid(onCritter) && onCritter.IsPlayer() && onCritter.Anim2Dead <= ANIM2_DEAD_BACK )
	{
		cr.ParamBase[ CR_VAL0 ] = onCritter.Id;
		cr.ParamBase[ ST_VAR5 ] = 3;
		cr.ShowScreen( SCREEN_DIALOGBOX, 1, "answer_cut_the_head" );
		cr.Say( SAY_DIALOGBOX_TEXT, "Вы уверены, что хотите изувечить труп? После такого его уже точно никто не откачает.");
		cr.Say( SAY_DIALOGBOX_BUTTON( 0 ), "Изувечить труп" );
		return true;
	}

	cr.ParamBase[ CR_HEXX ] = cr.HexX;
	cr.ParamBase[ CR_HEXY ] = cr.HexY;
	cr.ParamBase[ CR_VAL0 ] = ( valid(onCritter) ? onCritter.Id : 0 );

	cr.AddTimeEvent ( "cte_skinning", 0, CTE_SKINNING, 0 );
	return true;
}

import void Log_Killings( Critter& player, int target, int param1, int param2, string@ param3, int[] @ param4 ) from "gm"; // ErlKing

void answer_cut_the_head( Critter& cr, uint answerI, string& answerS )
{
	cr.StatBase[ ST_KARMA ] -= 10;
	if( cr.Karma[ KARMA_BERSERKER ] == 0 && cr.StatBase[ ST_KARMA ] < -10 )
	{
		cr.ShowScreen( SCREEN_DIALOGBOX, 1, "answer_become_cannibal" );
		cr.Say( SAY_DIALOGBOX_TEXT, "Вы хотите разделать его, словно потрошитель или какой-то каннибал?");
		cr.Say( SAY_DIALOGBOX_BUTTON( 0 ), "Пустить на мясо!" );
	}
	
	cr.ParamBase[ CR_HEXX ] = cr.HexX;
	cr.ParamBase[ CR_HEXY ] = cr.HexY;

	cr.AddTimeEvent ( "cte_skinning", 0, CTE_SKINNING, 0 );

	/*
    Critter@ targetCr = GetCritter( player.ParamBase[ CR_VAL0 ] );
    if( targetCr is null )
        return;

    if( answerI == 0 && !targetCr.IsDead() && player.ParamBase[ ST_VAR5 ] > 0 )
    {
		targetCr.ToLife();
		targetCr.ToDead( ANIM2_DEAD_BLOODY_SINGLE, player );
		targetCr.StatBase[ ST_KILLER_PERSON ] = player.Id;
		
		Log_Killings( player, targetCr.Id, 0, 0, null, null );
			
		player.Say( SAY_NETMSG, "Вы отрезали голову жертве." );
    }
	*/
}

void answer_become_cannibal( Critter& player, uint answerI, string& answerS )
{
	player.Say( SAY_NETMSG, "Ваше мировоззрение позволяет вам разделывать человеческие тела. То ещё гуро.." );
	player.KarmaBase[ KARMA_BERSERKER ] = 1;
}


uint cte_skinning( Critter& cr, int identifier, uint& rate )
{
	if( cr.TimeoutBase[ TO_TIREDNESS ] < int( __FullSecond ) ) 
    {
        cr.TimeoutBase[ TO_TIREDNESS ] = __FullSecond;
    }
	if( cr.TimeoutBase[ TO_TIREDNESS ] >= int( __FullSecond + REAL_SECOND( 60 ) ) )
	{	
		cr.Say( SAY_NETMSG, "Вы слишком устали, подождите ещё несколько секунд. Предельная усталость: 60 секунд" );
		return 0;
	}
	
	if( cr.HexX != cr.ParamBase[ CR_HEXX ] || cr.HexY != cr.ParamBase[ CR_HEXY ] || cr.TimeoutBase[ TO_BATTLE ] > int( __FullSecond ) )
	{
		cr.Say( SAY_NETMSG, "Вы отвлеклись от процесса свежевания." );
		return 0;
	}
	
	Critter@ onCritter = ( cr.ParamBase[ CR_VAL0 ] > 0 ? GetCritter( cr.ParamBase[ CR_VAL0 ] ) : null );
	if( !valid(onCritter) ) { 
		cr.Say( SAY_NETMSG, "Туша стала непригодна." );
		return 0; 
	}
	
	onCritter.ParamBase[ CR_VAL0 ] += cr.Skill[ SK_OUTDOORSMAN ] / 10; //Туша хранит в себе прогресс свежевания.
	
	if( onCritter.ParamBase[ CR_VAL0 ] < onCritter.Stat[ ST_MAX_LIFE ] )
	{
		uint dir = GetDirection ( cr.HexX, cr.HexY, onCritter.HexX, onCritter.HexY );
		cr.SetDir( dir );
		if( cr.CrType != 99 ) //Т.к. нет времени ковырять паки анимаций Гориса, поставил заглушку.
		{
			if( Random( 0, 1 ) == 0 ) cr.Animate( 0, ANIM2_PICKUP, null, false, true );
			if( Random( 0, 1 ) == 0 ) cr.Animate( 0, ANIM2_SWING_1H, null, false, true );
			if( Random( 0, 1 ) == 0 ) cr.Animate( 0, ANIM2_PICKUP, null, false, true );
			if( Random( 0, 1 ) == 0 ) cr.Animate( 0, ANIM2_USE, null, false, true );
		}
		uint time = cr.StatBase[ ST_AGILITY ] / 2;
		time = Random( CLAMP( 5 - time, 1, 10 ), 5 ); //Т.е. рандом от (11-ЛОВ/2) до 5 секунд
		cr.Say( SAY_NETMSG, "Вы разделываете тушу." );
		return REAL_SECOND( time );
	}
	
	bool skinned = false;
	uint Tired = 0;
    uint16 Add1 = 0;
	uint16 Add2 = 0;
	uint16 Add3 = 0;
	uint8  Sum1 = 0;
	uint8  Sum2 = 0;
	uint8  Sum3 = 0;
	uint16 PAdd1 = 0;
	uint16 PAdd2 = 0;
	uint16 PAdd3 = 0;
	uint8  PSum1 = 0;
	uint8  PSum2 = 0;
	uint8  PSum3 = 0;
	uint8 Exp1 = 0;
	uint8 Exp2 = 0;
	uint8 Exp3 = 0;
	string Str1 = "Из этого ничего не вышло.";
	string Str2 = "Из этого ничего не вышло.";
	string Str3 = "Из этого ничего не вышло.";
	int result = ( Random( 80, 120) * cr.Skill[SK_OUTDOORSMAN] ) / 100; //Т.е. +-20%
	
    // if( onCritter.IsDead() && onCritter.IsNpc() )
    if( onCritter.StatBase[ ST_CURRENT_HP ] < 0 && onCritter.IsNpc() ) //Можно свежевать тяжело раненных, но ещё не умирающих мобов.
    {
		Item @ darts = onCritter.GetItem(PID_DARTS_LOW, -1 );
        if( valid(darts) ) 
		{ 
			MoveItem( darts, darts.GetCount(), cr ); 
			cr.Say( SAY_NETMSG, "Вы достали дротики." ); 
		}
	
        if( onCritter.Stat[ ST_DESEASE ] != 0 )
        {
            cr.Say( SAY_NETMSG, "Уже освежован." );
            return 0;
        }
        
		uint16 npcPid = onCritter.GetProtoId();
		if( npcPid > 1000 ) npcPid = NewPidToDefault( npcPid );
		if( npcPid == 10 || npcPid == 545 ) npcPid = NPC_PID_Brahmin; //Дефолтные брамины.		
		
        switch( npcPid )
        {
			case NPC_PID_RegularRat:
			case NPC_PID_RegularRat2:
				Add1=PID_RAT_MEAT; 
				Sum1=1;
				PAdd1=PID_CRAFT_L_RAGS;
				PSum1=1;
				Exp1 = 5;
				Str1= "Вы бездарно разделываете бедную крысу.";	
				Add2=PID_RAT_MEAT;
				Sum2=1;
				PAdd2=PID_CRAFT_L_RAGS;
				PSum2=2;
				Exp2 = 10;
				Str2= "Вы разделываете бедную крысу.";
				Add3=PID_RAT_MEAT;
				Sum3=1;
				PAdd3=PID_MOUSE_SKIN;
				PSum3=1;
				Exp3 = 15;
				Str3= "Вы умело разделываете бедную крысу.";
				Tired = 20;
			break;
			
			case NPC_PID_Mantis:
			case NPC_PID_Mantis2:
				Add1=PID_RAD_MEAT;
				Sum1=0;
				PAdd1=PID_MANTIS_SHELL;
				PSum1=0;
				Exp1 = 5; 
				Str1= "Вы не смогли ни сохранить панцирь, ни достать мяса.";
				Add2=PID_RAD_MEAT;
				Sum2=1;
				PAdd2=PID_MANTIS_SHELL;
				PSum2=0;
				Exp2 = 10;
				Str2= "Вы достали мясо, но при этом сломали панцирь.";
				Add3=PID_RAD_MEAT;
				Sum3=1;
				PAdd3=PID_MANTIS_SHELL;
				PSum3=1;
				Exp3 = 15; 
				Str3= "Вы сняли панцирь и добрались до мяса.";
				Tired = 20;
				_CritAddItem( cr, PID_MANTIS_MEAT, 2 );
            break;
			
			case NPC_PID_Ant:
			case NPC_PID_Ant2:
			case NPC_PID_Ant3:
				Add1=PID_RAD_MEAT;
				Sum1=0;
				PAdd1=PID_MANTIS_SHELL;
				PSum1=0;
				Exp1 = 5; 
				Str1= "Вы не смогли ни сохранить панцирь, ни достать мяса.";
				Add2=PID_RAD_MEAT;
				Sum2=1;
				PAdd2=PID_MANTIS_SHELL;
				PSum2=1;
				Exp2 = 10;
				Str2= "Вы достали мясо, но при этом сломали панцирь.";
				Add3=PID_RAD_MEAT;
				Sum3=1;
				PAdd3=PID_MANTIS_SHELL;
				PSum3=1;
				Exp3 = 15; Str3= "Вы сняли панцирь и добрались до мяса.";
                Tired = 30;				
            break;
			
			case NPC_PID_RegularPigRat:
			case NPC_PID_RegularPigRat2:
				Add1=PID_RAD_MEAT;
				Sum1=1;
				PAdd1=PID_CRAFT_L_RAGS;
				PSum1=1;
				Exp1 = 5; 
				Str1= "В процессе добычи мяса вы исполосали кожу животного.";
				Add2=PID_RAD_MEAT;
				Sum2=1;
				PAdd2=PID_CRAFT_L_RAGS;
				PSum2=2;
				Exp2 = 10;
				Str2= "Вам удалось сохранить кожу животного и достать мяса.";
				Add3=PID_RAD_MEAT;
				Sum3=2;
				PAdd3=PID_CRAFT_L_RAGS;
				PSum3=3;
				Exp3 = 15; Str3= "Вы вырезали самые мясистые места туши, повредив шкуры.";
				Tired = 40;
            break;
			
			case NPC_PID_Molerat:
			case NPC_PID_MutatedMolerat:
			case NPC_PID_Molerat2:
			case NPC_PID_MutatedMolerat2:
				Add1=PID_RAD_MEAT;
				Sum1=1;
				PAdd1=PID_MOLERAT_STOMATCH;
				PSum1=0;
				Exp1 = 5; 
				Str1= "В процессе добычи мяса вы повредили желудок кротокрыса.";
				Add2=PID_RAD_MEAT;
				Sum2=2;
				PAdd2=PID_MOLERAT_STOMATCH;
				PSum2=1;
				Exp2 = 10; 
				Str2= "Вы вырезали желудок кротокрыса и немного мяса с ним.";
				Add3=PID_RAD_MEAT;
				Sum3=3;
				PAdd3=PID_MOLERAT_STOMATCH;
				PSum3=1;
				Exp3 = 15; Str3= "Вы вырезали желудок кротокрыса и немало мяса.";
				Tired = 60;
            break;
			
			case NPC_PID_SmallSilverGecko:
			case NPC_PID_SmallSilverGecko2:
				Add1=PID_GECKO_MEAT;
				Sum1=1;
				PAdd1=PID_CRAFT_L_RAGS;
				PSum1=2;
				Exp1 = 5; 
				Str1= "Ради мяса вы порезали тушу гекко.";
				Add2=PID_GECKO_MEAT;
				Sum2=2;
				PAdd2=PID_CRAFT_L_RAGS;
				PSum2=3;
				Exp2 = 10;
				Str2= "Вы не особо умело разделываете гекко.";
				Add3=PID_GECKO_MEAT;
				Sum3=2;
				PAdd3=PID_GECKO_PELT;
				PSum3=1;
				Exp3 = 15; Str3= "Вы аккуратно сняли шкуру с гекко, не забыв про мясо.";
				Tired = 70;
            break;
			
			case NPC_PID_GoldenGecko:
			case NPC_PID_GoldenGecko2:
				Add1=PID_GECKO_MEAT;
				Sum1=2;
				PAdd1=PID_CRAFT_L_RAGS;
				PSum1=2;
				Exp1 = 5; 
				Str1= "Ради мяса вы порезали тушу гекко.";
				Add2=PID_GECKO_MEAT;
				Sum2=4;
				PAdd2=PID_CRAFT_L_RAGS;
				PSum2=3;
				Exp2 = 10; 
				Str2= "Вы не особо умело разделываете гекко.";
				Add3=PID_GECKO_MEAT;
				Sum3=6;
				PAdd3=PID_GOLDEN_GECKO_PELT;
				PSum3=1;
				Exp3 = 15; Str3= "Вы аккуратно сняли шкуру с гекко, не забыв про мясо.";
				Tired = 90;
            break;
			
			case NPC_PID_CaveGecko:
				Add1=PID_GECKO_MEAT;
				Sum1=2;
				PAdd1=PID_CRAFT_L_RAGS;
				PSum1=2;
				Exp1 = 5; 
				Str1= "Ради мяса вы порезали тушу гекко.";
				Add2=PID_GECKO_MEAT;
				Sum2=4;
				PAdd2=PID_CRAFT_L_RAGS;
				PSum2=3;
				Exp2 = 10; 
				Str2= "Вы не особо умело разделываете гекко.";
				Add3=PID_GECKO_MEAT;
				Sum3=6;
				PAdd3=PID_PELT3;
				PSum3=1;
				Exp3 = 15; Str3= "Вы аккуратно сняли шкуру с гекко, не забыв про мясо.";
				Tired = 90;
            break;
			
			case NPC_PID_WildDog:
			case NPC_PID_WildDog2:
				Add1=PID_RAD_MEAT;
				Sum1=1;
				PAdd1=PID_WOLF_FUR;
				PSum1=1;
				Exp1 = 5; 
				Str1= "Вы не особо умело разделали животное.";
				Add2=PID_RAD_MEAT;
				Sum2=Random(1,2);
				PAdd2=PID_WOLF_FUR;
				PSum2=Random(1,2);
				Exp2 = 10; 
				Str2= "Вы разделываете тушку пса.";
				Add3=PID_RAD_MEAT;
				Sum3=2;
				PAdd3=PID_WOLF_FUR;
				PSum3=Random(2,3);
				Exp3 = 15; Str3= "Вы удачно разделали пса.";
				Tired = 70;
            break;
			
			case NPC_PID_SmallRadscorpion:
			case NPC_PID_SmallRadscorpion2:
			case NPC_PID_SmallBlackscorps:
				Add1=PID_RAD_MEAT;
				Sum1=1;
				PAdd1=PID_MANTIS_SHELL;
				PSum1=0;
				Exp1 = 5; 
				Str1= "Вы достали немного мяса из тела скорпиона.";
				Add2=PID_RAD_MEAT;
				Sum2=1;
				PAdd2=PID_MANTIS_SHELL;
				PSum2=1;
				Exp2 = 10; 
				Str2= "Отломав кусок панциря вы добрались до мяса.";
				Add3=PID_RAD_MEAT;
				Sum3=2;
				PAdd3=PID_MANTIS_SHELL;
				PSum3=2;
				Exp3 = 15; Str3= "Вы умело лишили мертвого скорпиона его жала и срезали ценные куски панциря.";
				_CritAddItem( cr, PID_SCORPION_SMALL_TAIL, 1 );
				Tired = 60;
            break;
			
			case NPC_PID_LargeRadscorpion:
			case NPC_PID_LargeRadscorpion2:
			case NPC_PID_LargeBlackscorps:
			case NPC_PID_LargeCavescorps:
				Add1=PID_RAD_MEAT;
				Sum1=2;
				PAdd1=PID_MANTIS_SHELL;
				PSum1=1;
				Exp1 = 5; 
				Str1= "Вы достали немного мяса из тела скорпиона.";
				Add2=PID_RAD_MEAT;
				Sum2=3;
				PAdd2=PID_MANTIS_SHELL;
				PSum2=2;
				Exp2 = 10;
				Str2= "Отломав кусок панциря вы добрались до мяса.";
				Add3=PID_RAD_MEAT;
				Sum3=4;
				PAdd3=PID_MANTIS_SHELL;
				PSum3=3;
				Exp3 = 15; Str3= "Вы умело лишили мертвого скорпиона его жала и срезали ценные куски панциря.";
				_CritAddItem( cr, PID_SCORPION_TAIL, 1 );
				Tired = 90;
            break;
			
			case NPC_PID_Brahmin:
			case NPC_PID_Brahmin2:
				Add1=PID_MEAT;
				Sum1=5;
				PAdd1=PID_CRAFT_L_HIDE;
				PSum1=Random(0,2);
				Exp1 = 5; 
				Str1= "Вы исполосали ножом всю шкуру.";
				Add2=PID_MEAT;
				Sum2=Random(5,8);
				PAdd2=PID_CRAFT_L_HIDE;
				PSum2=Random(1,2);
				Exp2 = 10; 
				Str2= "Вы разделали брамина не так хорошо как хотелось бы.";
				Add3=PID_MEAT;
				Sum3=10;
				PAdd3=PID_BRAHMIN_SKIN;
				PSum3=1;
				Exp3 = 15; Str3= "Вы лишили тушу брамина мяса и шкуры.";
				Tired = 120;
            break;
			
			case NPC_PID_SporePlant:
			case NPC_PID_SporePlant2:
			    Add1=PID_PLANT_SPIKE; 
				Sum1=0;
				PAdd1=PID_MUTATED_FRUIT;
				PSum1=0;
				Exp1 = 5;
				Str1= "Вы поцапапались о шипы и не смогли достать ничего.";	
				Add2=PID_PLANT_SPIKE;
				Sum2=2;
				PAdd2=PID_MUTATED_FRUIT;
				PSum2=0;
				Exp2 = 10;
				Str2= "Вы смогли взять несколько шипов, но корнеплод вытащить не смогли.";
				Add3=PID_PLANT_SPIKE;
                Sum3=4;
                PAdd3=PID_MUTATED_FRUIT;
                PSum3=1;
				Exp3 = 15;
                Str3= "Вы срезали сочный корнеплод и несколько семян.";
                Tired = 60;				
            break;
			
			case NPC_PID_Alien:
			case NPC_PID_Alien2:
				Add1=PID_RAD_MEAT;
				Sum1=3;
				PAdd1=PID_MUTATED_GLAND;
				PSum1=Random(0,1);
				Exp1 = 5; 
				Str1= "Вы небрежно распотрошили мутанта.";
				Add2=PID_RAD_MEAT;
				Sum2=Random(3,4);
				PAdd2=PID_MUTATED_GLAND;
				PSum2=1;
				Exp2 = 10; 
				Str2= "Вы извлекаете железу твари.";
				Add3=PID_RAD_MEAT;
				Sum3=Random(4,5);
				PAdd3=PID_MUTATED_GLAND;
				PSum3=1;
				Exp3 = 15; Str3= "Вы извлекаете железу твари.";	
				Tired = 70;
			break;
			
			case NPC_PID_SmDeathclaw:
			case NPC_PID_Deathclaw:
			case NPC_PID_ToughDeathclaw:
			case NPC_PID_Bsti11:
			case NPC_PID_SmDeathclaw2:
			case NPC_PID_Deathclaw2:
			case NPC_PID_ToughDeathclaw2:
				Add1=PID_RAD_MEAT;
				Sum1=2;
				PAdd1=PID_DEATHCLAW_HIDE;
				PSum1=0;
				Exp1 = 5;
				Str1= "Вы распотрошили тушу.";
				Add2=PID_RAD_MEAT;
				Sum2=3;
				PAdd2=PID_DEATHCLAW_HIDE;
				PSum2=Random(0,1);
				Exp2 = 10;
				Str2= "Вы усердно поработали ножом над тушей.";
				Add3=PID_RAD_MEAT;
				Sum3=4;
				PAdd3=PID_DEATHCLAW_HIDE;
				PSum3=1;
				Exp3 = 15; Str3= "Вы вырезали все, что посчитали возможным.";
				Tired = 180;
            break;
			
			case NPC_PID_FireGecko:
			case NPC_PID_FireGecko2:
				Add1=PID_GECKO_MEAT;
				Sum1=2;
				PAdd1=PID_CRAFT_L_RAGS;
				PSum1=4;
				Exp1 = 5; 
				Str1= "Ради мяса вы порезали тушу гекко.";
				Add2=PID_GECKO_MEAT;
				Sum2=3;
				PAdd2=PID_CRAFT_L_HIDE;
				PSum2=Random(1,2);
				Exp2 = 10;
				Str2= "Вы не особо умело разделываете гекко.";
				Add3=PID_GECKO_MEAT;
				Sum3=3;
				PAdd3=PID_FIRE_GECKO_PELT;
				PSum3=1;
				Exp3 = 15; Str3= "Вы аккуратно сняли шкуру с гекко, не забыв про мясо.";
				Tired = 100;
            break;
			
			case NPC_PID_Centaur:
			case NPC_PID_Centaur2:
				Add1=PID_RAD_MEAT;
				Sum1=3;
				PAdd1=PID_MUTATED_GLAND;
				PSum1=Random(0,1);
				Exp1 = 5; 
				Str1= "Вы небрежно распотрошили мутанта.";
				Add2=PID_RAD_MEAT;
				Sum2=Random(3,4);
				PAdd2=PID_MUTATED_GLAND;
				PSum2=1;
				Exp2 = 10;
				Str2= "Вы извлекаете железу твари.";
				Add3=PID_RAD_MEAT;
				Sum3=Random(4,5);
				PAdd3=PID_MUTATED_GLAND;
				PSum3=1;
				Exp3 = 15; Str3= "Вы извлекаете железу твари.";
				Tired = 120;
            break;
			
			case NPC_PID_Floater:
			case NPC_PID_Floater2:
				Add1=PID_RAD_MEAT;
				Sum1=3;
				PAdd1=PID_MUTATED_GLAND;
				PSum1=Random(0,1);
				Exp1 = 5; 
				Str1= "Вы небрежно распотрошили мутанта.";
				Add2=PID_RAD_MEAT;
				Sum2=Random(3,4);
				PAdd2=PID_MUTATED_GLAND;
				PSum2=1;
				Exp2 = 10; 
				Str2== "Вы извлекаете железу твари.";
				Add3=PID_RAD_MEAT;
				Sum3=Random(4,5);
				PAdd3=PID_MUTATED_GLAND;
				PSum3=1;
				Exp3 = 15; Str3= "Вы извлекаете железу твари.";
				Tired = 90;
            break;
			
			case NPC_PID_MirelurkWeak:
			case NPC_PID_MirelurkWeak2:
				Add1=PID_RAD_MEAT;
				Sum1=1;
				PAdd1=PID_MIRELUK_SHELL;
				PSum1=0;
				Exp1 = 5;
				Str1= "Разбив панцирь, вы вырезали немного мяса.";
				Add2=PID_RAD_MEAT;
				Sum2=2;
				PAdd2=PID_MANTIS_SHELL;
				PSum2=2;
				Exp2 = 10; 
				Str2= "Вы сломали панцирь в попытках его оторвать от тела болотника.";
				Add3=PID_RAD_MEAT;
				Sum3=2;
				PAdd3=PID_MIRELUK_SHELL;
				PSum3=1;
				Exp3 = 15; Str3= "Вы успешно срываете панцирь с болотника.";
				Tired = 100;
			break;
			
			case NPC_PID_BanditFemale:		
			case NPC_PID_RaiderFemale:  
			case NPC_PID_ToughFemaleThug:
			if( onCritter.IsDead() )
				onCritter.ToLife();
			onCritter.ToDead( ANIM2_DEAD_BLOODY_SINGLE, cr );

			if( cr.Karma[ KARMA_BERSERKER ] !=0 ) 
			{
				Add1=PID_MEAT;
				Sum1=1;
				PAdd1=PID_PLAYERS_EAR;
				PSum1=0;
				Exp1 = 5; 
				Str1= "Вы отрезали самую вкусную часть умирающего человека.";
				Add2=PID_MEAT;
				Sum2=2;
				PAdd2=PID_PLAYERS_EAR;
				PSum2=1;
				Exp2 = 10; 
				Str2= "Вы вырезали как можно больше мяса и взяли ухо как трофей.";
				Add3=PID_MEAT;
				Sum3=2;
				PAdd3=PID_PLAYERS_EAR;
				PSum3=2;
				Exp3 = 15; Str3= "Вы вырезали самое вкусное и отрезали уши умершего.";
				Tired = 60;
			}
			else 
			{
				cr.Say(SAY_NETMSG, "Вам не хочется издеваться над трупом.");
			}
			break;
		
			case NPC_PID_BanditMale:                           
			case NPC_PID_MauraderMale:            
			case NPC_PID_RaiderMale:              
			case NPC_PID_MaleSlaver:               
			case NPC_PID_MaleSlaver2:              
			case NPC_PID_ToughMaleThug:                     
			case NPC_PID_MaleTrapper:                                                                                     
			if( onCritter.IsDead() )
				onCritter.ToLife();
			onCritter.ToDead( ANIM2_DEAD_BLOODY_SINGLE, cr );
			
			if( cr.Karma[ KARMA_BERSERKER ] !=0 ) 
			{

				Add1=PID_MEAT;
				Sum1=1;
				PAdd1=PID_PLAYERS_EAR;
				PSum1=0;
				Exp1 = 5;
				Str1= "Вы отрезали самую вкусную часть умирающего человека.";
				Add2=PID_MEAT;
				Sum2=2;
				PAdd2=PID_PLAYERS_EAR;
				PSum2=1;
				Exp2 = 10;
				Str2= "Вы вырезали как можно больше мяса и взяли ухо как трофей.";
				Add3=PID_MEAT;
				Sum3=2;
				PAdd3=PID_PLAYERS_EAR;
				PSum3=2;
				Exp3 = 15; Str3= "Вы вырезали самое вкусное и отрезали уши умершего.";
				Tired = 60;
			}
			else 
			{
				cr.Say(SAY_NETMSG, "Вам не хочется издеваться над трупом.");
			}
			break;
			
			case NPC_PID_GreenGhoul:               
			case NPC_PID_WhiteGhoul:
			if( onCritter.IsDead() )
				onCritter.ToLife();
			onCritter.ToDead( ANIM2_DEAD_BLOODY_SINGLE, cr );
			
			if( cr.Karma[ KARMA_BERSERKER ] !=0 ) 
			{

				Add1=PID_RAD_MEAT;
				Sum1=1;
				PAdd1=PID_PLAYERS_EAR;
				PSum1=0;
				Exp1 = 5; 
				Str1= "Вы с радостью распотрошили гуля.";
				Add2=PID_RAD_MEAT;
				Sum2=2;
				PAdd2=PID_PLAYERS_EAR;
				PSum2=0;
				Exp2 = 10;
				Str2= "Вы вырезали как можно больше мяса.";
				Add3=PID_RAD_MEAT;
				Sum3=3;
				PAdd3=PID_PLAYERS_EAR;
				PSum3=Random(0,1);
				Exp3 = 15; Str3= "С тела гуля получилось мясное ассорти, на запах отвратное.";
				Tired = 60;
			}
			else 
			{
				cr.Say(SAY_NETMSG, "Вам не хочется издеваться над трупом.");
			}
			break;
		
			case NPC_PID_Supermutant: 
			if( onCritter.IsDead() )
				onCritter.ToLife();
			onCritter.ToDead( ANIM2_DEAD_BLOODY_SINGLE, cr );

			if( cr.Karma[ KARMA_BERSERKER ] !=0 ) 
			{
				Add1=PID_RAD_MEAT;
				Sum1=3;
				PAdd1=PID_PLAYERS_EAR;
				PSum1=0;
				Exp1 = 5;
				Str1= "Вы отрезали самую вкусную часть умирающего супермутанта.";
				Add2=PID_RAD_MEAT;
				Sum2=5;
				PAdd2=PID_PLAYERS_EAR;
				PSum2=1;
				Exp2 = 10;
				Str2= "Вы вырезали как можно больше мяса и взяли ухо как трофей.";
				Add3=PID_RAD_MEAT;
				Sum3=6;
				PAdd3=PID_PLAYERS_EAR;
				PSum3=2;
				Exp3 = 15; Str3= "Вы вырезали самое вкусное и отрезали уши умершего.";
				Tired = 60;
			}
			else 
			{
				cr.Say(SAY_NETMSG, "Вам не хочется издеваться над трупом.");
				return 0;
			}
			break;
		}
	}
	else if( onCritter.IsDead() && !onCritter.IsNpc() )
	{
		if( onCritter.Stat[ ST_DESEASE ] != 0 )
		{
			cr.Say( SAY_NETMSG, "Уже освежован." );
			return 0;
		}
		
		if( onCritter.IsDead() && onCritter.Anim2Dead <= ANIM2_DEAD_BACK )
		{
			onCritter.ToLife();
			onCritter.ToDead( ANIM2_DEAD_BLOODY_SINGLE, cr );
		}
		
		if(cr.Karma[ KARMA_BERSERKER ] != 0)
		{
				Add1=PID_MEAT;
				Sum1=3;
				PAdd1=PID_PLAYERS_EAR;
				PSum1=0;
				Exp1 = 5; 
				Str1= "Вы отрезали самую вкусную часть умирающего.";
				Add2=PID_MEAT;
				Sum2=4;
				PAdd2=PID_PLAYERS_EAR;
				PSum2=1;
				Exp2 = 10; 
				Str2= "Вы вырезали как можно больше мяса и взяли ухо как трофей.";
				Add3=PID_MEAT;
				Sum3=5;
				PAdd3=PID_PLAYERS_EAR;
				PSum3=2;
				Exp3 = 15; Str3= "Вы вырезали самое вкусное и отрезали уши умершего.";
				Tired = 60;
		}
		else
		{
			cr.Say(SAY_NETMSG, "Вы не каннибал-потрошитель, поэтому не стали свежевать тело.");
			return 0;
		}
	}
	
	if( result > 150 )
    {
        if( Sum3 > 0 )   _CritAddItem(cr,Add3,Sum3);
        cr.Say( SAY_NETMSG, Str3 );
        cr.StatBase[ ST_EXPERIENCE ] += Exp3;
        skinned = true;
        //if( cr.Perk[PE_GECKO_SKINNING] != 0 && PSum3 > 0)        
        if( PSum3 > 0)    _CritAddItem(cr,PAdd3,PSum3);
        cr.TimeoutBase[ TO_TIREDNESS ] += REAL_SECOND( Tired );
        /* if ( Random(1,100) < (5 + (10 -  cr.Stat[ST_LUCK])*2))
        {
        cr.ParamBase[ ST_CURRENT_HP ] -= Random(0,15);
        cr.Say( SAY_NETMSG, "Во время разделки вы случайно порезались." );
        if (Random ( 0,99) < (11-cr.Stat[ST_ENDURANCE]))
        cr.StatBase[ ST_BLOOD_TOXIC ]++;
        cr.StatBase[ ST_BLEED ] += Random (0,(11- cr.Stat[ST_LUCK])*2);
        } */
    }
    else if( result > 100 )
    {
        if( Sum2 > 0 )  _CritAddItem(cr,Add2,Sum2);
        cr.Say( SAY_NETMSG, Str2 );
        cr.StatBase[ ST_EXPERIENCE ] += Exp2;
        skinned = true;
        //if (cr.Perk[PE_GECKO_SKINNING] !=0 && PSum2 > 0)        
        if ( PSum2 > 0)     _CritAddItem(cr,PAdd2,PSum2);
        cr.TimeoutBase[ TO_TIREDNESS ] += REAL_SECOND( Tired );
        /* if ( Random(1,100) < (5 + (10 -  cr.Stat[ST_LUCK])*2))
        {
        cr.ParamBase[ ST_CURRENT_HP ] -= Random(0,15);
        cr.Say( SAY_NETMSG, "Во время разделки вы случайно порезались." );
        if (Random ( 0,99) < (11-cr.Stat[ST_ENDURANCE]))
        cr.StatBase[ ST_BLOOD_TOXIC ]++;
        cr.StatBase[ ST_BLEED ] += Random (0,(11- cr.Stat[ST_LUCK])*2);
        } */
    }
    else if( result > 40 )
    {    
        if( Sum1 > 0 )  _CritAddItem(cr,Add1,Sum1);
        cr.Say( SAY_NETMSG, Str1 );
        cr.StatBase[ ST_EXPERIENCE ] += Exp1;
        skinned = true;
        //if (cr.Perk[PE_GECKO_SKINNING] !=0 && PSum1 > 0)        
        if ( PSum1 > 0)    _CritAddItem(cr,PAdd1,PSum1);
        cr.TimeoutBase[ TO_TIREDNESS ] += REAL_SECOND( Tired );
        if ( Random(1,100) < (5 + (10 -  cr.Stat[ST_LUCK])*2))
        {
			cr.ParamBase[ ST_CURRENT_HP ] -= Random(0,15);
			cr.Say( SAY_NETMSG, "Во время разделки вы случайно порезались." );
			if (Random ( 0,99) < (11-cr.Stat[ST_ENDURANCE]))
				cr.StatBase[ ST_BLOOD_TOXIC ]++;
			cr.StatBase[ ST_BLEED ] += Random (0,(11- cr.Stat[ST_LUCK])*2);
        } 
    }
    else 
    {
		cr.Say( SAY_NETMSG, "Вы задумались о своем, забыв про разделку." );
    }
	
	if( skinned )
	{
		onCritter.StatBase[ ST_KILLER_PERSON ] = cr.Id;
		if( onCritter.StatBase[ ST_CURRENT_HP ] > 0 )
			onCritter.StatBase[ ST_CURRENT_HP ] = __DeadHitPoints * 0.5;
		onCritter.StatBase[ ST_CURRENT_HP ] += __DeadHitPoints; //ХП падает ниже некуда, скорей сгнивают останки.
		if( onCritter.IsDead() == false && onCritter.IsPlayer() == false )
		{
			if( onCritter.StatBase[ ST_CURRENT_HP ] > 0 )
			{
				cr.Say( SAY_NETMSG, "Жертва слишком сильно брыкается, у вас не вышло её разделать." );
				return 0;
			}
			else
			{
				cr.StatBase[ST_EXPERIENCE] += onCritter.Stat[ST_KILL_EXPERIENCE];
			}
		}
		onCritter.StatBase[ ST_DESEASE ] = 1;

		if( onCritter.IsPlayer() )
			Log_Killings( cr, onCritter.Id, 0, 0, null, null );
		
		if( !onCritter.IsPlayer() && onCritter.GetTimeEvents( CTE_ROTTEN, null, null, null ) < 1 )
			onCritter.AddTimeEvent( "cte_rotten", 0, CTE_ROTTEN, 0 );
	}
	
    return 0;
}


