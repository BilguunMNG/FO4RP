// Author: Anuri

#include "_utils.fos"
#include "FLAMMABLE_H.fos"

import void ExplodeEx( Map& map, uint16 hexX, uint16 hexY, uint16 effectPid, uint effectRadius, uint damage, uint damageType, uint damageRadius, uint ownerId )  from "explode";
import void InjureCritter( Critter& cr, uint dmg, uint dmgType, uint8 dir, int attackerId ) from "combat";
import bool LockInPlace( Critter& cr, Item& targetItem ) from "main";
import bool PickItem( Critter& cr, Item& targetItem ) from "main";
import bool FireUp( Item& item, uint pid, int strength ) from "firestarter";
import bool spawnFire( Map@ map, int x, int y ) from "firestarter";

const uint PIC_STILL_ANIM_ON = GetStrHash( "art\\items\\misc\\Still\\still_s_working.fofrm" );

#define STATE								Val0 	// Статус 0 - потух, 1 - заслонка 0%, 2 - заслонка 25%, 3 - заслонка 50%, 4 - заслонка 75%, 5 - заслонка 100%, 6 - работа завершена
#define SPIRIT_LEVEL						Val1 	// Уроверь спирта в браге
#define CURRENT_FUEL						Val2 	// Текущий заряд топлива
#define EVENT 								Val3 	// Для записи тайм-ивента работы аппарата
#define CURRENT_RAW_MATERIAL				Val4	// Текущий загруз браги
#define CURRENT_TEMPRATURE					Val5	// Текущая температура
#define	CURRENT_PRESSURE					Val6	// Текущее давление
#define CURRENT_PRODUCT						Val7	// Текущий объем спирта
#define IMPURITIES							Val8	// Уровень загрязнения аппарата
#define STORED_HEAT							Val9	// Запасенное тепло в системе

#define POT_LIQUID_LEVEL					Val4 	// кол-во жидкостей в кувшине браги
#define HB_POLUTION_LEVEL					Val7 	// кол-во загрязнения в браге
#define HB_SPIRIT_LEVEL						Val9 	// Градус спирта в браге

#define MAX_FUEL						( 10000 )	// Максимальный загруз топлива
#define MAX_RAW_MATERIAL				( 15000 )	// Максимальный загруз браги
#define MAX_TEMPRATURE					( 39500 )	// Максимальная температура до возгорания к
#define	MAX_PRESSURE					 ( 4000 )	// Максимальное давление до взрыва
#define MAX_PRODUCT						( 10000 )	// Максимальный выход

#define FIRE_BURNING_TIME		 REAL_SECOND( 1 ) 	// Время тика горения огня
#define FUEL_BURN_AMOUNT				   ( 45 )	// Кол-во сжигаемого топлива

//Thermodynamics - export to separate module later
#define THERM_HECHFS 					 ( 4650 ) 	// Вт/(м2*К) - коэффициент теплоотдачи от горячего флюида к стенке // heat exchange coefficient of hot fluid to surface
#define THERM_HECSCF					 ( 9.6f ) 	// 9,6, Вт/(м2*К) - коэффициент теплоотдачи стенки к холодному флюиду // heat exchange coefficient of surface to cold fluid
#define	THERM_STCC						( 52.5f ) 	// 52.5, Вт/(м*К) - коэффициент теплопроводности стенки // surface thermal conductivity coefficient
#define	THERM_STILL_D_INNER				( 0.30f ) 	// d1, м - внутренний диаметр цилиндра.
#define	THERM_STILL_D_OUTER				( 0.34f )	// d2, м - наружный диаметр цилиндра.  
#define THERM_Tf2 						( 29500 )   // Tf2 = 295, К - температура холодного флюида. Окружающей среды. // cold fluid temprature
#define THERM_WATER_TSP 		  	  ( 4.1806f )   // с = 4,1806, кДж/кг К - теплоемкость воды // water thermal storage property

//Still state
#define STATE_PREPARE 						( 0 )
#define STATE_WORKING_0 				 	( 1 )
#define STATE_WORKING_25 					( 2 )
#define STATE_WORKING_50 					( 3 )
#define STATE_WORKING_75 					( 4 )
#define STATE_WORKING_100 					( 5 )
#define STATE_FINISH    					( 6 )

const uint16[] Stills 	= { PID_STILL_B, PID_STILL_B_ACTIVE, PID_STILL_B_BROKEN, PID_STILL_S, PID_STILL_S_ACTIVE, PID_STILL_S_BROKEN };
const uint16[] Homebrew = { PID_POT_ALCO, PID_HOMEBREW };
const uint16[] wreckage = { PID_HLAM_MEH, PID_HLAM2_MEH, PID_METAL_LIST_MEH };

bool IsStill(Item& still) //export
{
	return Stills.find(still.GetProtoId()) != -1;
}

// Использование предмета на аппарате
// Вернуть false если target - это не аппарат, иначе true
bool UseItemOnStill( Critter& cr, Item@ item, Item@ still ) //export
{
	if( still is null || !IsStill(still) ) {
		return false;
	}
    Map@ map = cr.GetMap();
 	if( map is null || item is null ) {
		return true;
	}
	
	uint16 itemPid = item.GetProtoId();
	if( Igniters.find( itemPid ) != -1 ) {
		IgniteStill( cr, item, still );
	} else if( Homebrew.find( itemPid ) != -1 ) {
		AddHomebrew( cr, item, still );
	} else if( FireFuel.find( itemPid ) != -1 ) {
		FeedTheFire( cr, map, item, still );
	}

	return true;
}

bool HasFuel(Item& still) {
	return still.CURRENT_FUEL > 0;
}

bool IgniteStill( Critter& cr, Item& item, Item& target )
{	
	if( !HasFuel(target) )
	{
		cr.Say( SAY_NETMSG, "|0xFFFF00 Тут нечего разжигать, найдите подходящее топливо." );
		return false;
	}
	if( target.EVENT == 0 )
	{
		if( item.GetProtoId() == PID_FLINT && Random( 1, 300 ) > cr.Skill[SK_OUTDOORSMAN] )
		{
			_SubItem( item, 1 );
			cr.Say( SAY_NETMSG, "|0xFFFF00 Вы сточили поджиг." );
		}
		target.STATE = STATE_WORKING_100;
		_CritAnimateUse(cr);
		cr.Say( SAY_EMOTE, "Разжигает огонь" );
		target.PicMap = PIC_STILL_ANIM_ON;
		setAnimState( target );
		uint[] values = {target.Id};
		target.CURRENT_TEMPRATURE = THERM_Tf2;
		target.STORED_HEAT = target.CURRENT_TEMPRATURE * m(target) * THERM_WATER_TSP;
		target.EVENT = CreateTimeEvent( AFTER( REAL_SECOND( 0 ) ), "e_StillBurn", values, true );
	}
	return true;
}

float m( Item& target )
{
    float result = 0.09f; // масса воздуха в пустом баке на 15л // air mass in empty still
    if( target.CURRENT_RAW_MATERIAL > 0 ) {
        result = target.CURRENT_RAW_MATERIAL / 1000.0f;
    }
    return result;
}

uint e_StillBurn( uint[]@ values )
{
	uint itemId = values[0];
	Item@ target = GetItem( itemId );
	
	if( valid( target ) ) {
		if( target.STATE > STATE_PREPARE && target.CURRENT_TEMPRATURE >= THERM_Tf2 ) {
			uint16 hexX=0, hexY=0;
			Map@ map = target.GetMapPosition( hexX, hexY );
			map.PlaySound( "CHEMICAL.ACM", target.HexX, target.HexY, 5 );

			//Valve level effects burning time
			int valve_level = 0;
			switch( target.STATE ) {
				case( STATE_WORKING_0 ):
					valve_level = 0;
					break;
				case( STATE_WORKING_25 ):
					valve_level = 25;
					break;
				case( STATE_WORKING_50 ):
					valve_level = 50;
					break;
				case( STATE_WORKING_75 ):
					valve_level = 75;
					break;
				case( STATE_WORKING_100 ):
					valve_level = 100;
					break;
			}
			//RL_Thermodynamics_start_here

			/*float Q_burning = FUEL_BURN_AMOUNT * valve_level;   // Q-горения = q-горения*t-горения*M-задвижки, q-горения, кДж/с = 45 единиц игрового топлива / 39 секунд таймивента  горения = 1,15;
			
			if( target.CURRENT_FUEL <= 0 ) {
				Q_burning = 0;
			}
			
            //float delta_time = 3;//Три секунды. FIRE_BURNING_TIME

			// float heat_before = target.STORED_HEAT ;            
            target.STORED_HEAT += Q_burning; // +4500 при 100 valve_level
            // float heat_after = target.STORED_HEAT ;
            // float heat_summ = sqrt( pow( heat_before - heat_after, 2 ) + pow( delta_time, 2 )  ); 
			
			// R = (1/(a1*d1)) + ((1/2*y)*(Ln(d2/d1))) + (1/(a2*d2)) - linear thermic resistance formula
			float ti = 1.0 / ( THERM_HECHFS * THERM_STILL_D_INNER ); 										// (1/(a1*d1)) = 0.0007 0.0007;
			float log_d = log( float( THERM_STILL_D_OUTER / THERM_STILL_D_INNER) );							// (Ln(d2/d1))) = 0.125 10.1251;
			float tl = ( 1 / ( 2 * THERM_STCC ) ) * log_d; 													// (1/(2*y)*(Ln(d2/d1))) = 0.0012 0.0012;
			float to = 1.0 / ( THERM_HECSCF * THERM_STILL_D_OUTER ); 										// (1/(a2*d2)) 0.3064 0.3064;
			float R = ti + tl + to; 																		//  calculation == 0.31
			
			float M = m(target); // масса воздуха в пустом баке на 15л // air mass in empty still
			
			// float TempK_before = target.CURRENT_TEMPRATURE ;            
            // float TempK_after = target.CURRENT_TEMPRATURE;
            // float TempK_summ = sqrt( pow( TempK_before - TempK_after, 2 ) + pow( delta_time, 2 )  ); 
			
			float tmc = ( THERM_Tf2 - target.CURRENT_TEMPRATURE ) * M * THERM_WATER_TSP; 						    						// (Tf2*m*c)
			float rmcl = 1.0f + ( ( R * M * THERM_WATER_TSP ) / ( 3.14f * 1.0f ) ); 						// (1 + (R*m*c/3,14*L)) where L = size of still, 1m
			float Q_loss = ( target.STORED_HEAT + tmc ) / rmcl;												// calculation
			
			//target.STORED_HEAT -= Q_loss;

           	float T2 = ( target.STORED_HEAT / ( M * THERM_WATER_TSP ) );
			target.CURRENT_TEMPRATURE = T2;

			//Log( R + " " + tf2mc + " " + t1mc + " " + rmcl + " " + heat_summ);
			Log( target.CURRENT_TEMPRATURE * 0.01 + " == " + target.STORED_HEAT + " - " + Q_loss + "[ " + tmc + " / " + rmcl + "]" );
				
			target.CURRENT_FUEL -= FUEL_BURN_AMOUNT * valve_level / 100; */
			
			target.CURRENT_TEMPRATURE += 500;
			
			if( target.CURRENT_PRESSURE >= MAX_PRESSURE ) {
				CreateTimeEvent( AFTER( REAL_SECOND( Random( 5, 20 ) ) ),"e_Explode", values, false );
			}
			if( target.CURRENT_TEMPRATURE >= 37500 ) {
				Item@ steamFX = map.AddItem( target.HexX, target.HexY, PID_STILL_STEAM, 1 );
				uint[] values = {steamFX.Id};
				steamFX.EVENT = CreateTimeEvent( AFTER( REAL_SECOND( 1 ) ), "e_steamFX", values, false );
			}
			if( target.CURRENT_TEMPRATURE >= MAX_TEMPRATURE ) {
				spawnFire( map, target.HexX, target.HexY );
				GenerateFire( map, target.HexX, target.HexY, 1 );
			}

			return FIRE_BURNING_TIME;
		}
		target.STATE = STATE_PREPARE; // заменить на STATE_FINISH как только будет выделение спирта
		ProtoItem@ proto = GetProtoItem( PID_STILL_S );
		target.PicMap = proto.PicMap;
		setAnimState( target );
		target.EVENT = 0;
		target.STORED_HEAT = 0;
		
		uint16 hexX=0, hexY=0;
		Map@ map = target.GetMapPosition( hexX, hexY );
		Item@ fireFX = map.AddItem( target.HexX, target.HexY, PID_STEAM, 1 );
		uint[] values = {fireFX.Id};
		fireFX.EVENT = CreateTimeEvent( AFTER( REAL_SECOND( 2 ) ), "e_fireFX", values, false );
		EraseTimeEvent( target.EVENT );

	}
	return 0;
}

void GenerateFire( Map@ map, int x, int y, int r ) //exported
{
	if( !valid( map ) ) return;
	
	map.SetText( x, y, COLOR_SAND, "|0xFF828a96 :треск огня:" );
	Item@[] heated;
	map.GetItems( x, y, heated );
	for( uint i = 0; i < heated.length(); i++ )
	{	
		if( WildFires.find( heated[i].GetProtoId() ) != -1 )
			continue;
		FireUp( heated[i], WildFires[ Random( 0, WildFires.length() - 1 ) ], 1 );
	}
	spawnFire( map, x, y );
	for( int k = 1; k <= r; k++ )
	{
		for( uint i = 0; i < 6; i++ ) 
		{
			uint16 hx = x + Random( -k, k ), hy = y + Random( -k, k );
			spawnFire( map, hx, hy );
		}
	}
}

bool FeedTheFire( Critter& cr, Map& map, Item& item, Item& target )
{
	if( target.CURRENT_FUEL == MAX_FUEL)
	{	
		cr.Say( SAY_NETMSG, "|0xFFFF00 Горючее уже некуда подкладывать, дайте ему прогореть!" );
		return false;
	}
	
	_SubItem( item, 1 );
	_CritAnimateUse(cr);
	if( item.GetProtoId() == PID_COAL )
	{
		target.CURRENT_FUEL = MIN(target.CURRENT_FUEL + 5400, MAX_FUEL);
		cr.Say( SAY_EMOTE, "Подкладывает уголь" );
		map.PlaySound( "ROCK.ACM", target.HexX, target.HexY, 3 );
	}
	else
	{	
		target.CURRENT_FUEL = MIN(target.CURRENT_FUEL + 1800, MAX_FUEL);
		cr.Say( SAY_EMOTE, "Подкладывает топливо" );
		map.PlaySound( "BRDSWELL.ACM", target.HexX, target.HexY, 3 );
	}

	int occupancy_rate = ( target.CURRENT_FUEL * 100 / MAX_FUEL );
	cr.Say( SAY_NETMSG, "|0xFFFF00 Аппарат заполнен горючими материалами на " +occupancy_rate+ " %" );
	
	return true;
}

bool AddHomebrew( Critter& cr, Item& item, Item& target )
{
	Map@ map = cr.GetMap();
    if( !valid( map ) ) { return false;
	}
	if( item.GetProtoId() == PID_HOMEBREW ) {
		target.CURRENT_RAW_MATERIAL += 500;
		target.SPIRIT_LEVEL = target.SPIRIT_LEVEL + ( 500 * item.HB_SPIRIT_LEVEL / 100 );
		target.IMPURITIES += item.HB_POLUTION_LEVEL;

		map.PlaySound( "homebrew_pouring.ogg", cr.HexX, cr.HexY, 5 );
		
		_SubItem( item, 1 );
		cr.AddItem( PID_BOTTLE_GLASS, 1 );

		if( target.CURRENT_RAW_MATERIAL > MAX_RAW_MATERIAL ) {
			target.CURRENT_RAW_MATERIAL = MAX_RAW_MATERIAL;
			map.SetText( target.HexX, target.HexY, COLOR_LGRAY, ":брага переливается через край:" );
		}
	}
	/*if( item.GetProtoId() == PID_POT_ALCO ) { //лень делать, позже зафигачу
		target.CURRENT_RAW_MATERIAL += item.POT_LIQUID_LEVEL;
		target.SPIRIT_LEVEL = target.SPIRIT_LEVEL + ( item.POT_LIQUID_LEVEL * item.HB_SPIRIT_LEVEL / 100 );
		item.POT_LIQUID_LEVEL = 0;
		item.HB_SPIRIT_LEVEL = 0;
		item.HB_POLUTION_LEVEL = 0;
	}*/
	return true;
}

bool TransferToStill( Critter& cr, Item& targetItem, Item& cont ) //export to main
{
	if(!valid(cont)) { Log( "Потеря указателя на контейнер!" ); return false; 
	}
	if( cont.STATE > STATE_PREPARE ) { cr.Say( SAY_NETMSG, "|0xFF0000 Аппарат не готов к загрузу браги." ); return false; 
	}
	if( targetItem.GetProtoId() != PID_HOMEBREW ) { cr.Say( SAY_NETMSG, "|0xFF0000 Вам кажется, что из этого спирт не выделить." ); return false; 
	}
	
	Map@ map = cr.GetMap();
	uint transferAmount = cr.ItemTransferCount();
	uint16 targetItemPid = targetItem.GetProtoId();
	if( Homebrew.find( targetItemPid ) != -1 ) {
		cr.AddItem( PID_BOTTLE_GLASS, transferAmount );
		cont.CURRENT_RAW_MATERIAL = cont.CURRENT_RAW_MATERIAL + ( ( targetItem.Proto.Weight - 150 ) * transferAmount );
		
		map.PlaySound( "homebrew_pouring.ogg", cr.HexX, cr.HexY, 5 );
		
		_SubItem( targetItem, 1 );
		
		if( cont.CURRENT_RAW_MATERIAL > MAX_RAW_MATERIAL ) {
			cont.CURRENT_RAW_MATERIAL = MAX_RAW_MATERIAL;
			cr.Say( SAY_NETMSG, "|0xFFFF00 Похоже, что емкость заполнена под крышку." );
			map.SetText( cont.HexX, cont.HexY, COLOR_LGRAY, ":брага переливается через край:" );
		}
	}
	cr.ShowContainer( null, cont, TRANSFER_HEX_CONT_UP );
	return true;
}

uint e_Explode( uint[]@ values )
{
	uint itemId = values[0];
	Item@ target = GetItem( itemId );
	if( valid( target ) )    
	{
		uint16 hexX=0, hexY=0;
		Map @map = target.GetMapPosition( hexX, hexY );
		ExplodeEx( map, hexX, hexY, PID_EXPLODE_ROCKET, 2, Random( 50, 100 ), DAMAGE_EXPLODE, 2, 0 );
		map.AddItem( hexX, hexY, Ashes[ Random( 0, Ashes.length() - 1 ) ], 1 );
		Item@ fireFX = map.AddItem( hexX, hexY, PID_SMOKE, 1 );
		
		uint[] values = {fireFX.Id};
		fireFX.EVENT = CreateTimeEvent( AFTER( REAL_SECOND( 2 ) ),"e_fireFX", values, false );
		uint randomDebree = Random( 2,5 );
		for( uint i = 0; i < randomDebree; i++ )
		{
			uint16 hx=0, hy=0;
			hx = target.HexX; hy = target.HexY;
			map.MoveHexByDir( hx, hy, Random( 1, 6 ), Random( 1, 3) );
			if( map.IsHexPassed( hx, hy ) )
			{
				map.AddItem( hx, hy, wreckage[ Random( 0, wreckage.length() -1 ) ] , 1 );
			}
		}
	}
	EraseTimeEvent( target.EVENT );
	target.EVENT = 0;
	DeleteItem( target );
	return 0;
}

uint e_fireFX( uint[]@ values )
{
	uint itemId = values[0];
	Item@ e_fireFX = GetItem( itemId );
	if( valid( e_fireFX ) )  
	{
		EraseTimeEvent( e_fireFX.EVENT );
		e_fireFX.EVENT = 0;
		DeleteItem( e_fireFX );
	}
return 0;
}

uint e_steamFX( uint[]@ values )
{
	uint itemId = values[0];
	Item@ e_steamFX = GetItem( itemId );
	if( valid( e_steamFX ) )  
	{
		if( e_steamFX.CURRENT_TEMPRATURE >= 37500 ) {
			uint16 hexX=0, hexY=0;
			Map@ map = e_steamFX.GetMapPosition( hexX, hexY );
			map.PlaySound( "still_steam.ogg", hexX, hexY, 5 );
			return FIRE_BURNING_TIME;
		}
		
		EraseTimeEvent( e_steamFX.EVENT );
		e_steamFX.EVENT = 0;
		DeleteItem( e_steamFX );
	}
return 0;
}


//========== TECHNICAL_ANIMATION_STATE_CHANGER ===============//
void setAnimState( Item& target )
{
	if( target.STATE > STATE_PREPARE ) {	
		UNSETFLAG( target.Flags, ITEM_SHOW_ANIM_EXT );
		SETFLAG( target.Flags, ITEM_LIGHT );
		SETFLAG( target.Flags, ITEM_CAN_USE );
		UNSETFLAG( target.Flags, ITEM_CAN_PICKUP );
	} else {
		SETFLAG( target.Flags, ITEM_SHOW_ANIM_EXT );
		UNSETFLAG( target.Flags, ITEM_LIGHT );
	}
	target.Update();
}

//=============== STILL STATE DESCRIPTION ====================//

string@ GenerateDescription(Item& still) {
	string@ info;
	bool is_working = false;
	switch( still.STATE ) {
		case STATE_PREPARE:
			@info = "Аппарат не работает.";
			break;
		case STATE_FINISH:
			@info = "Работа аппарата завершена.";
			break;
		default:
			@info = "Аппарат работает, заслонка: ";
			is_working = true;
	}
	if( is_working ) {
		switch( still.STATE ) {
			case STATE_WORKING_0:
				info += "Закрыта.";
				break;
			case STATE_WORKING_25:
				info += "Открыта на четверть.";
				break;
			case STATE_WORKING_50:
				info += "Открыта на половину.";
				break;
			case STATE_WORKING_75:
				info += "Открыта на три четверти.";
				break;
			case STATE_WORKING_100:
				info += "Полностью открыта.";
				break;
		}

		float temprature = still.CURRENT_TEMPRATURE / 100.0 - 273.15;
		info += "\n" "Температура: " + temprature + " градусов C.";

		float pressure = still.CURRENT_PRESSURE / 1000.0;
		info += "\n" "Давление: " + pressure + " бар.";
	}

	float raw_material = still.CURRENT_RAW_MATERIAL / 1000.0;
	float max_raw_material = MAX_RAW_MATERIAL / 1000.0;
	info += "\nАппарат заполнен брагой на " + raw_material + " из " + max_raw_material + " литров.";

	string occupancy_level = ( still.CURRENT_FUEL * 100 / MAX_FUEL );
	info += "\nАппарат заполнен горючим на " + occupancy_level + " %";

	return info;
}

//=============== MAIN MENU ====================//

void ShowMenuStill( Critter& cr, Item& still ) //exported
{
	Map@ map = cr.GetMap();
    if( still is null || map is null ) {
        return;
    }

    iMenuHandler@ handler = MenuStill(still, map);
    iDialogBox@ menu = OpenMenu(cr, "Дестилятор", handler);
}

class MenuStill: CenteredMenuHandler {
	uint m_still_id;
	uint m_map_id;
	int m_last_state;
	
	MenuStill(Item& still, Map& map) {
		m_still_id = still.Id;
		m_map_id = map.Id;
	}
	bool MenuUpdate( Critter& cr, iDialogBox& menu ) {
		Item@ still = GetItem(m_still_id);
		Map@ map = GetMap(m_map_id);
		if(still is null || map is null) {
			return false;
		}

		bool locked_in_place = !FLAG( still.Flags, ITEM_CAN_PICKUP );

		// Все действия которые можно выполнить с закреплённым аппаратом
		if( locked_in_place ) {
			if ( still.STATE == STATE_PREPARE ) { // Который не начал работу
				if( menu.Button("Демонтировать") ) {
					LockInPlace( cr, still );
					return true;
				}
				if( menu.Button("Добавить брагу") ) {
					cr.ParamBase[ ST_LAST_CONT_ID ] = still.Id;
					cr.ShowContainer( null, still, TRANSFER_HEX_CONT_UP );
					return false; // чтобы не перебивать окно контейнера
				}
				if( HasFuel(still) && menu.Button("Разжечь огонь") ) {
					Item@ lighter = cr.GetItem( PID_LIGHTER, -1 );
					if( lighter is null ) {
						@lighter = cr.GetItem( PID_FLINT, -1 );
					}
					if( lighter is null ) {
						cr.Say( SAY_NETMSG, "|0xFFFF00 Вам нечем разжечь огонь." );
					} else {
						IgniteStill( cr, lighter, still );
					}
					return true;
				}
			} else if(still.STATE < STATE_FINISH ) { // Который начал, но не закончил работу
				if ( menu.Button( "Закрыть заслонку" ) ) {
					still.STATE = STATE_WORKING_0;
					return true;
				}
				if ( menu.Button( "На четверть" ) ) {
					still.STATE = STATE_WORKING_25;
					return true;
				}
				if ( menu.Button( "На половину" ) ) {
					still.STATE = STATE_WORKING_50;
					return true;
				}
				if ( menu.Button( "На две трети" ) ) {
					still.STATE = STATE_WORKING_75;
					return true;
				}
				if ( menu.Button( "Открыть полностью" ) ) {
					still.STATE = STATE_WORKING_100;
					return true;
				}
			}

			if ( still.STATE < STATE_FINISH ) { // Который не начал работу или работает
				if(menu.Button("Подкинуть горючее")) {
					Item@ fuel = FindStillFuel(cr);
					if( valid( fuel ) ) {
						FeedTheFire(cr, map, fuel, still); 
					} else {
						cr.Say( SAY_NETMSG, "|0xFF0000 У Вас нет подходящего топлива." ); 
					}				
					return true;
				}
			}
		} else {
			if( menu.Button("Установить") ) {
				LockInPlace( cr, still );
				return true;
			}
			if( menu.Button("Поднять") ) {
				PickItem( cr, still );
				return false; // предмет уже не на земле
			}
		}
		if( menu.Button("Ничего не делать") ) {
			return false;
		}
		return true;
	}

	string@ Description(Critter& cr) {
		Item@ still = GetItem(m_still_id);
		m_last_state = still.STATE;
		return GenerateDescription(still);
	}

	bool ShouldRedraw(Critter& cr) {
		Item@ still = GetItem(m_still_id);
		return still is null || IsStillWorking(still) || still.STATE != m_last_state;
    }
}

bool IsStillWorking(Item& still) {
	return still.STATE > STATE_PREPARE && still.STATE < STATE_FINISH;
}

Item@ FindStillFuel(Critter& cr) {
	Item@ fuel = null;
	for( uint i = 0, j = 9; i < j; i++)
	{
		@fuel = @cr.GetItem( FireFuel[i], -1 );
		if( fuel !is null ) {
			break;
		}
	}
	return fuel;
}
