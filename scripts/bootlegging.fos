// Author: Anuri

#include "_utils.fos"
#include "FLAMMABLE_H.fos"
#include "_dialogbox.fos"

import void ExplodeEx( Map& map, uint16 hexX, uint16 hexY, uint16 effectPid, uint effectRadius, uint damage, uint damageType, uint damageRadius, uint ownerId )  from "explode";
import void InjureCritter( Critter& cr, uint dmg, uint dmgType, uint8 dir, uint attackerId ) from "combat";
import bool LockInPlace( Critter& cr, Item& targetItem ) from "main";
import bool FireUp( Item& item, uint pid, int strength ) from "firestarter";
import bool spawnFire( Map@ map, int x, int y ) from "firestarter";

const uint PIC_STILL_ANIM_ON = GetStrHash( "art\\items\\misc\\Still\\still_s_working.fofrm" );

#define STATE								Val0 	// Статус 0 - потух, 1 - заслонка 0%, 2 - заслонка 25%, 3 - заслонка 50%, 4 - заслонка 75%, 5 - заслонка 100%, 6 - работа завершена
#define SPIRIT_LEVEL						Val1 	// Уроверь спирта в браге
#define CURRENT_FUEL						Val2 	// Текущий заряд топлива
#define EVENT 								Val3 	// Для записи тайм-ивента работы аппарата
#define CURRENT_RAW_MATERIAL				Val4	// Текущий загруз браги
#define CURRENT_TEMPRATURE					Val5	// Текущая температура
#define	CURRENT_PRESSURE					Val6	// Текущее давление
#define CURRENT_PRODUCT						Val7	// Текущий объем спирта
#define IMPURITIES							Val8	// Уровень загрязнения аппарата
#define DETERIORATION						Val9	// Уровень износа аппарата

#define POT_LIQUID_LEVEL					Val4 	// кол-во жидкостей в кувшине браги
#define HB_POLUTION_LEVEL					Val7 	// кол-во загрязнения в браге
#define HB_SPIRIT_LEVEL						Val9 	// Градус спирта в браге

#define MAX_FUEL						( 10000 )	// Максимальный загруз топлива
#define MAX_RAW_MATERIAL				( 15000 )	// Максимальный загруз браги
#define MAX_TEMPRATURE					  ( 120 )	// Максимальная температура до возгорания
#define	MAX_PRESSURE					  ( 320 )	// Максимальное давление до взрыва
#define MAX_PRODUCT						( 10000 )	// Максимальный выход

#define FIRE_BURNING_TIME		REAL_SECOND( 39 ) 	// Время тика горения огня

#define STATE_PREPARE 						( 0 )
#define STATE_WORKING_0 				 	( 1 )
#define STATE_WORKING_25 					( 2 )
#define STATE_WORKING_50 					( 3 )
#define STATE_WORKING_75 					( 4 )
#define STATE_WORKING_100 					( 5 )
#define STATE_FINISH    					( 6 )

const uint16[] Stills 	= { PID_STILL_B, PID_STILL_B_ACTIVE, PID_STILL_B_BROKEN, PID_STILL_S, PID_STILL_S_ACTIVE, PID_STILL_S_BROKEN };
const uint16[] Homebrew = { PID_POT_ALCO, PID_HOMEBREW };
const uint16[] wreckage = { PID_HLAM_MEH, PID_HLAM2_MEH, PID_METAL_LIST_MEH };

bool StillCheck( Critter& cr, Item@ item, Item@ target ) //exported - проверки на разное перед началом работы
{
    Map@ map = cr.GetMap();
 	if( !valid( map ) ) { return false; }
	if( !valid( item ) || !valid(target) ) { return false; }
	if(	Stills.find( target.GetProtoId() ) == -1 ) { return false; }
	
	uint16 itemPid = item.GetProtoId();
	if( Igniters.find( itemPid ) != -1 ) { IgniteStill( cr, item, target ); return true; }
	if( Homebrew.find( itemPid ) != -1 ) { AddHomebrew( cr, item, target ); return true; }
	if( FireFuel.find( itemPid ) != -1 ) { FeedTheFire( cr, item, target ); return true; }

	return true;
}

bool IgniteStill( Critter& cr, Item& item, Item& target )
{
	Map@ map = cr.GetMap();
    if( !valid( map ) ) { return false; }
	
	if( target.CURRENT_FUEL == 0 )
	{
		cr.Say( SAY_NETMSG, "|0xFFFF00 Тут нечего разжигать, найдите подходящее топливо." );
		return false;
	}
	if( target.STATE == 0 && target.CURRENT_FUEL > 0 )
	{
		if( item.GetProtoId() == PID_FLINT && Random( 1, 300 ) > cr.Skill[SK_OUTDOORSMAN] )
		{
			_SubItem( item, 1 );
			cr.Say( SAY_NETMSG, "|0xFFFF00 Вы сточили поджиг." );
		}
		target.STATE++;
		_CritAnimateUse(cr);
		cr.Say( SAY_EMOTE, "Разжигает огонь" );
		target.PicMap = PIC_STILL_ANIM_ON;
		setAnimState( target );
		uint[] values = {target.Id};
		target.EVENT = CreateTimeEvent( AFTER( REAL_SECOND( 0 ) ), "e_StillBurn", values, true );
	}
	return true;
}

uint e_StillBurn( uint[]@ values )
{
	uint itemId = values[0];
	Item@ target = GetItem( itemId );
	if( valid( target ) )    
	{
		target.CURRENT_FUEL -= 45;
		if( target.CURRENT_FUEL > 0 )
		{
			uint16 hexX=0, hexY=0;
			Map @map = target.GetMapPosition( hexX, hexY );
			map.PlaySound( "CHEMICAL.ACM", target.HexX, target.HexY, 5 );
			switch( target.STATE ) {
				case ( 1 ):
					break;
				case ( 2 ):
					break;
				case ( 3 ):
					break;
				case ( 4 ):
					break;
				case( 5 ):
					break;
			}
			target.CURRENT_TEMPRATURE += 30;
			target.CURRENT_PRESSURE += 100;
			if( target.CURRENT_PRESSURE >= MAX_PRESSURE ) {
				CreateTimeEvent( AFTER( REAL_SECOND( Random( 5, 20 ) ) ),"e_Explode", values, true );
			}
			if(target.CURRENT_TEMPRATURE >= MAX_TEMPRATURE ) {
				spawnFire( map, target.HexX, target.HexY );
				GenerateFire( map, target.HexX, target.HexY, 1 );
			}
			return FIRE_BURNING_TIME;
		}
		target.STATE--;
		ProtoItem@ proto = GetProtoItem( PID_STILL_S );
		target.PicMap = proto.PicMap;
		setAnimState( target );
		target.Update();
		uint16 hexX=0, hexY=0;
		EraseTimeEvent( target.EVENT );
		target.EVENT = 0;
	}
	return 0;
}

void GenerateFire( Map@ map, int x, int y, int r ) //exported
{
	if( !valid( map ) ) return;
	
	map.SetText( x, y, COLOR_SAND, "|0xFF828a96 :треск огня:" );
	Item@[] heated;
	map.GetItems( x, y, heated );
	for( uint i = 0; i < heated.length(); i++ )
	{	
		uint16[] WildFires = { PID_WILDFIRE_1, PID_WILDFIRE_2, PID_WILDFIRE_3, PID_WILDFIRE_4, PID_WILDFIRE_5 };
		if( WildFires.find( heated[i].GetProtoId() ) != -1 )
			continue;
		FireUp( heated[i], WildFires[ Random( 0, WildFires.length() - 1 ) ], 1 );
	}
	spawnFire( map, x, y );
	for( int k = 1; k <= r; k++ )
	{
		for( uint i = 0; i < 6; i++ ) 
		{
			uint16 hx = x + Random( -k, k ), hy = y + Random( -k, k );
			spawnFire( map, hx, hy );
		}
	}
}

bool FeedTheFire( Critter& cr, Item& item, Item& target )
{
	Map@ map = cr.GetMap();
	if( target.CURRENT_FUEL == MAX_FUEL)
	{	
		cr.Say( SAY_NETMSG, "|0xFFFF00 Горючее уже некуда подкладывать, дайте ему прогореть!" );
		return false;
	}
	_SubItem( item, 1 );
	_CritAnimateUse(cr);
	if( item.GetProtoId() == PID_COAL )
	{
		target.CURRENT_FUEL = MIN(target.CURRENT_FUEL + 5400, MAX_FUEL);
		cr.Say( SAY_EMOTE, "Подкладывает уголь" );
		map.PlaySound( "ROCK.ACM", target.HexX, target.HexY, 3 );
	}
	else
	{	
		target.CURRENT_FUEL = MIN(target.CURRENT_FUEL + 1800, MAX_FUEL);
		cr.Say( SAY_EMOTE, "Подкладывает топливо" );
		map.PlaySound( "BRDSWELL.ACM", target.HexX, target.HexY, 3 );
	}

	int occupancy_rate = ( target.CURRENT_FUEL * 100 / MAX_FUEL );
	cr.Say( SAY_NETMSG, "|0xFFFF00 Аппарат заполнен горючими материалами на " +occupancy_rate+ " %" );
	
	return true;
}

bool AddHomebrew( Critter& cr, Item& item, Item& target )
{
	Map@ map = cr.GetMap();
    if( !valid( map ) ) { return false;
	}
	if( item.GetProtoId() == PID_HOMEBREW ) {
		target.CURRENT_RAW_MATERIAL += 500;
		target.SPIRIT_LEVEL = target.SPIRIT_LEVEL + ( 500 * item.HB_SPIRIT_LEVEL / 100 );
		target.IMPURITIES += item.HB_POLUTION_LEVEL;
		map.PlaySound( "homebrew_pouring.ogg", cr.HexX, cr.HexY, 5 );
		_SubItem( item, 1 );
		cr.AddItem( PID_BOTTLE_GLASS, 1 );
		if( target.CURRENT_RAW_MATERIAL > MAX_RAW_MATERIAL ) {
			target.CURRENT_RAW_MATERIAL = MAX_RAW_MATERIAL;
			map.SetText( target.HexX, target.HexY, COLOR_LGRAY, ":брага переливается через край:" );
		}
	}
	/*if( item.GetProtoId() == PID_POT_ALCO ) { //лень делать, позже зафигачу
		target.CURRENT_RAW_MATERIAL += item.POT_LIQUID_LEVEL;
		target.SPIRIT_LEVEL = target.SPIRIT_LEVEL + ( item.POT_LIQUID_LEVEL * item.HB_SPIRIT_LEVEL / 100 );
		item.POT_LIQUID_LEVEL = 0;
		item.HB_SPIRIT_LEVEL = 0;
		item.HB_POLUTION_LEVEL = 0;
	}*/
	return true;
}

bool TransferToStill( Critter& cr, Item& targetItem, Item& cont ) //export to main
{
	if(!valid(cont)) { Log( "Потеря указателя на контейнер!" ); return false; 
	}
	if( cont.STATE > 0 ) { cr.Say( SAY_NETMSG, "|0xFF0000 Аппарат не готов к загрузу браги." ); return false; 
	}
	if( targetItem.GetProtoId() != PID_HOMEBREW ) { cr.Say( SAY_NETMSG, "|0xFF0000 Вам кажется, что из этого спирт не выделить." ); return false; 
	}
	Map@ map = cr.GetMap();
	uint transferAmount = cr.ItemTransferCount();
	uint16 targetItemPid = targetItem.GetProtoId();
	if( Homebrew.find( targetItemPid ) != -1 ) {
		cr.AddItem( PID_BOTTLE_GLASS, transferAmount );
		cont.CURRENT_RAW_MATERIAL = cont.CURRENT_RAW_MATERIAL + ( ( targetItem.Proto.Weight - 150 ) * transferAmount );
		map.PlaySound( "homebrew_pouring.ogg", cr.HexX, cr.HexY, 5 );
		_SubItem( targetItem, 1 );
		if( cont.CURRENT_RAW_MATERIAL > MAX_RAW_MATERIAL ) {
			cont.CURRENT_RAW_MATERIAL = MAX_RAW_MATERIAL;
			cr.Say( SAY_NETMSG, "|0xFFFF00 Похоже, что емкость заполнена под крышку." );
			map.SetText( cont.HexX, cont.HexY, COLOR_LGRAY, ":брага переливается через край:" );
		}
	}
	cr.ShowContainer( null, cont, TRANSFER_HEX_CONT_UP );
	return true;
}

uint e_Explode( uint[]@ values )
{
	uint itemId = values[0];
	Item@ target = GetItem( itemId );
	if( valid( target ) )    
	{
		uint16 hexX=0, hexY=0;
		Map @map = target.GetMapPosition( hexX, hexY );
		ExplodeEx( map, hexX, hexY, PID_EXPLODE_ROCKET, 2, Random( 50, 100 ), DAMAGE_EXPLODE, 2, 0 );
		map.AddItem( hexX, hexY, Ashes[ Random( 0, Ashes.length() - 1 ) ], 1 );
		Item@ fireFX = map.AddItem( hexX, hexY, PID_SMOKE, 1 );
		uint[] values = {fireFX.Id};
		fireFX.EVENT = CreateTimeEvent( AFTER( REAL_SECOND( 2 ) ),"e_fireFX", values, true );
		uint randomDebree = Random( 2,5 );
		for( uint i = 0; i < randomDebree; i++ )
		{
			uint16 hx=0, hy=0;
			hx = target.HexX; hy = target.HexY;
			map.MoveHexByDir( hx, hy, Random( 1, 6 ), Random( 1, 3) );
			if( map.IsHexPassed( hx, hy ) )
			{
				map.AddItem( hx, hy, wreckage[ Random( 0, wreckage.length() -1 ) ] , 1 );
			}
		}
	}
	EraseTimeEvent( target.EVENT );
	DeleteItem( target );
	return 0;
}

uint e_fireFX( uint[]@ values )
{
	uint itemId = values[0];
	Item@ e_fireFX = GetItem( itemId );
	if( valid( e_fireFX ) )  
	{
		DeleteItem( e_fireFX );
	}
return 0;
}

bool AddIngrigient( Critter& cr )
{
	Map@ map = cr.GetMap();		
	Item@ target = map.GetItem(cr.StatBase[ST_VAR7]);
	if(!valid(target)) 
	{ 
		Log("Потеря указателя на предмет!"); 
		return false; 
	}
	cr.ParamBase[ ST_LAST_CONT_ID ] = target.Id;
	cr.ShowContainer( null, target, TRANSFER_HEX_CONT_UP );
	return true;
}

//========== TECHNICAL_ANIMATION_STATE_CHANGER ===============//
void setAnimState( Item& target )
{
	if( target.STATE == 1 ) {	
		UNSETFLAG( target.Flags, ITEM_SHOW_ANIM_EXT );
		SETFLAG( target.Flags, ITEM_LIGHT );
		SETFLAG( target.Flags, ITEM_CAN_USE );
		UNSETFLAG( target.Flags, ITEM_CAN_PICKUP );
	} else {
		SETFLAG( target.Flags, ITEM_SHOW_ANIM_EXT );
		UNSETFLAG( target.Flags, ITEM_LIGHT );
	}
	target.Update();
}

//========== ACTION_MENU_FOR_UNIGNITED_STILL===============//
bool ShowMenuStill( Critter& cr, Item& target ) //exported
{
	Map@ map = cr.GetMap();
    if( !valid( map ) ) { return false;	}
	cr.ShowScreen( SCREEN_DIALOGBOX, 4, "answer_still" );
	cr.Say( SAY_DIALOGBOX_TEXT, MenuInfoStill( cr, target ) );
	cr.Say( SAY_DIALOGBOX_BUTTON( 0 ), Centering( "Добавить брагу" ) );
	cr.Say( SAY_DIALOGBOX_BUTTON( 1 ), Centering( "Разжечь огонь" ) );
	cr.Say( SAY_DIALOGBOX_BUTTON( 2 ), Centering( "Подкинуть горючее" ) );
	cr.Say( SAY_DIALOGBOX_BUTTON( 3 ), Centering( "Открепить аппарат" ) );
	cr.Say( SAY_DIALOGBOX_BUTTON( 4 ), Centering( "Ничего не делать" ) );

	cr.StatBase[ST_VAR7] = target.Id;
	return true;	
}

void answer_still( Critter& cr, uint answerI, string& answerS )
{
	if( !StillActions( cr, answerI ) ) { cr.Say( SAY_NETMSG, "|0xFF0000 Из этого ничего не вышло." ); 
	}
}

bool StillActions( Critter& cr, uint answer )
{
	switch( answer )
	{
		case( 0 ): return AddIngrigient( cr );
		case( 1 ): return TryIgnite( cr );
		case( 2 ): return TryFeedTheFire( cr );
		case( 3 ): return TryLockInPlace( cr );
		case( 4 ): return false;
	}
	return false;
}

bool TryLockInPlace( Critter& cr )
{
	Map@ map = cr.GetMap();
    if( !valid( map ) ) { return false; }	
	Item@ targetItem = map.GetItem(cr.StatBase[ST_VAR7]);
	if( !valid( targetItem ) ) { return false; }
	LockInPlace( cr, targetItem );
	return true;
}

bool TryIgnite( Critter& cr )
{
	Map@ map = cr.GetMap();
    if( !valid( map ) ) { return false; }		
	
	Item@ targetItem = map.GetItem(cr.StatBase[ST_VAR7]);
	if( !valid( targetItem ) ) { return false; }
	
	Item@ itemLighter = cr.GetItem( PID_LIGHTER, -1 );
	Item@ itemFlint = cr.GetItem( PID_FLINT, -1 );
	if( valid(itemLighter) ) { 
		Item@ item = itemLighter;
		IgniteStill( cr, item, targetItem );
	} else if( valid(itemFlint) ) { 
		Item@ item = itemFlint;
		IgniteStill( cr, item, targetItem );
	} else {
		cr.Say( SAY_NETMSG, "|0xFFFF00 Вам нечем разжечь огонь." );
		ShowMenuStill( cr, targetItem );
	}
	return true;
}

bool TryFeedTheFire( Critter& cr )
{
	Map@ map = cr.GetMap();
    if( !valid( map ) ) { return false; }		
	Item@ targetItem = map.GetItem(cr.StatBase[ST_VAR7]);
	if( !valid( targetItem ) ) { return false; }
	
	Item@ item = null;
	for( uint i = 0, j = 9; i < j; i++)
	{
		@item = @cr.GetItem( FireFuel[i], -1 );
		if( valid ( item ) )
        {
			break;
		}
	}
	if( valid( item ) ) { FeedTheFire(cr, item, targetItem); }
	else { cr.Say( SAY_NETMSG, "|0xFF0000 У Вас нет подходящего топлива." ); }
	
	ShowMenuStill( cr, targetItem );
	return true;
}

string MenuInfoStill( Critter& cr, Item& target )
{
	string TXT = "";
	string state = ( target.STATE == STATE_PREPARE ? "Аппарат не работает." : target.STATE == STATE_FINISH ? "Работа аппарата завершена." : "Аппарат работает, заслонка: " );
	string damper = ( target.STATE == STATE_WORKING_0 ? "Закрыта." : target.STATE == STATE_WORKING_25 ? "Открыта на четверть." : target.STATE == STATE_WORKING_50 ? "Открыта на половину."
					: target.STATE == STATE_WORKING_75 ? "Открыта на три четверти." : "Полностью открыта." );
	string occupancy_level = ( target.CURRENT_FUEL * 100 / MAX_FUEL );
	float temprature = target.CURRENT_TEMPRATURE;
	float pressure = target.CURRENT_PRESSURE / 100.0;
	float  raw_material = target.CURRENT_RAW_MATERIAL / 1000.0;
	float max_raw_material = MAX_RAW_MATERIAL / 1000.0;
	TXT += state;
	if( target.STATE != STATE_PREPARE && target.STATE != STATE_FINISH )
	{
		TXT += "\n" +damper;
		TXT += "\n" "Температура: " + temprature + " градусов.";
		TXT += "\n" "Давление: " + pressure + " бар.";
	}
	TXT += "\nАппарат заполнен брагой на " + raw_material + " из " + max_raw_material + " литров.";
	TXT += "\n" "Аппарат заполнен горючим на " + occupancy_level + " %";
	return TXT;
}
