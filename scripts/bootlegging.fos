// Author: Anuri

#include "_utils.fos"
#include "FLAMMABLE_H.fos"
#include "_ltp.fos"

import void ExplodeEx( Map& map, uint16 hexX, uint16 hexY, uint16 effectPid, uint effectRadius, uint damage, uint damageType, uint damageRadius, uint ownerId )  from "explode";
import void InjureCritter( Critter& cr, uint dmg, uint dmgType, uint8 dir, int attackerId ) from "combat";
import bool LockInPlace( Critter& cr, Item& targetItem ) from "main";
import bool PickItem( Critter& cr, Item& targetItem ) from "main";
import bool FireUp( Item& item, uint pid, int strength ) from "firestarter";
import bool spawnFire( Map@ map, int x, int y ) from "firestarter";

const uint PIC_STILL_ANIM_ON = GetStrHash( "art\\items\\misc\\Still\\still_s_working.fofrm" );

#define STATE								Val0 	// Статус 0 - потух, 1 - заслонка 0%, 2 - заслонка 25%, 3 - заслонка 50%, 4 - заслонка 75%, 5 - заслонка 100%, 6 - работа завершена
#define SPIRIT_LEVEL						Val1 	// Уроверь спирта в браге
#define CURRENT_FUEL						Val2 	// Текущий заряд топлива
#define EVENT 								Val3 	// Для записи тайм-ивента работы аппарата
#define CURRENT_RAW_MATERIAL				Val4	// Текущий загруз браги
#define CURRENT_TEMPRATURE					Val5	// Текущая температура
#define	CURRENT_PRESSURE					Val6	// Текущее давление
#define CURRENT_PRODUCT						Val7	// Текущий объем спирта
#define IMPURITIES							Val8	// Уровень загрязнения аппарата
#define STORED_HEAT							Val9	// Запасенное тепло в системе

//Homebrew States
#define REMAINING_USES						Val0 	// Кол-во оставшихся использований в бутылке браги
#define POT_LIQUID_LEVEL					Val4 	// кол-во жидкостей в кувшине браги
#define POLUTION_LEVEL						Val7 	// кол-во загрязнения в браге
#define HB_SPIRIT_LEVEL						Val9 	// Градус спирта в браге

#define MAX_FUEL					 ( 10000.0f )	// Максимальный загруз топлива
#define MAX_RAW_MATERIAL			 ( 15000.0f )	// Максимальный загруз браги
#define MAX_TEMPRATURE				   ( 575.0f )	// Максимальная температура до возгорания к
#define	MAX_PRESSURE				  ( 4000.0f )	// Максимальное давление до взрыва
#define MAX_PRODUCT					 ( 10000.0f )	// Максимальный выход

#define FIRE_BURNING_TIME	  REAL_SECOND( 1.0f ) 	// Время тика горения огня
#define FUEL_BURN_AMOUNT				( 45.0f )	// Кол-во сжигаемого топлива

//Thermodynamics - export to separate module later
#define THERM_HECHFS 				  ( 4650.0f ) 	// Вт/(м2*К) - коэффициент теплоотдачи от горячего флюида к стенке // heat exchange coefficient of hot fluid to surface
#define THERM_HECSCF					 ( 9.6f ) 	// 9,6, Вт/(м2*К) - коэффициент теплоотдачи стенки к холодному флюиду // heat exchange coefficient of surface to cold fluid
#define	THERM_STCC						( 52.5f ) 	// 52.5, Вт/(м*К) - коэффициент теплопроводности стенки // surface thermal conductivity coefficient
#define	THERM_STILL_D_INNER				 ( 0.3f ) 	// d1, м - внутренний диаметр цилиндра.
#define	THERM_STILL_D_OUTER				( 0.34f )	// d2, м - наружный диаметр цилиндра. 
#define	THERM_STILL_HIGHT				 ( 1.0f )	// высота цилиндра. 
#define L_RESIST 				  ( 100 * 0.31f )	// Линейное термическое сопротивление цилиндрической стенки
#define ENVIROMENT_TEMPRATURE_K 	   ( 295.0f )   // Tf2 = 295, К - температура холодного флюида. Окружающей среды. // cold fluid temprature
#define THERM_WATER_TSP 		  	  ( 4.1806f )   // с = 4,1806, кДж/кг К - теплоемкость воды // water thermal storage property

#define ALCOHOL_GAIN					( 10.0f )	// Прирост спирта за один "тик" таймивента, гр
#define RAW_MATERIAL_LOSS 				( 40.0f )   // Скорость испарения жидкости
#define BOILING_MULTIPLIER				 ( 1.0f )	// Мультипликатор давления при достижении температуры кипения

//Still state
#define STATE_PREPARE 						( 0 )
#define STATE_WORKING_0 				 	( 1 )
#define STATE_WORKING_25 					( 2 )
#define STATE_WORKING_50 					( 3 )
#define STATE_WORKING_75 					( 4 )
#define STATE_WORKING_100 					( 5 )
#define STATE_FINISH    					( 6 )



bool IsStill(Item& still) //export
{
	return Stills.find(still.GetProtoId()) != -1;
}

// Использование предмета на аппарате
// Вернуть false если target - это не аппарат, иначе true
bool UseItemOnStill( Critter& cr, Item@ item, Item@ still ) //export
{
	if( still is null || !IsStill(still) ) {
		return false;
	}
    Map@ map = cr.GetMap();
 	if( map is null || item is null ) {
		return true;
	}
	
	if( hasItems( cr, Igniters ) ) {
		
		IgniteStill( cr, item, still );
		
	} else if( hasItems( cr, Homebrew ) ) {
		
		AddHomebrew( cr, item, still );
		
	} else if( hasItems( cr, FireFuel ) ) {
		
		FeedTheFire( cr, map, item, still );
		
	}
	return true;
}

bool HasFuel(Item& still) {
	return still.CURRENT_FUEL > 0;
}

bool IgniteStill( Critter& cr, Item& item, Item& target )
{	
	if( !HasFuel(target) )
	{
		cr.Say( SAY_NETMSG, "|0xFFFF00 Тут нечего разжигать, найдите подходящее топливо." );
		return false;
	}
	if( target.EVENT == 0 )
	{
		if( item.GetProtoId() == PID_FLINT && Random( 1, 300 ) > cr.Skill[SK_OUTDOORSMAN] )
		{
			_SubItem( item, 1 );
			cr.Say( SAY_NETMSG, "|0xFFFF00 Вы сточили поджиг." );
		}
		target.STATE = STATE_WORKING_100;
		_CritAnimateUse( cr );
		cr.Say( SAY_EMOTE, "Разжигает огонь" );
		target.PicMap = PIC_STILL_ANIM_ON;
		setAnimState( target );
		uint[] values = { target.Id };
		target.STORED_HEAT = FloatToBits( 1 );
		target.CURRENT_PRESSURE = FloatToBits( 1 );
		target.EVENT = CreateTimeEvent( AFTER( REAL_SECOND( 0 ) ), "e_StillBurn", values, true );
	}
	return true;
}

float Mass( Item& target )
{
    float result = 0.09f; // масса воздуха в пустом баке на 15л // air mass in empty still
    if( target.CURRENT_RAW_MATERIAL > 0 ) {
        result = target.CURRENT_RAW_MATERIAL / 1000.0f;
    }
    return result;
}

float last_temp = 0;

uint e_StillBurn( uint[]@ values )
{
	uint itemId = values[0];
	Item@ still = GetItem( itemId );
	
	float boiling_Pressure_Mod = 1.0f;
	
	if( valid( still ) ) {
		float System_heat = FloatFromBits( still.STORED_HEAT );
		float M = Mass(still);
		float T1 = FloatFromBits( still.CURRENT_TEMPRATURE );

		if( still.STATE > STATE_PREPARE && System_heat >= 0.5f ) {
			
			uint16 hexX = 0, hexY = 0;
			Map@ map = still.GetMapPosition( hexX, hexY );
			map.PlaySound( "CHEMICAL.ACM", still.HexX, still.HexY, 5 );

			//Valve level effects burning time
			float valve_level = 0.0f;
			switch( still.STATE ) {
				case( STATE_WORKING_0 ):
					valve_level = 0.0f;
					break;
				case( STATE_WORKING_25 ):
					valve_level = 0.25f;
					break;
				case( STATE_WORKING_50 ):
					valve_level = 0.50f;
					break;
				case( STATE_WORKING_75 ):
					valve_level = 0.75f;
					break;
				case( STATE_WORKING_100 ):
					valve_level = 1.0f;
					break;
			}
			//RL_Thermodynamics_start_here MAX_RAW_MATERIAL

			float Q_burning = FUEL_BURN_AMOUNT * valve_level; //const 45
			
			if( still.CURRENT_FUEL <= 0 ) {
				Q_burning = 0;
			}
			
			System_heat += Q_burning;
			
			float TSP = ( THERM_WATER_TSP * M );
			
			float HOTTNESS = ( System_heat / TSP ) + ENVIROMENT_TEMPRATURE_K;
	
			float Q_loss = ( HOTTNESS / L_RESIST ) * 3.14f * THERM_STILL_HIGHT;
			
			System_heat -= Q_loss;
			
			still.STORED_HEAT = FloatToBits( System_heat );
			
			float T2 = ( System_heat / TSP ) + ENVIROMENT_TEMPRATURE_K;
			
			still.CURRENT_TEMPRATURE = FloatToBits( T2 );
			
			if( FloatFromBits( still.CURRENT_PRESSURE ) >= MAX_PRESSURE ) {
				CreateTimeEvent( AFTER( REAL_SECOND( Random( 5, 20 ) ) ), "e_Explode", values, true );
			}

			if( FloatFromBits( still.CURRENT_TEMPRATURE ) >= MAX_TEMPRATURE ) {
				spawnFire( map, still.HexX, still.HexY );
				GenerateFire( map, still.HexX, still.HexY, 1 );
			}
			
			float Sys_ST = FloatFromBits( still.STORED_HEAT );
			float Cur_temp = FloatFromBits( still.CURRENT_TEMPRATURE ) - 273.15;
			
			Log( "TSP: "+ TSP + ", Горение: " + Q_burning + ", Потери: " + Q_loss + ", Накопл Тепло: " + Sys_ST + ", Т-текущая: " + Cur_temp + " dT: " + ( Cur_temp - last_temp ) );
			last_temp = Cur_temp;
			
			float CurrentTemp = FloatFromBits( still.CURRENT_TEMPRATURE );
			if(  CurrentTemp >= Boiling_Temperature_Calc( still ) ) {
				Item@ steamFX = map.AddItem( still.HexX, still.HexY, PID_STILL_STEAM, 1 );
				uint[] values = { steamFX.Id };
				steamFX.EVENT = CreateTimeEvent( AFTER( REAL_SECOND( 1 ) ), "e_steamFX", values, true );
				
				if( still.CURRENT_RAW_MATERIAL > 0.0f && still.SPIRIT_LEVEL > 0.0f ) {
					
					still.CURRENT_RAW_MATERIAL -= RAW_MATERIAL_LOSS;
					still.SPIRIT_LEVEL -= ALCOHOL_GAIN;
					
					still.CURRENT_PRODUCT += ALCOHOL_GAIN;					
				}
			}
			
			if( still.CURRENT_RAW_MATERIAL <= 0.0f ) {
				still.CURRENT_RAW_MATERIAL = 0.0f;
			}
			
			if( still.SPIRIT_LEVEL <= 0.0f ) {
				still.SPIRIT_LEVEL = 0.0f;
			}
			
			return FIRE_BURNING_TIME;
		}
		
		still.STATE = STATE_PREPARE; // заменить на STATE_FINISH как только будет выделение спирта
		ProtoItem@ proto = GetProtoItem( PID_STILL_S );
		still.PicMap = proto.PicMap;
		setAnimState( still );
		still.EVENT = 0;
		still.CURRENT_TEMPRATURE = 0;
		still.STORED_HEAT = 0;
		
		uint16 hexX=0, hexY=0;
		Map@ map = still.GetMapPosition( hexX, hexY );
		Item@ fireFX = map.AddItem( still.HexX, still.HexY, PID_STEAM, 1 );
		uint[] values = { fireFX.Id };
		fireFX.EVENT = CreateTimeEvent( AFTER( REAL_SECOND( 2 ) ), "e_fireFX", values, true );
		EraseTimeEvent( still.EVENT );
	}
	return 0;
}

uint Boiling_Temperature_Calc( Item& still ) 
{
	float minAlcoholPercentage = 0.0f;					//Минимально возможный процент спирта в рабочем теле
	float minBoilingTemperature = 273.15f + 100.0f;		//Температура кипения рабочего тела при минимальном содержани спирта
	
	float maxAlcoholPercentage = 20.0f;					//Максимальный процент спирта в браге
	float maxBoilingTemperature = 273.15f + 80.0f;		//Температура кипения рабочего тела при заправке брагой с максимальной крепостью
	
	float currentAlcoholPercentage = still.CURRENT_RAW_MATERIAL != 0 ? ( still.SPIRIT_LEVEL / still.CURRENT_RAW_MATERIAL ) : 0;
	float targetBoilingTemperature;
	
	float borderAlcoholBoilingTemperature = 273.15f + 78.37f;
	
	targetBoilingTemperature = minBoilingTemperature + (( maxBoilingTemperature - minBoilingTemperature ) / ( maxAlcoholPercentage - minAlcoholPercentage )) * ( currentAlcoholPercentage - minAlcoholPercentage );
	
	//Если спирта нет - это просто вода которая кипит при 100 градусах
	if( currentAlcoholPercentage == 0.0f ) 
	{
		targetBoilingTemperature = minBoilingTemperature;
	}
	
	//Температура кипения не может опуститься ниже, сколько спирта не лей
	if( targetBoilingTemperature < borderAlcoholBoilingTemperature ) 
	{
		targetBoilingTemperature = borderAlcoholBoilingTemperature;
	}
	
	float tempForLog = targetBoilingTemperature - 273.15f;
	Log( "Температура кипения: " + tempForLog + " С" );
	
	return targetBoilingTemperature;
}

void GenerateFire( Map@ map, int x, int y, int r ) //exported
{
	if( !valid( map ) ) return;
	
	map.SetText( x, y, COLOR_SAND, "|0xFF828a96 :треск огня:" );
	Item@[] heated;
	map.GetItems( x, y, heated );
	for( uint i = 0; i < heated.length(); i++ )
	{	
		if( WildFires.find( heated[i].GetProtoId() ) != -1 )
			continue;
		FireUp( heated[i], WildFires[ Random( 0, WildFires.length() - 1 ) ], 1 );
	}
	spawnFire( map, x, y );
	for( int k = 1; k <= r; k++ )
	{
		for( uint i = 0; i < 6; i++ ) 
		{
			uint16 hx = x + Random( -k, k ), hy = y + Random( -k, k );
			spawnFire( map, hx, hy );
		}
	}
}

bool FeedTheFire( Critter& cr, Map& map, Item& item, Item& target )
{
	if( target.CURRENT_FUEL == MAX_FUEL)
	{	
		cr.Say( SAY_NETMSG, "|0xFFFF00 Горючее уже некуда подкладывать, дайте ему прогореть!" );
		return false;
	}
	
	_SubItem( item, 1 );
	_CritAnimateUse(cr);
	if( item.GetProtoId() == PID_COAL )
	{
		target.CURRENT_FUEL = MIN(target.CURRENT_FUEL + 5400, MAX_FUEL);
		cr.Say( SAY_EMOTE, "Подкладывает уголь" );
		map.PlaySound( "ROCK.ACM", target.HexX, target.HexY, 3 );
	}
	else
	{	
		target.CURRENT_FUEL = MIN(target.CURRENT_FUEL + 1800, MAX_FUEL);
		cr.Say( SAY_EMOTE, "Подкладывает топливо" );
		map.PlaySound( "BRDSWELL.ACM", target.HexX, target.HexY, 3 );
	}

	int occupancy_rate = ( target.CURRENT_FUEL * 100 / MAX_FUEL );
	cr.Say( SAY_NETMSG, "|0xFFFF00 Аппарат заполнен горючими материалами на " +occupancy_rate+ " %" );
	
	return true;
}

bool AddHomebrew( Critter& cr, Item& homebrew, Item& still )
{
	Map@ map = cr.GetMap();
    if( !valid( map ) ) { return false;
	}
	
	map.PlaySound( "homebrew_pouring.ogg", cr.HexX, cr.HexY, 5 );
	
	if( homebrew.GetProtoId() == PID_HOMEBREW ) {
		
		still.CURRENT_RAW_MATERIAL += 500;
		still.SPIRIT_LEVEL += 500 * homebrew.SPIRIT_LEVEL / 100;
		still.IMPURITIES += homebrew.POLUTION_LEVEL;
		
	} else if( homebrew.GetProtoId() == PID_HOMEBREW_PRT ) {
		
		still.CURRENT_RAW_MATERIAL += homebrew.REMAINING_USES * 100;
		still.SPIRIT_LEVEL += homebrew.REMAINING_USES * 100 * homebrew.HB_SPIRIT_LEVEL / 100;
		still.IMPURITIES += homebrew.REMAINING_USES * 100 * homebrew.POLUTION_LEVEL / 100;
	}
		
	_SubItem( homebrew, 1 );
	cr.AddItem( PID_BOTTLE_GLASS, 1 );

	if( still.CURRENT_RAW_MATERIAL > MAX_RAW_MATERIAL ) {
		still.CURRENT_RAW_MATERIAL = MAX_RAW_MATERIAL;
		map.SetText( still.HexX, still.HexY, COLOR_LGRAY, ":брага переливается через край:" );
	}

	/*if( item.GetProtoId() == PID_POT_ALCO ) { //лень делать, позже зафигачу
		target.CURRENT_RAW_MATERIAL += item.POT_LIQUID_LEVEL;
		target.SPIRIT_LEVEL = target.SPIRIT_LEVEL + ( item.POT_LIQUID_LEVEL * item.HB_SPIRIT_LEVEL / 100 );
		item.POT_LIQUID_LEVEL = 0;
		item.HB_SPIRIT_LEVEL = 0;
		item.POLUTION_LEVEL = 0;
	}*/
	return true;
}

bool TransferToStill( Critter& cr, Item& homebrew, Item& still ) //export to main
{
	Map@ map = cr.GetMap();
    if( !valid( map ) ) { return false;
	}
	if( !valid( still ) ) { Log( "Потеря указателя на контейнер!" ); return false; 
	}
	if( still.STATE > STATE_PREPARE ) { cr.Say( SAY_NETMSG, "|0xFF0000 Аппарат не готов к загрузу браги." ); return false; 
	}
	if( homebrew.GetProtoId() != PID_HOMEBREW && homebrew.GetProtoId() != PID_HOMEBREW_PRT	) { cr.Say( SAY_NETMSG, "|0xFF0000 Вам кажется, что из этого спирт не выделить." ); return false; 
	}
	
	map.PlaySound( "homebrew_pouring.ogg", cr.HexX, cr.HexY, 5 );
	
	if( homebrew.GetProtoId() == PID_HOMEBREW ) {
		
		still.CURRENT_RAW_MATERIAL += 500;
		still.SPIRIT_LEVEL += 500 * homebrew.SPIRIT_LEVEL / 100;
		still.IMPURITIES += homebrew.POLUTION_LEVEL;
		
	} else if( homebrew.GetProtoId() == PID_HOMEBREW_PRT ) {
		
		still.CURRENT_RAW_MATERIAL += homebrew.REMAINING_USES * 100;
		still.SPIRIT_LEVEL += homebrew.REMAINING_USES * 100 * homebrew.HB_SPIRIT_LEVEL / 100;
		still.IMPURITIES += homebrew.REMAINING_USES * 100 * homebrew.POLUTION_LEVEL / 100;
	}
		
	_SubItem( homebrew, 1 );
	cr.AddItem( PID_BOTTLE_GLASS, 1 );

	if( still.CURRENT_RAW_MATERIAL > MAX_RAW_MATERIAL ) {
		still.CURRENT_RAW_MATERIAL = MAX_RAW_MATERIAL;
		map.SetText( still.HexX, still.HexY, COLOR_LGRAY, ":брага переливается через край:" );
	}
	
	ShowContainer( cr, still, TRANSFER_HEX_CONT_UP );
	return true;
}

uint e_Explode( uint[]@ values )
{
	uint itemId = values[0];
	Item@ target = GetItem( itemId );
	if( valid( target ) )    
	{
		uint16 hexX=0, hexY=0;
		Map @map = target.GetMapPosition( hexX, hexY );
		ExplodeEx( map, hexX, hexY, PID_EXPLODE_ROCKET, 2, Random( 50, 100 ), DAMAGE_EXPLODE, 2, 0 );
		map.AddItem( hexX, hexY, Ashes[ Random( 0, Ashes.length() - 1 ) ], 1 );
		Item@ fireFX = map.AddItem( hexX, hexY, PID_SMOKE, 1 );
		
		uint[] values = {fireFX.Id};
		fireFX.EVENT = CreateTimeEvent( AFTER( REAL_SECOND( 2 ) ),"e_fireFX", values, true );
		uint randomDebree = Random( 2,5 );
		for( uint i = 0; i < randomDebree; i++ )
		{
			uint16 hx=0, hy=0;
			hx = target.HexX; hy = target.HexY;
			map.MoveHexByDir( hx, hy, Random( 1, 6 ), Random( 1, 3) );
			if( map.IsHexPassed( hx, hy ) )
			{
				map.AddItem( hx, hy, Wreckage[ Random( 0, Wreckage.length() -1 ) ] , 1 );
			}
		}
	}
	EraseTimeEvent( target.EVENT );
	target.EVENT = 0;
	DeleteItem( target );
	return 0;
}

uint e_fireFX( uint[]@ values )
{
	uint itemId = values[0];
	Item@ e_fireFX = GetItem( itemId );
	if( valid( e_fireFX ) )  
	{
		EraseTimeEvent( e_fireFX.EVENT );
		e_fireFX.EVENT = 0;
		DeleteItem( e_fireFX );
	}
return 0;
}

uint e_steamFX( uint[]@ values )
{
	uint itemId = values[0];
	Item@ e_steamFX = GetItem( itemId );
	if( valid( e_steamFX ) )  
	{
		if( e_steamFX.CURRENT_TEMPRATURE >= 37500 ) {
			uint16 hexX=0, hexY=0;
			Map@ map = e_steamFX.GetMapPosition( hexX, hexY );
			map.PlaySound( "still_steam.ogg", hexX, hexY, 5 );
			return FIRE_BURNING_TIME;
		}
		
		EraseTimeEvent( e_steamFX.EVENT );
		e_steamFX.EVENT = 0;
		DeleteItem( e_steamFX );
	}
return 0;
}

//========== TECHNICAL_ANIMATION_STATE_CHANGER ===============//
void setAnimState( Item& target )
{
	if( target.STATE > STATE_PREPARE ) {	
		UNSETFLAG( target.Flags, ITEM_SHOW_ANIM_EXT );
		SETFLAG( target.Flags, ITEM_LIGHT );
		SETFLAG( target.Flags, ITEM_CAN_USE );
		UNSETFLAG( target.Flags, ITEM_CAN_PICKUP );
	} else {
		SETFLAG( target.Flags, ITEM_SHOW_ANIM_EXT );
		UNSETFLAG( target.Flags, ITEM_LIGHT );
	}
	target.Update();
}

//=============== STILL STATE DISCRIPTION ====================//

string@ GenerateDescription(Item& still) {
	string@ info;
	bool is_working = false;
	switch( still.STATE ) {
		case STATE_PREPARE:
			@info = "Аппарат не работает.";
			break;
		case STATE_FINISH:
			@info = "Работа аппарата завершена.";
			break;
		default:
			@info = "Аппарат работает, заслонка: ";
			is_working = true;
	}
	if( is_working ) {
		switch( still.STATE ) {
			case STATE_WORKING_0:
				info += "Закрыта.";
				break;
			case STATE_WORKING_25:
				info += "Открыта на четверть.";
				break;
			case STATE_WORKING_50:
				info += "Открыта на половину.";
				break;
			case STATE_WORKING_75:
				info += "Открыта на три четверти.";
				break;
			case STATE_WORKING_100:
				info += "Полностью открыта.";
				break;
		}
		
		float temprature = FloatFromBits( still.CURRENT_TEMPRATURE ) - 273.15f;
		info += "\n" "Температура: " + temprature + " градусов C.";

		float pressure = FloatFromBits( still.CURRENT_PRESSURE );
		info += "\n" "Давление: " + pressure + " бар.";
	}

	float raw_material = still.CURRENT_RAW_MATERIAL / 1000.0f;
	float max_raw_material = MAX_RAW_MATERIAL / 1000.0f;
	info += "\nСырье: " + raw_material + " из " + max_raw_material + " литров.";

	string occupancy_level = ( still.CURRENT_FUEL * 100.0f / MAX_FUEL );
	info += "\nАппарат заполнен горючим на " + occupancy_level + " %";

	float product = still.CURRENT_PRODUCT / 1000.0f;
	info += "\nВыделено " + product + " литров спирта.";

	return info;
}

//=============== MAIN MENU ====================//

void ShowMenuStill( Critter& cr, Item& still ) //exported
{
	Map@ map = cr.GetMap();
    if( still is null || map is null ) {
        return;
    }

    iMenuHandler@ handler = MenuStill(still, map);
    iDialogBox@ menu = OpenMenu(cr, "Дестилятор", handler);
}

class MenuStill: CenteredMenuHandler {
	uint m_still_id;
	uint m_map_id;
	int m_last_state;
	
	MenuStill(Item& still, Map& map) {
		m_still_id = still.Id;
		m_map_id = map.Id;
	}
	bool MenuUpdate( Critter& cr, iDialogBox& menu ) {
		Item@ still = GetItem(m_still_id);
		Map@ map = GetMap(m_map_id);
		if(still is null || map is null) {
			return false;
		}

		bool locked_in_place = !FLAG( still.Flags, ITEM_CAN_PICKUP );

		// Все действия которые можно выполнить с закреплённым аппаратом
		if( locked_in_place ) {
			if ( still.STATE == STATE_PREPARE ) { // Который не начал работу
				if( menu.Button("Демонтировать") ) {
					LockInPlace( cr, still );
					return true;
				}
				if( menu.Button( "Добавить брагу" ) ) {
					ShowContainer( cr, still, TRANSFER_HEX_CONT_UP );
					return false; // чтобы не перебивать окно контейнера
				}
				if( HasFuel(still) && menu.Button("Разжечь огонь") ) {
					Item@ lighter = cr.GetItem( PID_LIGHTER, -1 );
					if( lighter is null ) {
						@lighter = cr.GetItem( PID_FLINT, -1 );
					}
					if( lighter is null ) {
						cr.Say( SAY_NETMSG, "|0xFFFF00 Вам нечем разжечь огонь." );
					} else {
						IgniteStill( cr, lighter, still );
					}
					return true;
				}
			} else if(still.STATE < STATE_FINISH ) { // Который начал, но не закончил работу
				if ( menu.Button( "Закрыть заслонку" ) ) {
					still.STATE = STATE_WORKING_0;
					return true;
				}
				if ( menu.Button( "На четверть" ) ) {
					still.STATE = STATE_WORKING_25;
					return true;
				}
				if ( menu.Button( "На половину" ) ) {
					still.STATE = STATE_WORKING_50;
					return true;
				}
				if ( menu.Button( "На две трети" ) ) {
					still.STATE = STATE_WORKING_75;
					return true;
				}
				if ( menu.Button( "Открыть полностью" ) ) {
					still.STATE = STATE_WORKING_100;
					return true;
				}
			}

			if ( still.STATE < STATE_FINISH ) { // Который не начал работу или работает
				if(menu.Button("Подкинуть горючее")) {
					Item@ fuel = FindStillFuel(cr);
					if( valid( fuel ) ) {
						FeedTheFire(cr, map, fuel, still); 
					} else {
						cr.Say( SAY_NETMSG, "|0xFF0000 У Вас нет подходящего топлива." ); 
					}				
					return true;
				}
			}
		} else {
			if( menu.Button("Установить") ) {
				LockInPlace( cr, still );
				return true;
			}
			if( menu.Button("Поднять") ) {
				PickItem( cr, still );
				return false; // предмет уже не на земле
			}
		}
		if( menu.Button("Ничего не делать") ) {
			return false;
		}
		return true;
	}

	string@ Description(Critter& cr) {
		Item@ still = GetItem(m_still_id);
		m_last_state = still.STATE;
		return GenerateDescription(still);
	}

	bool ShouldRedraw(Critter& cr) {
		Item@ still = GetItem(m_still_id);
		return still is null || IsStillWorking(still) || still.STATE != m_last_state;
    }
}

bool IsStillWorking(Item& still) {
	return still.STATE > STATE_PREPARE && still.STATE < STATE_FINISH;
}

Item@ FindStillFuel(Critter& cr) {
	Item@ fuel = null;
	for( uint i = 0, j = 9; i < j; i++)
	{
		@fuel = @cr.GetItem( FireFuel[i], -1 );
		if( fuel !is null ) {
			break;
		}
	}
	return fuel;
}