#include "_utils.fos"
#include "_ltp.fos"
#include "STAT_MODS_H.fos"

import void Cleaning( Critter& player, uint soap_pid, int water_source ) from "main";
import void AffectPoison( Critter& cr, int value ) from "poison";
import void AffectRadiation( Critter& cr, int value ) from "radiation";
import void AskCooking( Critter& cr ) from "cooking";
import void InjureCritter( Critter& cr, uint dmg, uint dmgType, uint8 dir, int attackerId ) from "combat"; // Export
import void ProccessDrink( Critter& cr, Critter& target, Item& item ) from "food";

int[][] groups = { {}, { PID_POWER_GEN }, { PID_FIREBARREL }, { PID_FIREPLACE2, PID_FIREPLACE_OFF, 286, PID_WILDFIRE_1 }, { PID_WELL_1, PID_WELL_2, PID_WELL_3, PID_NEW_WELL }, { PID_CACTUS_1, PID_CACTUS_2 } };
string[] group_descriptions = { "ERROR", "генераторе", "бочке", "костре", "колодце", "кактусе"};
#define TYPE_NONE        ( 0 )
#define TYPE_POWERGEN    ( 1 )
#define TYPE_FIREBARREL  ( 2 )
#define TYPE_FIREPIT     ( 3 )
#define TYPE_WELL 		 ( 4 )
#define TYPE_CACTUS 	 ( 5 )

int FindGroup(Item& item) {
    int PID = item.GetProtoId();
	for( uint i = 0, iEnd = groups.length(); i < iEnd; i++ )
		if( groups[i].find(PID) != -1 ) return i;
	return TYPE_NONE;
}

#define STATE 									Val0
#define MAX 									Val1
#define REMAINING_CHARGE					 	Val2
#define EVENT 									Val3
#define BREAK									Val4
#define TYPE 									Val5

#define WATER_FILL_TIME __FullSecond + REAL_MINUTE( Random( 15, 45 ) )

#define REMAINING_USES							Val0 	// Кол-во оставшихся использований
#define EXTRA_WEIGHT							Val2	// Дополнительный вес жидкости

void _InitItem( Item& item, bool firstTime )
{
	//TODO: Разобраться, почему при перезапуске сервера слетает поведение предметов, если раскомментить строку ниже:
	//if( !firstTime ) return;
	
	int key = FindGroup(item);
    if( key > TYPE_NONE ) 
	{
        if( key != TYPE_FIREPIT )
			ChangeFrame( item, 0 );

        item.STATE = 0;
		if( key == TYPE_WELL || key == TYPE_CACTUS ) {
			item.MAX = ( key == TYPE_CACTUS ? Random(10,15) : Random(25,75) );
			item.REMAINING_CHARGE = item.MAX;
		}
		else 
		{
			item.MAX = 10;
			item.REMAINING_CHARGE = 0;
		}
		item.EVENT = 0;
		if(key == TYPE_WELL) {
			uint[] values = { item.Id };
			item.EVENT = CreateTimeEvent( __FullSecond + WATER_FILL_TIME, "e_WellCharge", values, true );
		}
		item.BREAK = 0;
		item.TYPE = key;
		item.SetEvent( ITEM_EVENT_SKILL, "e_Skill" );
        item.SetEvent( ITEM_EVENT_USE_ON_ME, key == TYPE_CACTUS ? "e_Cut" : "e_Repair" );
    }
}

bool e_Skill( Item& item, Critter& cr, int skill ) 
{
	if( item.GetProtoId() == 286 )
		return false; //Игнор дров.
	
	if(item.STATE != 0 ) {
		cr.Say(SAY_NETMSG, "Предмет требует починки!" );
		return true;
	}
	string description = group_descriptions[item.TYPE];
    switch( skill ) 
	{
		case SK_SCIENCE:
			cr.Say( SAY_NETMSG, "В " + description + " осталось " + item.REMAINING_CHARGE + "." );
			return true;
		case SKILL_PICK_ON_GROUND:
		switch(item.TYPE) {
			//case(TYPE_FIREBARREL):
			case(TYPE_FIREPIT):
				if( item.REMAINING_CHARGE > 0 ) { AskCooking( cr ); return true; }
				else { cr.Say(SAY_NETMSG, "Огонь погас, используйте древесину и зажигалку."); item.STATE = 1; }
				return true;
			//case(TYPE_CACTUS):
			case(TYPE_WELL):
				if( item.REMAINING_CHARGE > 0 ) return ShowMenuWater( cr, item );
				else
					cr.Say(SAY_NETMSG, "В " + description + " кончилась вода. Подождите часок-другой или поработайте лопатой."); 
				return true;
			default: break;
		}
    }
    return false;
}

bool ShowMenuWater(Critter& cr, Item& item) {
	if( item.REMAINING_CHARGE <= 0 ) 
	{ 
		cr.Say(SAY_NETMSG, "В колодце кончилась вода. Подождите часок-другой или поработайте лопатой."); 
		return true; 
	}
	
	cr.ShowScreen( SCREEN_DIALOGBOX, 3, "adv_items@answer_WATER" );
	cr.Say( SAY_DIALOGBOX_TEXT, "В " + group_descriptions[item.TYPE] + " осталось " + item.REMAINING_CHARGE + "." );
	cr.Say( SAY_DIALOGBOX_BUTTON( 0 ), "набрать воды" );
	cr.Say( SAY_DIALOGBOX_BUTTON( 1 ), "попить" );
	cr.Say( SAY_DIALOGBOX_BUTTON( 2 ), "помыться" );
	
	cr.StatBase[ST_VAR7] = item.Id;
	
	return true;
}

import bool checkTiredness( Critter& cr, int max, int add ) from "fix_boy";

void answer_WATER( Critter& cr, uint answerI, string& answerS )
{
	if( cr.IsBusy() || cr.IsDead() )
	{
		cr.Say( SAY_NETMSG, "Вы заняты, подождите." );
		return;
	}
	
	cr.Action( ACTION_PICK_CRITTER, 3, null );
	cr.Wait(500);
	
	Map@ map = cr.GetMap();
	if(!valid(map)) { Log("Вызов с глобала!"); return; }
	Item@ source = map.GetItem(cr.StatBase[ST_VAR7]);
	if(!valid(source)) { Log("Потеря указателя на предмет!"); return; }
		
	switch( answerI )
	{
		case(0):
		{
			start_pouring( cr, source );
			break;
		}
		case(1): 
		{
			Item@ consumedDrink = cr.AddItem( PID_GLASS_BOTTLE_DIRTY_FULL_PRT, 1 );
			consumedDrink.REMAINING_USES = 2;
			ProccessDrink( cr, cr, consumedDrink );
	
			_SubItem( consumedDrink, 1 );
			break;
		}
		case(2): Cleaning( cr, 0, -1 ); break;
	}
	if( !spendWater( cr, source, 1 ) ) return;//TODO: влияние вариативности использования на затраты воды
}

bool spendWater( Critter& cr, Item& source, int delta )
{
	if( source.REMAINING_CHARGE < delta )
		return testInfo( cr, "REMAINING_CHARGE(" + source.REMAINING_CHARGE + ") < delta(" + delta + ")" );
	
	source.REMAINING_CHARGE -= delta;

	return true;
}

bool ltp_inited = false;
void ltp_init()
{
	LTPREG( LTP_POURING, process_pouring )
	ltp_inited = true;
}

bool start_pouring( Critter& cr, Item& target )
{
	if(!ltp_inited) { 
		ltp_init();
	}
	
	Map@ map = cr.GetMap();		
	
	if( valid( target ) ) {
		
		if( target.REMAINING_CHARGE < 1 ) {
			cr.Say( SAY_NETMSG, "|0xFFFF00 Воды больше нет." );
			return false;
		}
	
		if( !hasItem( cr, PID_BOTTLE_GLASS, SLOT_HAND1 ) && !hasItem( cr, PID_GLASS_BOTTLE_DIRTY_FULL_PRT, SLOT_HAND1 ) ) { cr.Say( SAY_NETMSG, "|0xFFFF00 У вас нет подходящей тары в руках." ); return false;
		}
		
		uint hit_pause = ACTION_PAUSE_BASE - (cr.Stat[ST_AGILITY] * ACTION_PAUSE_BONUS_RATE );
		uint action_pause = CLAMP( hit_pause, ACTION_PAUSE_MIN, ACTION_PAUSE_MAX );
		map.PlaySound( "homebrew_pouring.ogg", cr.HexX, cr.HexY, 5 );
		CreateTimeEvent( AFTER( REAL_MS( 1000 ) ), "e_TiredenessTimeout", cr.Id, true);	
		
		StartProcess( cr, LTP_POURING, 0, 0, target.Id, action_pause );
		return true;
	}
	return false;
}

uint process_pouring( Critter@ cr, int& param0, int& param1, int& param2 )
{
    LTPROCESS( cr, param0, LTP_POURING )
	uint hit_pause = ACTION_PAUSE_BASE - ( cr.Stat[ST_AGILITY] * ACTION_PAUSE_BONUS_RATE );
	uint action_pause = CLAMP( hit_pause, ACTION_PAUSE_MIN, ACTION_PAUSE_MAX );
  	Item@ target = GetItem( param2 );
	
  	if( valid( target ) ) {
		
      	if( ( !hasItem( cr, PID_BOTTLE_GLASS ) && !hasItem( cr, PID_GLASS_BOTTLE_DIRTY_FULL_PRT ) ) || target.REMAINING_CHARGE < 1 ) {
			string TXT = ( !hasItem( cr, PID_BOTTLE_GLASS ) || !hasItem( cr, PID_GLASS_BOTTLE_DIRTY_FULL_PRT ) ) ? " У Вас закончилась тара." : " Вы разлили всю воду по бутылкам.";
			cr.Say( SAY_NETMSG, "|0xFFFF00" + TXT );
			return 0;
		}
		
		_CritAnimateUse(cr);
		uint autoemote = Random( 1, 10 );
		if( autoemote == 10 ) { cr.Say( SAY_EMOTE, "Наполняет бутылку" );
		}
		
		if( hasItem( cr, PID_GLASS_BOTTLE_DIRTY_FULL_PRT ) ) {
			
			Item@ waterBottlePrt = getItem( cr, PID_GLASS_BOTTLE_DIRTY_FULL_PRT );
			if( waterBottlePrt.REMAINING_USES < waterBottlePrt.Proto.Partial_Item ) {
				
				target.REMAINING_CHARGE --;
				waterBottlePrt.REMAINING_USES ++;
				waterBottlePrt.EXTRA_WEIGHT = waterBottlePrt.REMAINING_USES * 100;

				Map@ map = cr.GetMap();
				map.PlaySound( "homebrew_pouring.ogg", cr.HexX, cr.HexY, 5 );
								
				waterBottlePrt.Update();
				
			} else {
			
				Item@ waterBottle = cr.AddItem( PID_GLASS_BOTTLE_DIRTY_FULL, 1 );
				
				_SubItem( waterBottlePrt , 1 );
				
				cr.Say( SAY_NETMSG, "|0xFFFF00 Вы полностью наполнили бутылку водой" );
				
				waterBottle.Update();
			}

			CreateTimeEvent( AFTER( REAL_MS( 1000 ) ), "e_TiredenessTimeout", cr.Id, true);
			
			return action_pause;
			
		} else {
		
			Item@ bottle = cr.GetItem( PID_BOTTLE_GLASS, -1 );
			_SubItem( bottle , 1 );
		
			Item@ waterBottlePrt = cr.AddItem( PID_GLASS_BOTTLE_DIRTY_FULL_PRT, 1 );
			
			Item@ hands = cr.GetItem( 0, SLOT_HAND1 );
			if( valid( hands ) ) {
				cr.MoveItem( hands.Id, hands.GetCount(), SLOT_INV );
			}
			
			cr.MoveItem( waterBottlePrt.Id, waterBottlePrt.GetCount(), SLOT_HAND1 );
		
			target.REMAINING_CHARGE --;
			waterBottlePrt.REMAINING_USES ++;
			waterBottlePrt.EXTRA_WEIGHT = waterBottlePrt.REMAINING_USES * 100;

			Map@ map = cr.GetMap();
			map.PlaySound( "homebrew_pouring.ogg", cr.HexX, cr.HexY, 5 );
				
			waterBottlePrt.Update();
		}
		
		CreateTimeEvent( AFTER( REAL_MS( 1000 ) ), "e_TiredenessTimeout", cr.Id, true);
		
		return action_pause;
    }
	return 0;
}

uint e_TiredenessTimeout(uint[]@ values)
{
	Critter@ cr = GetCritter( values[0] ); 
	uint fatigue_per_action = ACTION_FATIGUE_BASE - ( cr.Stat[ST_ENDURANCE] * ACTION_FATIGUE_RATE );
	uint fatigue = CLAMP( fatigue_per_action, ACTION_FATIGUE_MIN, ACTION_FATIGUE_MAX);
	cr.TimeoutBase[ TO_TIREDNESS ] = __FullSecond + cr.Timeout[ TO_TIREDNESS ] + REAL_SECOND( fatigue );
	return 0;
}

/*#define CACTUS_REST_TIME __FullSecond + REAL_MINUTE( Random( 15, 45 ) )
#define CACTUS_WATERING_TIME __FullSecond + REAL_MINUTE( Random( 1, 3 ) )
int[] CactusCutting_tools = { PID_KNIFE, PID_AXE, PID_COMBAT_KNIFE, PID_THROWING_KNIFE, PID_LIL_JESUS_WEAPON, 
								PID_REVKNIFE1, PID_REVKNIFE2, PID_SHIV, PID_SWITCHBLADE, PID_WAKIZASHI_BLADE };
bool e_Cut( Item& item, Critter& cr, Item@ usedItem )
{
	if( item.REMAINING_CHARGE == 0 ) {
		cr.Say( SAY_NETMSG, "Этот кактус полностью выжат, ему потребуется около получаса на восстановление." );
		uint[] values = { item.Id };
		item.EVENT = CreateTimeEvent( __FullSecond + CACTUS_REST_TIME, "e_CactusCharge", values, true );
		return true;
	}
	if( cr.Timeout[ TO_SK_REPAIR ] > 0 && !isGM(cr) ) {
		cr.Say( SAY_NETMSG, "Вы слишком устали, дайте отдых рукам." ); return true; 
	}
	if( !valid(usedItem) || CactusCutting_tools.find(usedItem.GetProtoId()) == -1 ) {
		cr.Say( SAY_NETMSG, "Что бы извлечь из кактуса влагу, вам потребуется использовать любой инструмент из списка:" );
		for(uint i = 0, iEnd = CactusCutting_tools.length(); i < iEnd; i++)
			cr.SayMsg( SAY_NETMSG, TEXTMSG_ITEM,  CactusCutting_tools[i] * 100 );
		return true;
	}
	Item@ hand = _CritGetItemHand( cr );
	if(!valid(hand)) { cr.Say( SAY_NETMSG, "Возьмите пустую тару в руки!" ); return true; }
	int n = BottlePIDs_before.find( hand.GetProtoId() );
	if(n == -1) { cr.Say( SAY_NETMSG, "Эта тара не подходит!" ); return true; }
	_SubItem(hand, 1);
	_CritAddItem( cr, BottlePIDs_after[n], 1 );
	cr.TimeoutBase[ TO_SK_REPAIR ] = __FullSecond + (11 - cr.Stat[ ST_ENDURANCE ] ) 1 * REAL_SECOND( 30 );
	cr.AddTimeEvent( "main@cte_Tired", 1 * REAL_SECOND( 30 ), CTE_TIRED, 0 );
	cr.Say( SAY_EMOTE, "набирает воду" );
	return false;
}*/

#define WELL_BROKEN_ROPE  ( 1 )
#define WELL_BROKEN_WHEEL ( 2 )
#define WELL_BROKEN_SHAFT ( 3 )
#define FIRE_BURNING_TIME REAL_SECOND( Random( 4, 10 ) )
uint[][] Repairing_resources =  {{ PID_ROPE, PID_CRAFT_M_STEL, PID_FIREWOOD }, {PID_COAL,PID_FIREWOOD}};
uint[][] Repairing_tools =      {{ PID_MULTI_TOOL, PID_SUPER_TOOL_KIT, PID_SHOVEL }, {PID_LIGHTER}};
uint[][] Repairing_iterations = {{ 1, 2, 3 }, {0, 0}};

//import bool e_Repair( Item& item, Critter& cr, Item@ usedItem ) from "adv_items";
bool e_Repair( Item& item, Critter& cr, Item@ usedItem )
{
	if(item.STATE == 0 && !valid(usedItem)) return e_Skill( item, cr, SKILL_PICK_ON_GROUND ); 
	if( cr.Timeout[ TO_SK_REPAIR ] > 0 && !isGM(cr) ) {
		cr.Say( SAY_NETMSG, "|0xFF0000 Вы слишком устали, дайте отдых рукам." ); return true; 
	}

    switch( item.TYPE ) {
		case(TYPE_NONE):  break;
		case(TYPE_WELL): {
			
			if( !isGM(cr) && !checkTiredness( cr, 60, 60 ) )
				return true; 
			if (item.REMAINING_CHARGE >= 80){cr.Say( SAY_NETMSG, "|0xFFFF00 Вода переливается за края колодца. Вы не можете больше копать." ); return true;}//TODO: ускорять набор воды (таймивент)
			if (usedItem.GetProtoId() == PID_SHOVEL){
				item.REMAINING_CHARGE += Random( 0, 1 );
				cr.Say( SAY_EMOTE_ON_HEAD, "копает колодец" );//TODO: ускорять набор воды (таймивент)
			}
			else{
				cr.Say( SAY_NETMSG, "|0xFF0000 копайте колодец чем-то более приемлиемым, например лопатой." );//TODO: ускорять набор воды (таймивент)
			} 
			
			return true;
		}
		default: break;
    }
	return false;
}

void e_Hot(Item& item, Critter& crit, bool entered, uint8 dir) 
{
	if( entered )
	{
		if( crit.GetTimeEvents( CTE_DYSPNEA, null, null, null ) == 0 )
			crit.AddTimeEvent( "cte_Hot", 0, CTE_DYSPNEA, 0 );
	}
	else crit.EraseTimeEvents( CTE_DYSPNEA );
}

bool NeededItem( Critter& cr, uint16 protoId )
{
    cr.Say( SAY_NETMSG, "Требуется:" );
    cr.SayMsg( SAY_NETMSG, TEXTMSG_ITEM, protoId * 100 );
	return true;
}
 
void LightControl( Item& item, bool onOff, uint intensity, uint8 radius )
{
	item.SetEvent( ITEM_EVENT_WALK, onOff ? "e_Hot" : null );
    item.LightIntensity = intensity;
    item.LightColor = LightColor( onOff ? 1 : 0 );
    item.Update();
}

uint LightColor( int color )
{
    switch( color )
    {
    case 1:
        color = 9999666;
        break;                         
    default:
        color = 0;
        break;
    }
    return color;
}

void addlight( Critter& player, int param0, int param1, int param2 )
{
    Map @ map = player.GetMap();
    uint16 hexX = 0, hexY = 0;
    for( uint8 i = 240; i < 242; i++ )
    {
        if( not map.GetEntireCoords( i, 0, hexX, hexY ) )
        {
            Log( "entire num " + i + " not found(light env)" );
            return;
        }
        Log( "hexX = " + hexX + " hexY = " + hexY );
        Item@ light = map.AddItem( hexX, hexY, PID_LIGHT_ENV, 1 );
        Log( "light" + ( valid( light ) ? " " : " not ") + "valid" );
    }
}

uint e_WellCharge( uint[] @ values ) 
{
	Item @ well = GetItem( values[ 0 ] );
	if( !valid( well ) ) return 0;
	well.MAX = Random(25,75);
	well.REMAINING_CHARGE += CLAMP(Random(25,well.MAX), 0, well.MAX);
	Map@ map = GetMap( well.MapId );
	if(valid(map)) map.SetText(well.HexX,well.HexY,COLOR_GRAY,":журчание воды:");
	well.STATE = 0;
	return WATER_FILL_TIME;
}
/*uint e_CactusCharge( uint[] @ values )
{
    Item @ cactus = GetItem( values[ 0 ] );
    if( cactus.MAX >= cactus.REMAINING_CHARGE )
    {
        cactus.REMAINING_CHARGE += Random( 0, 1 ) + Random( 0, 1 ) + Random( 0, 1 );
        return CACTUS_WATERING_TIME;
    }
	cactus.EVENT = 0;
    return 0;
}*/

void RemoveItemsByPID( Map& map, uint pid )
{
	Item@[] items;
	uint count = map.GetItems( pid, items );
	for( uint i = 0; i < count; i++ )
		DeleteItem( items[i] );
}

void RemoveItemsByPID( Map& map, uint[] pids )
{
	for( uint i = 0, len = pids.length(); i < len; i++ )
		RemoveItemsByPID( map, pids[i] );
}

//~run adv_items clear 0 0 0 
/*void clear( Critter& cr, int, int, int )
{
	Map@ map = cr.GetMap();
	if(!valid(map)) return;
	
	RemoveItemsByPID( map, firables );
	RemoveItemsByPID( map, firesources );
	RemoveItemsByPID( map, ashes );
}*/

//~run adv_items run 0 0 0 
void run( Critter& cr, int, int, int )
{
	Map@ map = cr.GetMap();
	if( !valid(map) ) return;
	
	uint count;
	Item@[] fires;
	
	count = map.GetItems( cr.HexX + 1, cr.HexY + 1, fires );
	if( count == 0 )
		fires.insertLast( map.AddItem( cr.HexX + 1, cr.HexY + 1, PID_WILDFIRE_1, 1 ) );
	if( fires.length() == 1 )
		switchState( fires[0] );
	fires.resize(0);
	
	count = map.GetItems( cr.HexX - 1, cr.HexY + 1, fires );
	if( count == 0 )
		fires.insertLast( map.AddItem( cr.HexX - 1, cr.HexY + 1, PID_FIREPLACE_OFF, 1 ) );
	if( fires.length() == 1 )
		switchState( fires[0] );
	fires.resize(0);
}

//~run adv_items go id1 id2 id3
void go( Critter& cr, int id1, int id2, int id3 )
{
	int[] ids = { id1, id2, id3 };
	
	for( uint i = 0, len = ids.length(); i < len; i++ )
		switchState( ids[i] );
}

void switchState( int itemId )
{
	if( itemId == 0 ) return;
	Item@ item = GetItem( itemId );
	if( !valid( item ) ) return;
	switchState( item );
}

void switchState( Item@ item )
{
	if( !valid( item ) ) return;
	
	uint pid = item.GetProtoId();
	
	if( pid != PID_FIREPLACE_OFF && pid != PID_WILDFIRE_1 && pid != PID_FIREPLACE2 ) return;
	
	bool isFire = ( pid == PID_FIREPLACE2 || pid == PID_WILDFIRE_1 );
	
	//item.ChangeProto( isFire ? PID_FIREPLACE_OFF : PID_WILDFIRE );
	@item = @recreateWithNewProto( item, isFire ? PID_FIREPLACE_OFF : PID_WILDFIRE_1 );
	if( !isFire && valid( item ) )
		item.SetEvent( ITEM_EVENT_WALK, isFire ? "e_Hot" : null );
}

Item@ recreateWithNewProto( Item& item, uint pid )
{
	Map@ map = GetMap( item.MapId );
	if( !valid( map ) ) return null;
	
	if( item.Accessory != ACCESSORY_HEX ) return null;
	
	Item@ result = map.AddItem( item.HexX, item.HexY, pid, 1 );
	if( !valid( result ) ) null;
	
	cloneVals( item, result );
	DeleteItem( item );
	
	return result;
}

void cloneVals( Item& source, Item& target )
{
	target.Val0 = source.Val0;
	target.Val1 = source.Val1;
	target.Val2 = source.Val2;
	target.Val3 = source.Val3;
	target.Val4 = source.Val4;
	target.Val5 = source.Val5;
	target.Val6 = source.Val6;
	target.Val7 = source.Val7;
	target.Val8 = source.Val8;
	target.Val9 = source.Val9;
}