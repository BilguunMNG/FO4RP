#include "_utils.fos"

import void Cleaning( Critter& player, uint soap_pid, int water_source ) from "main";
import void AffectPoison( Critter& cr, int value ) from "poison";
import void AffectRadiation( Critter& cr, int value ) from "radiation";
import bool ConsumeMeal( Critter& cr, uint water_pid, uint amount ) from "food";
import void AskCooking( Critter& cr ) from "cooking";
import void InjureCritter( Critter& cr, uint dmg, uint dmgType, uint8 dir, int attackerId ) from "combat"; // Export

/* Дефайны айтемов должны быть в _itempid.fos !!!!
#define PID_FIREBARREL    ( 7900 )
#define PID_FIREPLACE     ( 7901 )
#define PID_WELL_1		  ( 7902 )
#define PID_WELL_2		  ( 7903 ) //Нужно поправить описание!
#define PID_WELL_3		  ( 7904 ) //У него спрайт кактуса!
#define PID_CACTUS_1      ( 7905 )
#define PID_CACTUS_2      ( 7906 ) //У него спрайт генератора!
#define PID_POWER_GEN     ( 7907 ) //У него нет спрайта!
#define PID_LIGHT_ENV     ( 7908 ) // val1 = lightColor, val2 = radius
#define PID_FIREPLACE_OFF ( 7911 )
*/

int[][] groups = { {}, { PID_POWER_GEN }, { PID_FIREBARREL }, { PID_FIREPLACE2, PID_FIREPLACE_OFF, 286, PID_WILDFIRE_1 }, { PID_WELL_1, PID_WELL_2, PID_WELL_3, PID_NEW_WELL }, { PID_CACTUS_1, PID_CACTUS_2 } };
string[] group_descriptions = { "ERROR", "генераторе", "бочке", "костре", "колодце", "кактусе"};
#define TYPE_NONE        ( 0 )
#define TYPE_POWERGEN    ( 1 )
#define TYPE_FIREBARREL  ( 2 )
#define TYPE_FIREPIT     ( 3 )
#define TYPE_WELL 		 ( 4 )
#define TYPE_CACTUS 	 ( 5 )

int FindGroup(Item& item) {
    int PID = item.GetProtoId();
	for( uint i = 0, iEnd = groups.length(); i < iEnd; i++ )
		if( groups[i].find(PID) != -1 ) return i;
	return TYPE_NONE;
}

#define STATE Val0
#define MAX Val1
#define VAL Val2
#define EVENT Val3
#define BREAK Val4
#define TYPE Val5

#define WATER_FILL_TIME __FullSecond + REAL_MINUTE( Random( 15, 45 ) )
void _InitItem( Item& item, bool firstTime )
{
	//TODO: Разобраться, почему при перезапуске сервера слетает поведение предметов, если раскомментить строку ниже:
	//if( !firstTime ) return;
	
	int key = FindGroup(item);
    if( key > TYPE_NONE ) 
	{
        if( key != TYPE_FIREPIT )
			ChangeFrame( item, 0 );

        item.STATE = 0;
		if( key == TYPE_WELL || key == TYPE_CACTUS ) {
			item.MAX = ( key == TYPE_CACTUS ? Random(10,15) : Random(25,75) );
			item.VAL = item.MAX;
		}
		else 
		{
			item.MAX = 10;
			item.VAL = 0;
		}
		item.EVENT = 0;
		if(key == TYPE_WELL) {
			uint[] values = { item.Id };
			item.EVENT = CreateTimeEvent( __FullSecond + WATER_FILL_TIME, "e_WellCharge", values, true );
		}
		item.BREAK = 0;
		item.TYPE = key;
		item.SetEvent( ITEM_EVENT_SKILL, "e_Skill" );
        item.SetEvent( ITEM_EVENT_USE_ON_ME, key == TYPE_CACTUS ? "e_Cut" : "e_Repair" );
    }
}

bool e_Skill( Item& item, Critter& cr, int skill ) 
{
	if( item.GetProtoId() == 286 )
		return false; //Игнор дров.
	
	if(item.STATE != 0 ) {
		cr.Say(SAY_NETMSG, "Предмет требует починки!" );
		return true;
	}
	string description = group_descriptions[item.TYPE];
    switch( skill ) 
	{
		case SK_SCIENCE:
			cr.Say( SAY_NETMSG, "В " + description + " осталось " + item.VAL + "." );
			return true;
		case SKILL_PICK_ON_GROUND:
		switch(item.TYPE) {
			//case(TYPE_FIREBARREL):
			case(TYPE_FIREPIT):
				if( item.VAL > 0 ) { AskCooking( cr ); return true; }
				else { cr.Say(SAY_NETMSG, "Огонь погас, используйте древесину и зажигалку."); item.STATE = 1; }
				return true;
			//case(TYPE_CACTUS):
			case(TYPE_WELL):
				if( item.VAL > 0 ) return ShowMenuWater( cr, item );
				else
					cr.Say(SAY_NETMSG, "В " + description + " кончилась вода. Подождите часок-другой или поработайте лопатой."); 
				return true;
			default: break;
		}
    }
    return false;
}

bool ShowMenuWater(Critter& cr, Item& item) {
	if( item.VAL <= 0 ) 
	{ 
		cr.Say(SAY_NETMSG, "В колодце кончилась вода. Подождите часок-другой или поработайте лопатой."); 
		return true; 
	}
	
	cr.ShowScreen( SCREEN_DIALOGBOX, 3, "adv_items@answer_WATER" );
	cr.Say( SAY_DIALOGBOX_TEXT, "В " + group_descriptions[item.TYPE] + " осталось " + item.VAL + "." );
	cr.Say( SAY_DIALOGBOX_BUTTON( 0 ), "набрать воды" );
	cr.Say( SAY_DIALOGBOX_BUTTON( 1 ), "попить" );
	cr.Say( SAY_DIALOGBOX_BUTTON( 2 ), "помыться" );
	
	cr.StatBase[ST_VAR7] = item.Id;
	
	return true;
}

import bool checkTiredness( Critter& cr, int max, int add ) from "fix_boy";

int[] BottlePIDs_before = { PID_BOTTLE_GLASS };//PID_EMPTY_BUCKET
int[] BottlePIDs_after = { PID_GLASS_BOTTLE_DIRTY_FULL };// PID_WATER_BUCKET
void answer_WATER( Critter& cr, uint answerI, string& answerS )
{
	if( cr.IsBusy() || cr.IsDead() )
	{
		cr.Say( SAY_NETMSG, "Вы заняты, подождите." );
		return;
	}
	
	cr.Action( ACTION_PICK_CRITTER, 3, null );
	cr.Wait(500);
	
	Map@ map = cr.GetMap();
	if(!valid(map)) { Log("Вызов с глобала!"); return; }
	Item@ source = map.GetItem(cr.StatBase[ST_VAR7]);
	if(!valid(source)) { Log("Потеря указателя на предмет!"); return; }
		
	switch( answerI )
	{
		case(0): if (!collectWater( cr, null )) return; 
				 else break;
		case(1): ConsumeMeal( cr, PID_GLASS_BOTTLE_DIRTY_FULL, 1 ); break;
		case(2): Cleaning( cr, 0, -1 ); break;
	}
	if( !spendWater( cr, source, 1 ) ) return;//TODO: влияние вариативности использования на затраты воды
	ShowMenuWater( cr, source );
}

bool spendWater( Critter& cr, Item& source, int delta )
{
	if( source.VAL < delta )
		return testInfo( cr, "VAL(" + source.VAL + ") < delta(" + delta + ")" );
	
	source.VAL -= delta;

	return true;
}

//import bool collectWater( Critter& cr, Item@ bottle ) from "adv_items";
bool collectWater( Critter& cr, Item@ bottle ) //exported
{
	if( !valid( bottle ) )
	{
		@bottle = _CritGetItemHand( cr );
		if( !valid( bottle ) ) 
			return testInfo( cr, "Возьмите пустую тару в руки!" );
	}
	
	int n = BottlePIDs_before.find( bottle.GetProtoId() );
	if(n == -1) { cr.Say( SAY_NETMSG, "Эта тара не подходит!" ); return false; }

	if( !isGM(cr) && !checkTiredness( cr, 60, 5 ) ) {
		//cr.Say( SAY_NETMSG, "Вы слишком устали, дайте отдых рукам." ); //Проверка усталости сама выводит сообщение игроку.
		return false; 
	}
	
	_SubItem( bottle, 1 );
	_CritAddItem( cr, BottlePIDs_after[n], 1 );
	cr.Say( SAY_EMOTE, "набирает мутную жижу" );
	//AffectRadiation( cr, 5 );
	
	//Проверка усталости сама накидывает усталость, смотри код `checkTiredness`
	//cr.TimeoutBase[ TO_SK_REPAIR ] = __FullSecond + /*(11 - cr.Stat[ ST_ENDURANCE ] )*/ 5 * REAL_SECOND( 3 );
	//cr.AddTimeEvent( "main@cte_Tired", 5 * REAL_SECOND( 3 ), CTE_TIRED, 0 );
	return true;
}

#define CACTUS_REST_TIME __FullSecond + REAL_MINUTE( Random( 15, 45 ) )
#define CACTUS_WATERING_TIME __FullSecond + REAL_MINUTE( Random( 1, 3 ) )
int[] CactusCutting_tools = { PID_KNIFE, PID_AXE, PID_COMBAT_KNIFE, PID_THROWING_KNIFE, PID_LIL_JESUS_WEAPON, 
								PID_REVKNIFE1, PID_REVKNIFE2, PID_SHIV, PID_SWITCHBLADE, PID_WAKIZASHI_BLADE };
bool e_Cut( Item& item, Critter& cr, Item@ usedItem )
{
	if( item.VAL == 0 ) {
		cr.Say( SAY_NETMSG, "Этот кактус полностью выжат, ему потребуется около получаса на восстановление." );
		uint[] values = { item.Id };
		item.EVENT = CreateTimeEvent( __FullSecond + CACTUS_REST_TIME, "e_CactusCharge", values, true );
		return true;
	}
	if( cr.Timeout[ TO_SK_REPAIR ] > 0 && !isGM(cr) ) {
		cr.Say( SAY_NETMSG, "Вы слишком устали, дайте отдых рукам." ); return true; 
	}
	if( !valid(usedItem) || CactusCutting_tools.find(usedItem.GetProtoId()) == -1 ) {
		cr.Say( SAY_NETMSG, "Что бы извлечь из кактуса влагу, вам потребуется использовать любой инструмент из списка:" );
		for(uint i = 0, iEnd = CactusCutting_tools.length(); i < iEnd; i++)
			cr.SayMsg( SAY_NETMSG, TEXTMSG_ITEM,  CactusCutting_tools[i] * 100 );
		return true;
	}
	Item@ hand = _CritGetItemHand( cr );
	if(!valid(hand)) { cr.Say( SAY_NETMSG, "Возьмите пустую тару в руки!" ); return true; }
	int n = BottlePIDs_before.find( hand.GetProtoId() );
	if(n == -1) { cr.Say( SAY_NETMSG, "Эта тара не подходит!" ); return true; }
	_SubItem(hand, 1);
	_CritAddItem( cr, BottlePIDs_after[n], 1 );
	cr.TimeoutBase[ TO_SK_REPAIR ] = __FullSecond + /*(11 - cr.Stat[ ST_ENDURANCE ] )*/ 1 * REAL_SECOND( 30 );
	cr.AddTimeEvent( "main@cte_Tired", 1 * REAL_SECOND( 30 ), CTE_TIRED, 0 );
	cr.Say( SAY_EMOTE, "набирает воду" );
	return false;
}

#define WELL_BROKEN_ROPE  ( 1 )
#define WELL_BROKEN_WHEEL ( 2 )
#define WELL_BROKEN_SHAFT ( 3 )
#define FIRE_BURNING_TIME REAL_SECOND( Random( 4, 10 ) )
uint[][] Repairing_resources =  {{ PID_ROPE, PID_CRAFT_M_STEL, PID_FIREWOOD }, {PID_COAL,PID_FIREWOOD}};
uint[][] Repairing_tools =      {{ PID_MULTI_TOOL, PID_SUPER_TOOL_KIT, PID_SHOVEL }, {PID_LIGHTER}};
uint[][] Repairing_iterations = {{ 1, 2, 3 }, {0, 0}};

//import bool e_Repair( Item& item, Critter& cr, Item@ usedItem ) from "adv_items";
bool e_Repair( Item& item, Critter& cr, Item@ usedItem )
{
	if(item.STATE == 0 && !valid(usedItem)) return e_Skill( item, cr, SKILL_PICK_ON_GROUND ); 
	if( cr.Timeout[ TO_SK_REPAIR ] > 0 && !isGM(cr) ) {
		cr.Say( SAY_NETMSG, "|0xFF0000 Вы слишком устали, дайте отдых рукам." ); return true; 
	}

    switch( item.TYPE ) {
		case(TYPE_NONE):  break;
		case(TYPE_WELL): {
			
			if( !isGM(cr) && !checkTiredness( cr, 60, 60 ) )
				return true; 
			if (item.VAL >= 80){cr.Say( SAY_NETMSG, "|0xFFFF00 Вода переливается за края колодца. Вы не можете больше копать." ); return true;}//TODO: ускорять набор воды (таймивент)
			if (usedItem.GetProtoId() == PID_SHOVEL){
				item.VAL += Random( 0, 1 );
				cr.Say( SAY_EMOTE_ON_HEAD, "копает колодец" );//TODO: ускорять набор воды (таймивент)
			}
			else{
				cr.Say( SAY_NETMSG, "|0xFF0000 копайте колодец чем-то более приемлиемым, например лопатой." );//TODO: ускорять набор воды (таймивент)
			} 
			
			return true;
		}
		default: break;
    }
	return false;
}

void e_Hot(Item& item, Critter& crit, bool entered, uint8 dir) 
{
	if( entered )
	{
		if( crit.GetTimeEvents( CTE_DYSPNEA, null, null, null ) == 0 )
			crit.AddTimeEvent( "cte_Hot", 0, CTE_DYSPNEA, 0 );
	}
	else crit.EraseTimeEvents( CTE_DYSPNEA );
}

bool NeededItem( Critter& cr, uint16 protoId )
{
    cr.Say( SAY_NETMSG, "Требуется:" );
    cr.SayMsg( SAY_NETMSG, TEXTMSG_ITEM, protoId * 100 );
	return true;
}
 
void LightControl( Item& item, bool onOff, uint intensity, uint8 radius )
{
	item.SetEvent( ITEM_EVENT_WALK, onOff ? "e_Hot" : null );
    item.LightIntensity = intensity;
    item.LightColor = LightColor( onOff ? 1 : 0 );
    item.Update();
}

uint LightColor( int color )
{
    switch( color )
    {
    case 1:
        color = 9999666;
        break;                         
    default:
        color = 0;
        break;
    }
    return color;
}

void addlight( Critter& player, int param0, int param1, int param2 )
{
    Map @ map = player.GetMap();
    uint16 hexX = 0, hexY = 0;
    for( uint8 i = 240; i < 242; i++ )
    {
        if( not map.GetEntireCoords( i, 0, hexX, hexY ) )
        {
            Log( "entire num " + i + " not found(light env)" );
            return;
        }
        Log( "hexX = " + hexX + " hexY = " + hexY );
        Item@ light = map.AddItem( hexX, hexY, PID_LIGHT_ENV, 1 );
        Log( "light" + ( valid( light ) ? " " : " not ") + "valid" );
    }
}

uint e_WellCharge( uint[] @ values ) 
{
	Item @ well = GetItem( values[ 0 ] );
	if( !valid( well ) ) return 0;
	well.MAX = Random(25,75);
	well.VAL += CLAMP(Random(25,well.MAX), 0, well.MAX);
	Map@ map = GetMap( well.MapId );
	if(valid(map)) map.SetText(well.HexX,well.HexY,COLOR_GRAY,":журчание воды:");
	well.STATE = 0;
	return WATER_FILL_TIME;
}
uint e_CactusCharge( uint[] @ values )
{
    Item @ cactus = GetItem( values[ 0 ] );
    if( cactus.MAX >= cactus.VAL )
    {
        cactus.VAL += Random( 0, 1 ) + Random( 0, 1 ) + Random( 0, 1 );
        return CACTUS_WATERING_TIME;
    }
	cactus.EVENT = 0;
    return 0;
}

void RemoveItemsByPID( Map& map, uint pid )
{
	Item@[] items;
	uint count = map.GetItems( pid, items );
	for( uint i = 0; i < count; i++ )
		DeleteItem( items[i] );
}

void RemoveItemsByPID( Map& map, uint[] pids )
{
	for( uint i = 0, len = pids.length(); i < len; i++ )
		RemoveItemsByPID( map, pids[i] );
}

//~run adv_items clear 0 0 0 
/*void clear( Critter& cr, int, int, int )
{
	Map@ map = cr.GetMap();
	if(!valid(map)) return;
	
	RemoveItemsByPID( map, firables );
	RemoveItemsByPID( map, firesources );
	RemoveItemsByPID( map, ashes );
}*/

//~run adv_items run 0 0 0 
void run( Critter& cr, int, int, int )
{
	Map@ map = cr.GetMap();
	if( !valid(map) ) return;
	
	uint count;
	Item@[] fires;
	
	count = map.GetItems( cr.HexX + 1, cr.HexY + 1, fires );
	if( count == 0 )
		fires.insertLast( map.AddItem( cr.HexX + 1, cr.HexY + 1, PID_WILDFIRE_1, 1 ) );
	if( fires.length() == 1 )
		switchState( fires[0] );
	fires.resize(0);
	
	count = map.GetItems( cr.HexX - 1, cr.HexY + 1, fires );
	if( count == 0 )
		fires.insertLast( map.AddItem( cr.HexX - 1, cr.HexY + 1, PID_FIREPLACE_OFF, 1 ) );
	if( fires.length() == 1 )
		switchState( fires[0] );
	fires.resize(0);
}

//~run adv_items go id1 id2 id3
void go( Critter& cr, int id1, int id2, int id3 )
{
	int[] ids = { id1, id2, id3 };
	
	for( uint i = 0, len = ids.length(); i < len; i++ )
		switchState( ids[i] );
}

void switchState( int itemId )
{
	if( itemId == 0 ) return;
	Item@ item = GetItem( itemId );
	if( !valid( item ) ) return;
	switchState( item );
}

void switchState( Item@ item )
{
	if( !valid( item ) ) return;
	
	uint pid = item.GetProtoId();
	
	if( pid != PID_FIREPLACE_OFF && pid != PID_WILDFIRE_1 && pid != PID_FIREPLACE2 ) return;
	
	bool isFire = ( pid == PID_FIREPLACE2 || pid == PID_WILDFIRE_1 );
	
	//item.ChangeProto( isFire ? PID_FIREPLACE_OFF : PID_WILDFIRE );
	@item = @recreateWithNewProto( item, isFire ? PID_FIREPLACE_OFF : PID_WILDFIRE_1 );
	if( !isFire && valid( item ) )
		item.SetEvent( ITEM_EVENT_WALK, isFire ? "e_Hot" : null );
}

Item@ recreateWithNewProto( Item& item, uint pid )
{
	Map@ map = GetMap( item.MapId );
	if( !valid( map ) ) return null;
	
	if( item.Accessory != ACCESSORY_HEX ) return null;
	
	Item@ result = map.AddItem( item.HexX, item.HexY, pid, 1 );
	if( !valid( result ) ) null;
	
	cloneVals( item, result );
	DeleteItem( item );
	
	return result;
}

void cloneVals( Item& source, Item& target )
{
	target.Val0 = source.Val0;
	target.Val1 = source.Val1;
	target.Val2 = source.Val2;
	target.Val3 = source.Val3;
	target.Val4 = source.Val4;
	target.Val5 = source.Val5;
	target.Val6 = source.Val6;
	target.Val7 = source.Val7;
	target.Val8 = source.Val8;
	target.Val9 = source.Val9;
}