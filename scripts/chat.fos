#define __CHAT_MODULE__
#include "chat.fosh"

#ifdef __CLIENT
    import bool isGM( CritterCl@ cr ) from "client_main";
    import bool out_command( string& message, int& sayType ) from "client_main";
    import bool out_speak( string& message, int& sayType ) from "client_main";

    /*
    string InaudibleVoice( uint16 SBT )
    {
        uint16[] BTList =    {    BT_MEN,  BT_WOMEN, BT_CHILDREN, BT_SUPER_MUTANT,  BT_GHOUL, BT_BRAHMIN,     BT_RADSCORPION,  BT_RAT, BT_FLOATER, BT_CENTAUR,     BT_ROBOT, BT_DOG,    BT_MANTI, BT_DEADCLAW, BT_PLANT, BT_GECKO, BT_ALIEN, BT_GIANT_ANT, BT_BIG_BAD_BOSS, BT_GIANT_BEETLE, BT_GIANT_WASP, MAX_BODY_TYPES };
        string[] EMOTEList = { "Говорит", "Говорит",   "Говорит",       "Говорит", "Говорит",    "Мычит", "Щелкает клешнями", "Пищит", "Хрипение", "Хрипение", "Попикивает", "Лает", "Стрекочет",     "Рычит",       "",  "Шипит", "Хрипит",  "Стрекочет",       "Говорит",     "Стрекочет",       "Жужит",             "" };
        string emote = "Говорит";

        for( uint8 i = 0, l = BTList.length(); i < l; i++ )
        {
            if( SBT == BTList[ i ] ) { emote = EMOTEList[ i ]; }
        }
        return "|" + COLOR_CHAT_EMOTE + " **" + emote + "**";
    }
    */

    // Убирает нестандартные символы вроде скобок из прямой речи
    class SpeechRemoveNonVerbalSymbols : MessageHandler
    {
        bool RejectMessage;

        SpeechRemoveNonVerbalSymbols() 
        {
            this.RejectMessage = false;
        }

        bool IsForbiddenSymbol(uint char) 
        {
            switch (char) {
                case '(': case ')': case '[': case ']': case '|': case '{': case '}': case '<': case '>': 
                case '@': case '#': case '~': case '^': case '_':
                    return true;
            }
            return false;
        }

        bool resolve(uint& critterID, string& text, uint8 volume, int sayType) 
        {
            if (!SayType(sayType).IsSpeech() || text.length() == 0) return false;

            for (uint i = 0, length = text.length(); i < length; i++) {
                if (this.IsForbiddenSymbol(text[i])) {
                    this.RejectMessage = true;
                    return true;
                }
            }
            return false;
        }
    }

    // Деградирует текстовое сообщение в зависимости от дистанции и громкости речи
    class SpeechIllegibilityGenerator : MessageHandler
    {
        // Символ - гласная буква
        bool IsVowel(uint char) 
        {
            switch (char) {
                case 224: case 238: case 253: case 243: case 254: case 255: case 251: case 229: case 232: case 184:
                case 192: case 197: case 200: case 206: case 211: case 219: case 221: case 222: case 223: case 168:
                case 'a': case 'e': case 'i': case 'o': case 'y': case 'u':
                case 'A': case 'E': case 'I': case 'O': case 'Y': case 'U':
                    return true;
            }
            return false;
        }

        // Символ относится к A-z А-я 0-9
        bool IsAlphanumeric(uint8 char) 
        {
            return ('0' <= char && '9' >= char) || ('a' <= char && 'z' >= char) || ('A' <= char && 'Z' >= char) || (192 <= char && 255 >= char) || 184 == char || 168 == char;
        }

        bool resolve(uint& critterID, string& text, uint8 volume, int sayType) 
        {
            if ("" == text || !SayType(sayType).IsSpeech()) {
                return false; // Если вернуть true, остальные MessageHandler в очереди не запустятся
            }

            float integrity = 1.0f;
            CritterCl@ chosen = GetChosen();
            CritterCl@ speaker = GetCritter(critterID);

            if (null !is chosen && isGM(chosen)) { // Игнор для ГМов
                return false;
            }

            // Повреждение сообщения в зависимости от дистанции и громкости
            if (null !is speaker) {
                int distance = GetDistantion(chosen.HexX, chosen.HexY, speaker.HexX, speaker.HexY);
                int diff = int(volume) - distance;
                // Дистанция превышает условную громкость - повреждаем сообщение
                if (diff < 0) { 
                    integrity = integrity / float(-diff);
                }
            }
            // Повредить текст сделав большую часть слогов неразборчивыми
            if (integrity < 1.0f) {
                // При <6% слышимости игнорировать
                if (integrity < 0.06f) {
                    text = "...";
                }
                // Иначе - делать попытки расслышать часть текста
                else {
                    array<string@> parts = {};
                    int penalty = 0;
                    int threshold = floor(integrity * 200);
                    // перебираем сообщение
                    for (uint i = 0, length = text.length(), y = 0; i < length && y <= i; i++) {
                        // удаляем все знаки кроме пробелов и А-я A-z 0-9
                        if (!IsAlphanumeric(text[i]) && ' ' != text[i]) {
                            text[i] = ' ';
                        }
                        // грубо разбиваем сообщение на "слоги" (если обрабатывать не по слогам а посимвольно потом разобрать что-то невозможно)
                        if (text[i] == ' ' || (i > 0 && this.IsVowel(text[i]) && (i == length - 1 || !this.IsVowel(text[i+1]))))
                        {
                            uint offset = i - y + 1;
                            string part = substring(text, y, y + offset < length ? offset : length - y);
                            int roll = Random(0, 100);
                            // не слышно
                            if (roll > (threshold - penalty)) {
                                if (parts.length == 0 || (parts[parts.length - 1] != "...")) parts.insertLast("...");
                            } 
                            // слышно
                            else {
                                parts.insertLast(part);
                                // с каждым расслышанным слогом шанс расслышать следующий слог падает
                                // в зависимости от целостности сообщения и восприятия персонажа
                                // это нужно чтобы избежать ситуаций когда из-за рандома все слоги
                                // рольнулись как слышные не смотря на то что шанс для каждого был ~1%
                                penalty += floor((1.0 - integrity) * (15 - chosen.Stat[ ST_PERCEPTION ]));
                            }
                            y = i + 1;
                            continue;
                        }
                    }
                    // склеиваем слоги в текст, чистим от артефактов
                    text = join(parts, "");
                    if (text == "......") text = "...";
                }
            }
            
            return false;
        }
    }

    bool InMessage(string& message, int& sayType, uint& senderCritterID, uint& delay)
    {
        ChatMessage@ chatMessage = ChatMessage(message, sayType, senderCritterID);

        // Внешние фильтры
        //chatMessage.OnInMessage(MessageHandler()); // Выводит все обрабатываемые выражения в чат (отладка)
        chatMessage.OnInMessage(SpeechIllegibilityGenerator());
        chatMessage.InMessage(message, sayType);

        return true;
    }

    bool OutMessage(string& message, int& sayType) 
    {
        CritterCl @ choo = GetChosen();
        if(valid(choo)) RunServerScriptUnsafe( "rp_chat@unsafe_stopTyping", 0, 0, 0, null, null );

        //
        // Команда
        //
        if (
            // Имеет префикс как у команды
            (message[ 0 ] == '#' || message[ 0 ] == '%' || message[ 0 ] == '$' || message[ 0 ] == '!' || message[ 0 ] == '~')
            // Второй символ относится к А-я 0-9
            && (message.length() > 1 && ((message[2] >= 'A' && message[2] <= 'z') || (message[2] >= '0' && message[2] <= '9')))
        ) { 
            if(__waiting) {
                Message("Нельзя использовать команды в процессе ожидания");
                return false;
            } 
            return out_command(message, sayType);
        }

        //
        // Речь
        //
        // Серый текст
        if (message.length() >= 2 && (message[0] == '.' || message[0] == '/') && (message[1] == 241 || message[1] == 209 || message[1] == '$')) {
            sayType = SAY_SOCIAL;
            message = substring(message, 2, message.length() - 2);
        } 
        // Игнорировать уже отформатированные сообщения
        else if (message.length() > 1 && message[0] == '|') {
            return out_speak(message, sayType);
        }
        // Обычная речь
        else {
            CritterCl@ chosen = GetChosen();
            ChatMessage@ chatMessage = ChatMessage(message, sayType, chosen is null ? 0 : chosen.Id);
            
            // Внешние фильтры
            //chatMessage.OnOutMessage(MessageHandler());// Выводит все обрабатываемые выражения в чат (отладка)
            SpeechRemoveNonVerbalSymbols@ nvsFilter = SpeechRemoveNonVerbalSymbols();
            chatMessage.OnOutMessage(nvsFilter);

            chatMessage.OutMessage(message, sayType);

            if (nvsFilter.RejectMessage) {
                Message("Символы ()[]{}<>@#~^_ запрещены к применению в прямой речи.");
                return false;
            }
        }
        return out_speak(message, sayType);
    }

    bool MapMessage(string& message, uint16& hexX, uint16& hexY, uint& color, uint& delay) {
        int sayType = SAY_NORM;
        if (color == COLOR_CHAT_RADIO) {
            sayType = SAY_RADIO;
        } 
        else if (color == COLOR_CHAT_SHOUT) {
            sayType = SAY_SHOUT;
        }
        ChatMessage@ chatMessage = ChatMessage(message, sayType, 0);
        chatMessage.InMessage(message, sayType);
        return true;
    }
#endif