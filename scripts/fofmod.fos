#ifndef FOFMOD_MODULE
#define FOFMOD_MODULE


#include "fofmod_h.fos"
#include "_macros.fos"



// Read fofmod.cpp in scripts/fmod/src directory for documentation AS interface registering section
// API exposes fmod features as directly as possible, fmod documentation should explain on how fofmod API supposed to work.
// https://fmod.com/resources/documentation-api?version=2.0&page=core-api.html



#define FOFMOD_CHANNEL_COUNT ( 32 ) // 32 is okay, Range: [0, 4095]


//Translate hex coordinates into more human coordinates: X is right and Y is down
void CoordinatesHexToGrid(int x, int y, float &out ox, float &out oy)
{
	const float sqrt3 = 1.732050807;
	int div = x / 2;
	y += div;

	ox = sqrt3 * (x - y / 2.0);
	oy = y * 3.0 / 2.0;
}


#ifdef __CLIENT

#pragma bindfunc "void dummy_fmod() -> fofmod_client.dll CLIENT"	// to trigger entry point from engine

#define FOFMOD_DEBUG




uint16 Hx, Hy;
float FHx, FHy;

dictionary PlayingSounds;
uint PlayingSoundCount = 0;
dictionary PlayingMusic;
uint PlayingMusicCount = 0;


// // no templates, whatever, fuck off;
// class PlayingSoundContainer
// {

// 	const uint GARBAGE_TIME = 5000;
// 	uint lastGarbageTick;

// 	array<FMODChannel@> playingSounds;
// 	array<uint> soundsFreePositions;
// 	array<uint> soundsUsedPositions;


// 	PlayingSoundContainer()
// 	{
// 		this.lastGarbageTick = GetTick();
// 		this.playingSounds.resize(0);
// 		this.soundsFreePositions.resize(0);
// 		this.soundsUsedPositions.resize(0);
// 		this.toDelete.resize(0);
// 	}

// 	uint Count()
// 	{
// 		return this.soundsUsedPositions.length();
// 	}

// 	uint CountFree()
// 	{
// 		return this.soundsFreePositions.length();
// 	}

// 	void Add( FMODChannel@ chn )
// 	{
		
// 		uint len = this.soundsFreePositions.length();
// 		if( len > 0 )
// 		{
// 			@this.playingSounds[ this.soundsFreePositions[ len - 1 ] ] = chn;
// 			this.soundsFreePositions.removeLast();
// 		}
// 		else
// 		{
// 			this.playingSounds.insertLast( chn );
// 		}

// 		this.soundsUsedPositions.insertLast( this.playingSounds.length() - 1 );
// 	}

// 	void Update()
// 	{
// 		for( unsigned int i = 0, j = this.playingSounds.length(); i < j; i++ )
// 		{
// 			FMODChannel@ ptr = this.playingSounds[i];
// 			if( valid( ptr ) )
// 			{
// 				if( ptr.IsValid() )
// 				{
// 					// sounds are alive, do whatever you want to them
// 				}
// 				else
// 				{
// 					// gotta remove the garbage
// 					@this.playingSounds[i] = null;
// 					this.soundsFreePositions.insertLast( i );
// 					int pos = this.soundsUsedPositions.find( i );
// 					if( pos > -1 )
// 					{
// 						this.soundsUsedPositions.removeAt( pos );
// 					}
// 				}
// 			}
// 		}
// 	}
// }

// PlayingSoundContainer PlayingSounds;
// PlayingSoundContainer PlayingMusic;


bool FOFMOD_Initialize()
{
	bool result = FMOD_Initialize( FOFMOD_CHANNEL_COUNT );
	if( result )
	{
		FMOD_Set3DListenerUp( 0.0f, 0.0f, 1.0f ); // UP is towards Camera, right handedness
		FMOD_Set3DListenerForward( 0.0f, -1.0f, 0.0f ); // Negative Y is forward
		#ifdef FOFMOD_DEBUG
		FOFMOD_Test();
		#endif
	}

	return result;
}


void FOFMOD_Update()
{
	CritterCl@ chosen = GetChosen();
	if( valid ( chosen ) )	
	{
		if( ( Hx != chosen.HexX ) || ( Hy != chosen.HexY) )
		{
			// position changed
			Hx = chosen.HexX;
			Hy = chosen.HexY;
			CoordinatesHexToGrid( Hx, Hy, FHx, FHy );
			FMOD_Set3DListenerPosition( FHx, FHy, 0.0f );
			Message(" Position update " + FHx + ":"  + FHy );
		}
		
	}
	else
	{
		FMOD_Set3DListenerPosition( 0.0f, 0.0f, 0.0f );
	}
	
	FOFMOD_ProcessGarbage();
	//FOFMOD_PersistentTest();
	FMOD_Update();
}


uint LastGarbageTick;
const uint GARBAGE_TIME = 5000;// in MS

void FOFMOD_PersistentTest()
{
	//Log("Playing Sounds count " + PlayingSoundCount );
	if( PlayingSoundCount < 1000 )
	{
		FMODChannel@ testSound3 = FMOD_PlaySound("c.ogg", false); // automatic path
		if( valid(testSound3) )
		{
			//testSound3.SetPitch( float( Random( 500, 2000 ) / 1000 ) );
			PlayingSoundCount++;
			PlayingSounds.set( ""+uint(-PlayingSoundCount), @testSound3 );
		}
	}
}

void FOFMOD_ProcessGarbage()
{
	uint currentTick = GetTick();
	if( ( currentTick - LastGarbageTick ) >= GARBAGE_TIME )
	{
		// garbage loose objects
		array<string@> keys = array<string@>();
		uint count = PlayingSounds.keys( keys );
		for( uint i = 0; i < count; i++ )
		{
			FMODChannel@ ptr = null;
			PlayingSounds.get( keys[i], @ptr );
			if( valid( ptr ) )
			{
				if( !ptr.IsValid() )
				{
		//			Log("Playing sound is not valid, removing.");
					PlayingSounds.delete( keys[i] );
					PlayingSoundCount--;
				}
			}
		}

		keys.resize(0);
		count = PlayingMusic.keys( keys );
		for( uint i = 0; i < count; i++ )
		{
			FMODChannel@ ptr = null;
			PlayingMusic.get( keys[i], @ptr );
			if( valid( ptr ) )
			{
				if( !ptr.IsValid() )
				{
					PlayingMusic.delete( keys[i] );
					PlayingMusicCount--;
				}
			}
		}

		LastGarbageTick = currentTick;
	}
}


void FOFMOD_Test()
{
	Log("Preloading sounds directory at test");
	//FMOD_PreloadSounds( ".\\test" );
	FMOD_TouchArchive("./data/forp_content.zip");
	FOFMOD_TestSounds();
}

void FOFMOD_TestSounds()
{	

	FMODChannel@ testSound2 = FMOD_PlaySound("./test/c.ogg", false); // manual path
	FMODChannel@ testSound3 = FMOD_PlaySound("c.ogg", false); // automatic path
	if( valid(testSound3) )
	{
		testSound3.SetPitch( 0.7f );
	}

	FMODChannel@ testSoundPathArchive = FMOD_PlaySound( "sound/sfx/chewy.ogg", false ); // manual path
	FMODChannel@ testSoundArchive = FMOD_PlaySound("chewy.ogg", false); // automatic path
	if( valid( testSoundArchive ) )
	{
		testSoundArchive.SetPitch( 0.5f );
	}
}
 
// global sound, no position or distance specified
FMODChannel@ FOFMOD_PlaySound( string& filename )
{
	FMODChannel@ result = null;

	@result = FMOD_PlaySound( filename, true );
	if( valid( result ) )
	{
		result.Set3DLevel( 0.0f ); // do not attenuate with distance from listener
		result.Set3DMinMaxDistance( 100000.0f, 100000.0f ); // its actually documented to be legit
	//	result.SetPaused(false);
	}

	return result;
}


FMODChannel@ FOFMOD_PlaySound( string& filename, uint16 hexX, uint16 hexY, uint minDistance, uint maxDistance )
{

	FMODChannel@ result = null;

	@result = FMOD_PlaySound( filename, true );

	if( valid(result ) )
	{
		float x = 0.0f, y = 0.0f;
		CoordinatesHexToGrid( hexX, hexY, x, y );
		result.Set3DPosition( x, y, 0.0f );
		CoordinatesHexToGrid( minDistance, maxDistance, x, y );
		result.Set3DMinMaxDistance( x, y ); 
	//	result.SetPaused(false);
	}
	
	return result;
}

void __PlaySoundFile( int hexX, int hexY, int soundId, string@ path, int[]@ param4)
{
	Log("Playing from remote sound id " + soundId + " " + path );
	FMODChannel@ sound = FMOD_PlaySound( path, false );
	//if( ( hexX > 0 ) && ( hexY > 0 ) )
	//{
		float ox = 0.0f, oy = 0.0f;
		CoordinatesHexToGrid( hexX, hexY, ox, oy );
		sound.Set3DPosition( ox, oy, 0.0f );
		sound.Set3DMinMaxDistance( 5.0f, 24.0f ); 
		Log("Play at position " + ox + ":" + oy );
	//}

	PlayingSounds.set( ""+soundId, @sound );
	PlayingSoundCount++;
}



#endif // __CLIENT



#ifdef __SERVER


// void FOFMOD_Client_PlaySound( Critter& client, Sound& sound )
// {

// }

// void FOFMOD_Client_UpdateSound( Critter& client, Sound& sound )
// {

// }

// void FOFMOD_Client_PauseSounds( Critter& client )
// {

// }

// void FOFMOD_Client_StopSounds( Critter& client )
// {

// }

// void FOFMOD_Client_PauseMusic( Critter& client )
// {

// }

// void FOFMOD_Client_StopMusic( Critter& client )
// {

// }



#endif // __SERVER


#endif // FOFMOD_MODULE