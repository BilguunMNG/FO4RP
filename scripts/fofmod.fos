#ifndef FOFMOD_MODULE
#define FOFMOD_MODULE


#include "fofmod_h.fos"
#include "_macros.fos"



// Read fofmod.cpp in scripts/fmod/src directory for documentation AS interface registering section
// API exposes fmod features as directly as possible, fmod documentation should explain on how fofmod API supposed to work.
// https://fmod.com/resources/documentation-api?version=2.0&page=core-api.html



#define FOFMOD_CHANNEL_COUNT ( 32 ) // 32 is okay, Range: [0, 4095]


//Translate hex coordinates into more human coordinates: X is right and Y is down
void CoordinatesHexToGrid(int x, int y, float &out ox, float &out oy)
{
	const float sqrt3 = 1.732050807;
	int div = x / 2;
	y += div;

	ox = sqrt3 * (x - y / 2.0);
	oy = y * 3.0 / 2.0;
}


#ifdef __CLIENT

#pragma bindfunc "void dummy_fmod() -> fofmod_client.dll CLIENT"	// to trigger entry point from engine

#define FOFMOD_DEBUG

dictionary PlayingSounds;
dictionary PlayingMusic;

bool FOFMOD_Initialize()
{
	bool result = FMOD_Initialize( FOFMOD_CHANNEL_COUNT );
	if( result )
	{
		FMOD_Set3DListenerUp( 0.0f, 0.0f, 1.0f ); // UP is towards Camera, right handedness
		FMOD_Set3DListenerForward( 0.0f, -1.0f, 0.0f ); // Negative Y is forward
		#ifdef FOFMOD_DEBUG
		FOFMOD_Test();
		#endif
	}

	return result;
}


uint16 prevHx, prevHy;

void FOFMOD_Update()
{
	CritterCl@ chosen = GetChosen();
	if( valid ( chosen ) )	
	{
		if( ( prevHx != chosen.HexX ) || ( prevHy != chosen.HexY) )
		{
			// position changed
			prevHx = chosen.HexX;
			prevHy = chosen.HexY;
			float ox = 0.0f, oy = 0.0f;
			CoordinatesHexToGrid( chosen.HexX, chosen.HexY, ox, oy );
			FMOD_Set3DListenerPosition( ox, oy, 0.0f );
			Message(" Position update " + ox + ":"  + oy );
		}
		
	}
	else
	{
		FMOD_Set3DListenerPosition( 0.0f, 0.0f, 0.0f );
	}
	
	FOFMOD_ProcessGarbage();
	FMOD_Update();
}


uint LastGarbageTick;
const uint GARBAGE_TIME = 5000;// in MS

void FOFMOD_ProcessGarbage()
{
	uint currentTick = GetTick();
	if( ( currentTick - LastGarbageTick ) >= GARBAGE_TIME )
	{
		// garbage loose objects
		array<string@> keys = array<string@>();
		uint count = PlayingSounds.keys( keys );
		for( uint i = 0; i < count; i++ )
		{
			FMODChannel@ ptr = null;
			PlayingSounds.get( keys[i], @ptr );
			if( valid( ptr ) )
			{
				if( !ptr.IsValid() )
				{
					Log("Playing sound is not valid, removing.");
					PlayingSounds.delete( keys[i] );
				}
			}
		}

		keys.resize(0);
		count = PlayingMusic.keys( keys );
		for( uint i = 0; i < count; i++ )
		{
			FMODChannel@ ptr = null;
			PlayingMusic.get( keys[i], @ptr );
			if( valid( ptr ) )
			{
				if( !ptr.IsValid() )
				{
					PlayingMusic.delete( keys[i] );
				}
			}
		}

		LastGarbageTick = currentTick;
	}
}


void FOFMOD_Test()
{
	Log("Preloading sounds directory at test");
	//FMOD_PreloadSounds( ".\\test" );
	FMOD_TouchArchive("./data/forp_content.zip");
	FOFMOD_TestSounds();
}

void FOFMOD_TestSounds()
{	

	FMODChannel@ testSound2 = FMOD_PlaySound("./test/c.ogg", false); // manual path
	FMODChannel@ testSound3 = FMOD_PlaySound("c.ogg", false); // automatic path
	if( valid(testSound3) )
	{
		testSound3.SetPitch( 0.7f );
	}

	FMODChannel@ testSoundPathArchive = FMOD_PlaySound( "sound/sfx/chewy.ogg", false ); // manual path
	FMODChannel@ testSoundArchive = FMOD_PlaySound("chewy.ogg", false); // automatic path
	if( valid( testSoundArchive ) )
	{
		testSoundArchive.SetPitch( 0.5f );
	}
}

void __PlaySoundFile( int hexX, int hexY, int soundId, string@ path, int[]@ param4)
{
	Log("Playing from remote sound id " + soundId + " " + path );
	FMODChannel@ sound = FMOD_PlaySound( path, false );
	//if( ( hexX > 0 ) && ( hexY > 0 ) )
	//{
		float ox = 0.0f, oy = 0.0f;
		CoordinatesHexToGrid( hexX, hexY, ox, oy );
		sound.Set3DPosition( ox, oy, 0.0f );
		sound.Set3DMinMaxDistance( 3.0f, 12.0f ); 
		Log("Play at position " + ox + ":" + oy );
	//}

	PlayingSounds.set( ""+soundId, @sound );
}

#endif // __CLIENT



#ifdef __SERVER


#endif // __SERVER


#endif // FOFMOD_MODULE