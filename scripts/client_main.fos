// comment this out to disable physical ui and enable "visible_items.fos"
#define PHYSICAL_UI

// Author: cvet, Atom
// Client main script
// Compile using fo_client.dll
#include "_client_defines.fos"
#include "_msgstr.fos"
#include "sprite.fos"
#include "_colors.fos"
#include "_animation.fos"
#include "combat_h.fos"
// #include "mutual_h.fos"
#include "wait_time_h.fos"

#include "_utils.fos"

import void InitializeGame() from "config";
import void InitTestScreen() from "client_screen_test";
import void InitRadioScreen() from "radio";
import void GUI_Init() from "client_gui";
import void GUI_GetActiveScreens( int[]& result ) from "client_gui";
import void GUI_ShowScreen( int screenIndex, int p0, int p1, int p2 ) from "client_gui";
import void GUI_HideScreen( int screenIndex, int p0, int p1, int p2 ) from "client_gui";
import void GUI_Render() from "client_gui";
import bool GUI_MouseDown( int click, int x, int y ) from "client_gui";
import bool GUI_MouseUp( int click, int x, int y ) from "client_gui";
import void GUI_MouseMove( int x, int y ) from "client_gui";
import bool GUI_KeyDown( uint8 key ) from "client_gui";
import bool GUI_KeyUp( uint8 key ) from "client_gui";
import void GUI_InputLost() from "client_gui";
import int GUI_GetActiveScreen() from "client_gui";

import bool PerkCheck( CritterCl& cr, uint perk ) from "perks";
import void CritterGenerate( int[]& data ) from "parameters";
import bool CritterGenerateCheck( int[]& data ) from "parameters";
import void InitChosenTabs() from "chosen_tabs";
import void DrawChosenTabs() from "chosen_tabs";
// binyan - Hotkeys
import void SetHotkeysUse( bool use ) from "hotkeys";
// binyan - timeouts
import void show_timeouts() from "client_timeouts";
// ///////////////////////////////////////////////////////
import bool gm_msg( string& message ) from "client_gm";

#ifdef PLAYERS_3D
import void Init3DChaRegScreen() from "client_3d_cha_reg";
import void Set3DRegistrationGender( int gender ) from "client_3d_cha_reg";
import void Fill3DRegistrationParameters( int[]& params ) from "client_3d_cha_reg";
#endif
import void PlayAnimSound( uint crType, int gender, uint anim1, uint anim2 ) from "animation";

// qthree
import void    SaveNames() from "client_names";
import void    LoadNames() from "client_names";
import void    ClearNameCache() from "client_names";
import string@ GetName( uint id ) from "client_names";
import bool    updateNick( CritterCl& cr ) from "client_names";
import bool    updateAllNicks() from "client_names";

import void DrawMapTiles() from "qmap_client";
import void qmap_loop() from "qmap_client";

import void overlay_loop(bool show) from "overlay";
import void overlay_connect() from "overlay";
import void overlay_disconnect() from "overlay";
import void overlay_visibility() from "overlay";
import void overlay_message(string& message, int& sayType, uint& critterId, uint& delay) from "overlay";

// @pm menu
import void InitContMenuScreen() from "client_screen_contmenu";     // Export
import void InitFastPanelScreen() from "client_screen_fastpanel";   // Export
import void InitFastPanelSkillbox() from "client_screen_fastpanel"; // export
import void InitFastPanelTextbox() from "client_screen_fastpanel";
// import void SaveFastPanel(bool save) from "client_screen_fastpanel";
import void InitHistoryViewScreen() from "client_screen_history";
import void InitHistoryAllScreen() from "client_screen_history";
import void HidePanel( bool show ) from "client_screen_fastpanel";
import void InitCodedoorScreen() from "client_screen_codedoor";
import void InitScreenAddiotional() from "client_screen_additional";
import void SetCrtype( int[]& params ) from "client_screen_additional";
import void InitTeachScreen() from "client_screen_teaching";
import void InitScreenDoc() from "client_screen_doc";
import void InitFirstAidScreen() from "client_screen_firstais";
import void InitOptMenuScreen() from "client_screen_options"; // Export
import void SetHivePos( int16 x, int16 y, int16 realX, int16 realY, int16 type, uint8 count ) from "client_screen_additional";
import void InitScreenInputbox() from "client_screen_inputbox";
import void InitInventoryTnfScreen() from "client_screen_inventory";
import void MoveHand() from "client_screen_copybool";
import void InitClockScreen() from "client_screen_copybool";
import void InitWaypointScreen() from "checkpoints";
import void WASDInputLoop() from "input_wasd";
import bool WASDInputKeyState(int key, bool state) from "input_wasd";
import void WASDInputLost() from "input_wasd";
// #pm menu

import void FactionGuiInit() from "factions_gui";

uint prevId = 0; // нужен для определения, когда загружать сохраненные имена
Sprite[] arrow;

Sprite F1_arrows, F1_tabs, F1_text, TabPic;
// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on client loaded or new client_main.fos script received.
bool start()
{
    InitializeGame();

    if( __ScreenWidth < 800 || __ScreenWidth > 1280 || __ScreenHeight < 600 || __ScreenHeight > 1024 )
    {
        // Recomendation message
        Message( GetMsgStr( TEXTMSG_GAME, STR_INVALID_RESOLUTION ) );
//		return false;
    }

    #ifdef PLAYERS_3D
    AppendIfaceIni( "players3d_chareg.ini" );
    # ifndef PLAYERS_3D_NO_HEAD
    AppendIfaceIni( "players3d_headinv.ini" );
    # endif
    #endif

	AppendIfaceIni( "rp_default.ini" );
	Message( GetMsgStr (TEXTMSG_GAME, STR_INFO_WELCOME_INFO) ); // "Вы можете настроить произвольное разрешение экрана игры в файле FOConfig.exe"
		
	string legacyGUI;
	legacyGUI = GetMsgStr (TEXTMSG_GAME, STR_INFO_WELCOME_LEGACY );
	string newGUI;
	newGUI    = GetMsgStr (TEXTMSG_GAME, STR_INFO_WELCOME_NEW);
	string errorGUI;
	errorGUI  = GetMsgStr (TEXTMSG_GAME, STR_INFO_WELCOME_ERROR);
	
	if( AppendIfaceIni( "rp_default.ini" ) )
    {
        Message( "" + newGUI ); 
    }
    else if ( AppendIfaceIni( "default.ini" ) )
    {
        Message( "" + legacyGUI ); 
    }
	else
	{
		Message ( "" + errorGUI );
	}
	
    GUI_Init();

    InitRadioScreen();
    InitChosenTabs();
	FactionGuiInit();

    // @pm menu
    InitContMenuScreen();
    InitFastPanelScreen();
    InitFastPanelSkillbox();
    InitFastPanelTextbox();
    InitCodedoorScreen();
    InitScreenAddiotional();
    InitTeachScreen();
    InitScreenDoc();
    InitFirstAidScreen();
    InitOptMenuScreen();
    InitInventoryTnfScreen();
    InitScreenInputbox();
    InitClockScreen();
    InitWaypointScreen();

    ExpBarSetPos();

    arrow.resize( 8 );
    arrow[ 0 ].Load( "arrow0.png", int(PT_ART_INTRFACE) );
    arrow[ 1 ].Load( "arrow1.png", int(PT_ART_INTRFACE) );
    arrow[ 2 ].Load( "arrow2.png", int(PT_ART_INTRFACE) );
    arrow[ 3 ].Load( "arrow3.png", int(PT_ART_INTRFACE) );
    arrow[ 4 ].Load( "arrow4.png", int(PT_ART_INTRFACE) );
    arrow[ 5 ].Load( "arrow5.png", int(PT_ART_INTRFACE) );
    arrow[ 6 ].Load( "arrow6.png", int(PT_ART_INTRFACE) );
    arrow[ 7 ].Load( "arrow7.png", int(PT_ART_INTRFACE) );
    // #pm menu
	
	__MouseScroll = true;

    #ifdef PLAYERS_3D
    Init3DChaRegScreen();
    #endif

    __ShowPlayerNames = true;
    __ShowNpcNames = true;
	
	__ShowF1Help = false;
	F1_arrows.Load( "Arrows.png", int(PT_ART) );
	F1_tabs.Load( "Tabs.png", int(PT_ART) );
	F1_text.Load( "Text.png", int(PT_ART) );
	TabPic.LoadByIni( "ChosenTabPic", PT_ART_INTRFACE );

    __global = CONF_GLOB_GRID | CONF_GLOB_WILD;

    Load3dFile( "VbFemaleFat.fo3d", PT_ART_CRITTERS );
    Load3dFile( "VbFemaleNormal.fo3d", PT_ART_CRITTERS );
    Load3dFile( "VbFemaleStrong.fo3d", PT_ART_CRITTERS );
    Load3dFile( "VbFemaleWiry.fo3d", PT_ART_CRITTERS );
    Load3dFile( "VbFemaleSkeleton.fo3d", PT_ART_CRITTERS );
    Load3dFile( "VbMaleFat.fo3d", PT_ART_CRITTERS );
    Load3dFile( "VbMaleNormal.fo3d", PT_ART_CRITTERS );
    Load3dFile( "VbMaleStrong.fo3d", PT_ART_CRITTERS );
    Load3dFile( "VbMaleWiry.fo3d", PT_ART_CRITTERS );
    Load3dFile( "VbMaleSkeleton.fo3d", PT_ART_CRITTERS );
    #endif

    return true;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Main loop function. Returned time of next call in milliseconds.

uint loop_turn = 0;

uint loop()
{
    WASDInputLoop();

    if( __isClockActive )
    {
        MoveHand();
    }

    if( loop_turn % 4 == 0 ) {
        updateAllNicks();
		
		if( !last_radio_message_recieved )
		{
			Message( "|0xFFFFFF " + last_radio_message );
			last_radio_message_recieved = true;
		}
    }

    if( loop_turn % 5 == 0 ) {
        qmap_loop();
    }

    if( loop_turn % 100 == 0 )
    {
        int[] result;
        GUI_GetActiveScreens( result );

        CritterCl@ ch = GetChosen();

        if( !(ch is null) && ( prevId == ch.Id ) && ( ( result.length() > 0 && result[ result.length() - 1 ] == CLIENT_MAIN_SCREEN_GAME ) || ( result.length() > 1 && result[ result.length() - 2 ] == CLIENT_MAIN_SCREEN_GAME ) ) )
        {
            SaveNames();
        }
    }
    loop_turn += 1;
    if( loop_turn > 100 )
        loop_turn = 0;

    return 100;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Say to engine what screens is active.
void get_active_screens( int[]& result )
{
    GUI_GetActiveScreens( result );
}

// Show/hide screen behaviour.
int _MainScreen = CLIENT_SCREEN_NONE;
int _LastMainScreen = CLIENT_SCREEN_NONE;
void screen_change( bool show, int screen, int p0, int p1, int p2 )
{ 
    // qthree: sorry for the trash
    //debug_screen_change(show, screen, p0, p1, p2);
    if ( show ) {
        //если новый экран - основной экран игры или глобал, а последний значимый экран - логин, то подключаемся к оверлею
        if(
            ( screen == CLIENT_MAIN_SCREEN_GAME || screen == CLIENT_MAIN_SCREEN_GLOBAL_MAP ) &&
            ( _LastMainScreen == CLIENT_MAIN_SCREEN_LOGIN || _LastMainScreen == CLIENT_SCREEN_NONE )
        ){
            //Message("BINGO");
            overlay_connect();
            #ifdef PHYSICAL_UI
                PhysicalUI_Reset();
            #endif //PHYSICAL_UI
        }
        //если новый экран - логин, а последний значимый экран - основной игровой или глобал, то отключаемся от оверлея и сбрасываем запомненные имена
        else if ( screen == CLIENT_MAIN_SCREEN_LOGIN && (_LastMainScreen == CLIENT_MAIN_SCREEN_GAME || _LastMainScreen == CLIENT_MAIN_SCREEN_GLOBAL_MAP) ) {
            prevId = 0;
            ClearNameCache();
            overlay_disconnect();
            #ifdef PHYSICAL_UI
                PhysicalUI_Reset();
            #endif //PHYSICAL_UI
        }

        if(screen>=CLIENT_MAIN_SCREEN_LOGIN && screen<=CLIENT_MAIN_SCREEN_WAIT) {
            _MainScreen = screen;
            if(screen != CLIENT_MAIN_SCREEN_WAIT) {
                _LastMainScreen = screen;
            }
        }
    }

// binyan - Hotkeys
    if( screen == CLIENT_SCREEN_SAY || screen == CLIENT_SCREEN_TIMER || screen == CLIENT_SCREEN_INPUT_BOX || screen == CLIENT_SCREEN_SPLIT )
        __IsTextInput = show ? true : false;
// /////////////////////////////////////
    if( show )
        GUI_ShowScreen( screen, p0, p1, p2 );
    else
        GUI_HideScreen( screen, p0, p1, p2 );
}

int[] @ data_color = null;
int[] @ data_number = null;
int[] @ data_char = null;


int[] hive_data;

void SetHiveData( int[] hivedata )
{
    hive_data.resize( 0 );
    for( uint8 i = 0; i < hivedata.length(); i++ )
    {
        hive_data.insertLast( hivedata[ i ] );
    }
}

void _dr( int param0, int param1, int param2, string@ param3, int[] @ param4 ) // draw data
{
    switch( param0 )
    {
    case 1:
        @data_color = param4;
        break;
    case 2:
        @data_number = param4;
        break;
    case 3:
        @data_char = param4;
        break;
    default:
        break;
    }
}

#include "disp_tests.fos"

void render_iface( uint layer )
{
    if( layer == 1 )
    {
        show_player_info();
    }
    else if( layer == 3 )
    {
		DrawChosenTabs();
		GUI_Render();

		if( __sinf & SINF_DISP != 0 )
		{
			if( __ConsoleActive )
			{
				clearLine();
				generateLine( 10, 150 );
				Info_About_Line( __MouseX, __MouseY );
			}
			else
			{
				clearLine();
			}
			
			Draw_Test_Line();
		}
		
		ItemCl @ item = GetMonitorItem( __MouseX, __MouseY );
		if( item !is null )
		{
			if( GetCurrentCursor() == CURSOR_MOVE && item.GetProtoId() >= EXIT_GRID_PID && item.GetProtoId() <= EXIT_GRID_PID + 8 )
			{
				CritterCl @ choo = GetChosen();

				if( ABS( int(choo.HexX - item.HexX) ) <= 16 && ABS( int(choo.HexY - item.HexY) ) <= 16 )
				{

					uint16 hexX = 0, hexY = 0;
					GetMonitorHex( __MouseX, __MouseY, hexX, hexY );
					int value = GetDirection( choo.HexX, choo.HexY, hexX, hexY );

					//Костыли:
					if( value == 0 ) value = 1;
					if( value == 4 || value == 5 ) value = 7;
					if( value == 3 ) value = 5;
					if( value == 2 ) value = 3;
					
					// Message( "Value: " + value );
					int x = 0, y = 0;
					switch( value )
					{
					case 0:
						x = -100;
						y = -80;
						break;
					case 1:
						x = -120;
						y = -110;
						break;
					case 2:
						x = -120;
						y = -120;
						break;
					case 3:
						x = -120;
						y = -100;
						break;
					case 4:
						x = -90;
						y = -110;
						break;
					case 5:
						x = -100;
						y = -110;
						break;
					case 6:
						x = -60;
						y = -125;
						break;
					case 7:
						x = -120;
						y = -120;
						break;
					default:
						break;
					}

					arrow[ value ].Draw( __MouseX + x, __MouseY + y );

					uint localMapPid = choo.StatBase[ ST_LOCALMAP_PID ];

					if( value != choo.StatBase[ ST_LOCALMAP_DIR ] )
						RunServerScriptUnsafe( "globalmap_group@unsafe_GetMapPid", item.HexX, item.HexY, item.GetProtoId(), null, null );

					
						localMapPid++;
					
					string mapName = GetMsgStr( TEXTMSG_GM, localMapPid * 10 + 8 );
					bool isRed = ( mapName == "error" ) || ( localMapPid == 0 );
					if( mapName == "error" ) mapName = "Недоступно";
					DrawText( localMapPid != 0 ? mapName : "Пустошь", __MouseX - ( localMapPid != 0 ? mapName.length() * 7 : 45 ), __MouseY + 20, 400, 20, isRed ? COLOR_RED : COLOR_LGREEN, FONT_BIG, 0 );
				}
			}
        }
        // binyan - Hex attack
        if( __IsHexAttack && GetCurrentCursor() == CURSOR_USE_WEAPON )
        {
			int tohit = to_hit_hex( __ctrlDown );
            if( tohit > 0 )
                DrawText( tohit + "%", __MouseX + 6, __MouseY + 6, ( ( tohit / 10 >= 1 ? 2 : 1 ) + 2 ) * 10, 10, COLOR_RED, FONT_FALLOUT, 0 );
			
			CritterCl@ target = GetMonitorCritter( __MouseX, __MouseY );
			CritterCl@ chosen = GetChosen();
			if( valid( target ) && isGM( chosen ) )
			{
				string sub_info;
				sub_info = target.Stat[ ST_CURRENT_HP ] + " / " + target.Stat[ ST_MAX_LIFE ];
				DrawText( sub_info, __MouseX + 6, __MouseY - 18, sub_info.length() * 10, 10, COLOR_GREEN, FONT_FALLOUT, 0 );
				
				sub_info = target.Stat[ ST_CURRENT_AP ] + " / " + target.Stat[ ST_ACTION_POINTS ];
				DrawText( sub_info, __MouseX + 12, __MouseY - 6, sub_info.length() * 10, 10, COLOR_LBLUE, FONT_FALLOUT, 0 );
			}
        }
        if( __ShowTimeouts )
            show_timeouts();
    }
    else if( layer == 4 )
	{
		//int[] drawData = {0, 0, 0xFFFFFFFF, 5, 5, 0xFFFF00FF};
		//DrawPrimitive( DRAW_PRIMITIVE_LINELIST, drawData );
		//TestDirect3d(0);
	}
    else if( layer == 5 )
    {
        int active_screen = GUI_GetActiveScreen();
        bool show = !__IsTextInput && active_screen == CLIENT_MAIN_SCREEN_GAME; //&& !__ConsoleActive
        //send positions of players' sprites, send empty if gui is active
        overlay_loop(show);
        
        //TestDirect3d(0);
		//DrawText( "d3d draw: "+TestDirect3d(0), 30, 30, 100, 20, COLOR_LGREEN, FONT_FALLOUT, FT_NOBREAK );
    }
    else if( layer == 100 && __GmapActive )
    {
        render_global_map();
    }
}

void render_global_map()
{
    CritterCl@ ch = GetChosen();
    if(ch !is null)
    {
        // Here you can draw on global map

        // bool  __GmapActive - активна ли глобальная карта и все ли следующие нижеприведенные переменные корректны;
        // bool  __GmapWait   - включен режим ожидания ответа о подтверждении энкаунтера;
        // float __GmapZoom   - текущий масштаб, не забывайте учитывать его при рисовании на карте;
        // int   __GmapOffsetX/Y   - смещение карты от нулевой координаты (верхний-левый угол);
        // int   __GmapGroupCurX/Y - координаты группы игрока;
        // int   __GmapGroupToX/Y  - координаты точки назначения;
        // float __GmapGroupSpeed  - текущая скорость передвижения.
        // Для примера, расчет текущего пикселя группы:
        // x = __GmapGroupX / __GmapZoom + __GmapOffsetX, y = __GmapGroupY / __GmapZoom + __GmapOffsetY.

        // SetHivePos(__GmapOffsetX, __GmapOffsetY, 5);
        if( ch.Param[ QST_GAMEMODE ] == GAME_ARCADE )
        {
            // Message(""+hive_data.length());
            for( uint8 i = 0; i < hive_data.length(); i++ )
            {
                int16 x = ( hive_data[ i ] ) & 0x3FF;
                int16 y = ( hive_data[ i ] >> 10 ) & 0x3FF;
                int16 type = ( hive_data[ i ] >> 20 ) & 0xFFF;

                SetHivePos( x / __GmapZoom + __GmapOffsetX, y / __GmapZoom + __GmapOffsetY, x, y, type, i );

                // Message("i "+i+" type "+type+" x "+x+" offX "+__GmapOffsetX+" y "+y+" offY "+__GmapOffsetY);
            }

            // GUI_Render(100);
        }


        int flags = ( FT_NOBREAK | FT_CENTERX | FT_CENTERY | FT_BORDERED ),
            font = FONT_FALLOUT;

        float  size = 10 / __GmapZoom;

        uint16 chx = __GmapGroupCurX / 10, chy = __GmapGroupCurY / 10;

        if( @data_color != null && __global & CONF_GLOB_WILD != 0 )
        {
            uint len = data_color.length();

            if( len > 0 && len % 2 == 0 )
            {
                // int color = 0x44772222;

                int[] drawData( len / 2*18 );

                for( uint i = 0, j = 0; i < len / 2; j++ )
                {
                    float x = ( data_color[ j * 2 ] & 0xFFFF ),
                          y = ( ( data_color[ j * 2 ] >> 16 ) );

                    // if(x0==chx && y0==chy) {len-=2; continue;}

                    x = x * 10 / __GmapZoom + __GmapOffsetX;
                    y = y * 10 / __GmapZoom + __GmapOffsetY;

                    int a = data_color[ j * 2 + 1 ];

                    /*if(a==0x33773333)
                       {
                            len-=2; continue;
                       }*/

                    uint k = i * 18;
                    drawData[ k++ ] = x;
                    drawData[ k++ ] = y;
                    drawData[ k++ ] = a;
                    drawData[ k++ ] = x + size;
                    drawData[ k++ ] = y;
                    drawData[ k++ ] = a;
                    drawData[ k++ ] = x;
                    drawData[ k++ ] = y + size;
                    drawData[ k++ ] = a;
                    drawData[ k++ ] = x;
                    drawData[ k++ ] = y + size;
                    drawData[ k++ ] = a;
                    drawData[ k++ ] = x + size;
                    drawData[ k++ ] = y;
                    drawData[ k++ ] = a;
                    drawData[ k++ ] = x + size;
                    drawData[ k++ ] = y + size;
                    drawData[ k++ ] = a;

                    /*for(uint k=0, p=i*18; k<4; k++)
                       {
                            drawData[p++]=x+size*(k&1);
                            drawData[p++]=y+size*(k>>1);
                            drawData[p++]=a;
                       }*/

                    i++;
                }
                drawData.resize( len / 2 * 18 );
                DrawPrimitive( DRAW_PRIMITIVE_TRIANGLELIST, drawData );
            }
        }

        if( size > 10 && __global & CONF_GLOB_GRID != 0 )
        {
            uint8 alpha = CLAMP( ( size - 5 ) * 20, 0, 0xAA );
            // int r=0x66, g=0xBB, b=0x44;
            int   r = 0x22, g = 0x22, b = 0x22;
            // float t=2/__GmapZoom-2; t=MIN(t, 1);
            // r*=t*t*t; g*=t; b*=t*t*t;
            r = CLAMP( r, 0, 0xFF );
            g = CLAMP( g, 0, 0xFF );
            b = CLAMP( b, 0, 0xFF );
            int   color = ( ( alpha ) << 24 ) | ( r << 16 ) | ( g << 8 ) | ( b );

            float x0 = __GmapOffsetX,
                  y0 = __GmapOffsetY,
                  x = ( ZONE_COUNT_X * ZONE_LENGTH ) / __GmapZoom + __GmapOffsetX,
                  y = ( ZONE_COUNT_Y * ZONE_LENGTH ) / __GmapZoom + __GmapOffsetY;

            uint w = ZONE_COUNT_X * ZONE_LENGTH / 10,
                 h = ZONE_COUNT_Y * ZONE_LENGTH / 10;

            int[] drawData( ( w + h + 2 )*6 );

            for( uint i = 0; i <= h; i++ )
            {
                drawData[ i * 6 ] = x0;
                drawData[ i * 6 + 1 ] = y0 + size * i;
                drawData[ i * 6 + 2 ] = color;
                drawData[ i * 6 + 3 ] = x;
                drawData[ i * 6 + 4 ] = y0 + size * i;
                drawData[ i * 6 + 5 ] = color;
            }
            for( uint j = 0; j <= w; j++ )
            {
                uint i = h + 1 + j;
                drawData[ i * 6 ] = x0 + size * j;
                drawData[ i * 6 + 1 ] = y0;
                drawData[ i * 6 + 2 ] = color;
                drawData[ i * 6 + 3 ] = x0 + size * j;
                drawData[ i * 6 + 4 ] = y;
                drawData[ i * 6 + 5 ] = color;
            }

            DrawPrimitive( DRAW_PRIMITIVE_LINELIST, drawData );
        }

        if( size >= 5 /*&& ((ch !is null and ch.Param[QST_GAMEMODE]==GAME_ARCADE) || __sinf&SINF_GRID!=0 || __sinf&SINF_GLOBAL!=0)*/ )
        {
            float x = ( chx * 10 ) / __GmapZoom + __GmapOffsetX,
                  y = ( chy * 10 ) / __GmapZoom + __GmapOffsetY;

            {
                int color = int( 0xAA00FFFF );

                int[]  drawData = { x + 1, y + 1, color, x + size - 1, y + 1, color, x + size - 1, y + size - 1, color, x + 1, y + size - 1, color, x + 1, y + 1, color };
                DrawPrimitive( DRAW_PRIMITIVE_LINESTRIP, drawData );
            }
        }

        if( @data_number != null )
        {
            uint len = data_number.length();

            if( len > 0 && len % 2 != 1 )
            {
                for( uint i = 0; i < len / 2; i++ )
                {
                    float x = ( data_number[ i * 2 ] & 0xFFFF ),
                          y = ( ( data_number[ i * 2 ] >> 16 ) );

                    x = x * 10 / __GmapZoom + __GmapOffsetX;
                    y = y * 10 / __GmapZoom + __GmapOffsetY;
                    int a = data_number[ i * 2 + 1 ] & 0xFFFF,
                        b = data_number[ i * 2 + 1 ] >> 16;
                    ;
                    // if(x<0 || y<0 || x>)
                    string str = a;
                    if( b > 0 )
                        str += "+" + ( b - a );

                    {
                        uint8 alpha = MIN( ( 2000.0f / size ), 0x88 );
                        int   color = 0x00FFAA00 | ( ( alpha ) << 24 );

                        int[]  drawData = { x + 1, y + 1, color, x + size - 1, y + 1, color, x + 1, y + size - 1, color, x + size - 1, y + size - 1, color };
                        DrawPrimitive( DRAW_PRIMITIVE_TRIANGLESTRIP, drawData );
                    }
                    int tw = 0, th = 0, lines = 0;
                    GetTextInfo( str, 0, 0, font, flags, tw, th, lines );
                    DrawText( str, x - ( tw >> 1 ), y - ( tw >> 1 ), size + tw, size + tw, 0xFF22AAFF, font, flags );
                }
            }
        }

        if( @data_char != null )
        {
            uint len = data_char.length();

            if( len > 0 && len % 2 != 1 )
            {
                for( uint i = 0; i < len / 2; i++ )
                {
                    float x = ( data_char[ i * 2 ] & 0xFFFF ),
                          y = ( ( data_char[ i * 2 ] >> 16 ) );

                    x = x * 10 / __GmapZoom + __GmapOffsetX;
                    y = y * 10 / __GmapZoom + __GmapOffsetY;
                    uint a = ( data_char[ i * 2 + 1 ] & 0x00FFFFFF ) | 0xFF000000,
                         b = data_char[ i * 2 + 1 ] >> 24;

                    string str = " ";
                    str[ 0 ] = b;

                    int tw = 0, th = 0, lines = 0;
                    GetTextInfo( str, 0, 0, font, flags, tw, th, lines );
                    DrawText( str, x - ( tw >> 1 ), y - ( tw >> 1 ), size + tw, size + tw, a, font, flags );
                }
            }
        }

        {
            float x = ( __MouseX - __GmapOffsetX ) * __GmapZoom,
                  y = ( __MouseY - __GmapOffsetY ) * __GmapZoom;

            x -= x % 10;
            y -= y % 10;

            string str = floor( x / 10 ) + " : " + floor( y / 10 );

            x = x / __GmapZoom + __GmapOffsetX;
            y = y / __GmapZoom + __GmapOffsetY;

            if( size >= 5 )
            {
                int[]  drawData = { x + 1, y + 1, int( COLOR_RED ), x + size - 1, y + 1, int( COLOR_RED ), x + size - 1, y + size - 1, int( COLOR_RED ), x + 1, y + size - 1, int( COLOR_RED ), x + 1, y + 1, int( COLOR_RED ) };
                DrawPrimitive( DRAW_PRIMITIVE_LINESTRIP, drawData );
            }

            int tw = 0, th = 0, lines = 0;

            GetTextInfo( str, 0, 0, font, FT_NOBREAK, tw, th, lines );
            DrawText( str, __MouseX + 30, __MouseY + 10, tw, th, COLOR_LGREEN, font, FT_NOBREAK );
        }
    }
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Render map function. You can use DrawMap* functions only there. This drawing before 1 iface layer.
void render_map()
{
    DrawMapTiles();
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Mouse behaviours. Click states look in _client_defines.fos, Mouse click states.
// Return true to disable engine events.
bool mouse_down( int click )
{ 
    return GUI_MouseDown( click, __MouseX, __MouseY );
}

bool mouse_up( int click )
{
    return GUI_MouseUp( click, __MouseX, __MouseY );
}

void mouse_move( int x, int y )
{
    // x == __MouseX
    // y == __MouseY
    GUI_MouseMove( x, y );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Keyboard behaviours. Key codes look in _client_defines.fos DirectInput keyboard scan codes.
// Return true to disable engine events.
bool AltDown = false;
bool key_down( uint8 key )
{
    if (WASDInputKeyState(key, true)) {
        return true;
    }

    if(__ctrlDown && key == DIK_O) {
        //show or hide overlay
        overlay_visibility();
        return true;
    }
    if( __ConsoleActive )
	{
		CritterCl@ ch = GetChosen();
		if( valid(ch) )
		{
			if( key != DIK_RETURN )
			{
				if( ch.Param[CR_TYPING_TIME] < int( __FullSecond + __TypingDelay ) ) 
					RunServerScriptUnsafe( "rp_chat@unsafe_ShowTyping", 0, 0, 0, null, null );
			}
			else
			{
				if( ch.Param[CR_TYPING_TIME] > int( __FullSecond + __TypingDelay ) )
					RunServerScriptUnsafe( "rp_chat@unsafe_stopTyping", 0, 0, 0, null, null );
			}
		}
	} 

    if( __waiting )
    {
        CritterCl@ ch = GetChosen();
        if( @ch != null )
        {
            if(__ConsoleActive) 
			{
				bool key_disallowed = (key == DIK_ESCAPE);
                return key_disallowed;
            } else  {
                if( key == DIK_RETURN ) {
                    __ConsoleActive = true;
                    return true;
                }
            }

            if( key == DIK_ESCAPE || key == DIK_SPACE )
            {
                RunServerScriptUnsafe( "ltp@unsafe_StopProcess",  0, 0, 0, null, null );
            }
            return true;
        }
        else
            __waiting = false;
    }

    // Effect example, temporary
    if( key == DIK_LMENU || key == DIK_RMENU )
        AltDown = true;

    if( key == DIK_LCONTROL || key == DIK_RCONTROL )
        __ctrlDown = true;

    if( key == DIK_Z )
        __MapZooming = true;
    
	if( GUI_KeyDown( key ) ) {
		// Hotkey consumed
		return true;
	} else {
		// disable hardcoded date and time hotkey
		if( key == DIK_SLASH && _MainScreen==CLIENT_MAIN_SCREEN_GAME && !__ConsoleActive && !__IsTextInput && !__ctrlDown && !AltDown ) {
			RunServerScriptUnsafe( "main@unsafe_getIngameTime", -1, 0, 0, null, null );
			return true;
		}
	}
    return false;
}

bool key_up( uint8 key )
{
    if (WASDInputKeyState(key, false)) {
        return true;
    }

    if( key == DIK_LMENU || key == DIK_RMENU )
        AltDown = false;
    if( key == DIK_LCONTROL || key == DIK_RCONTROL )
        __ctrlDown = false;   

    if( __waiting )
        return !__ConsoleActive;

    if( key == DIK_Z )
        __MapZooming = false;

    return GUI_KeyUp( key );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on mouse/keyboard input lost (alt-tab, minimize, lost focus).
void input_lost()
{
    AltDown = false;
    __ctrlDown = false;
    __MapZooming = false;

    GUI_InputLost();
}

import void __seeTyping( int x, int y, int info, string@ text, int[]@ ) from "rp_client";
// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on something critter in/out game.
void critter_in( CritterCl& cr )
{
    CritterCl@ ch = GetChosen();
    if( !(ch is null) && ( ch.Id == cr.Id ) && ( prevId != cr.Id ) )
    {
        @data_number = null;
        @data_color = null;
        @data_char = null;
        LoadNames();
        prevId = cr.Id;
    }

    updateNick( cr );

    // Default colors
    cr.NameColor = COLOR_CRITTER_NAME;
    cr.ContourColor = ( cr.IsPlayer() ? COLOR_CONTOUR_YELLOW : COLOR_CONTOUR_RED );
    if( cr.Param[ QST_GAMEMODE ] == GAME_ARCADE )
        cr.ContourColor = COLOR_CONTOUR_RED;

    if( __fastPanel )
        HidePanel( true );
    // SaveFastPanel(false); //@pm menu
}

void critter_out( CritterCl& cr )
{}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on something item in/changed/out map.
void item_map_in( ItemCl& item )
{
    #ifndef PHYSICAL_UI
        iList().add( item );
    #endif //PHYSICAL_UI
}

void item_map_changed( ItemCl& itemNow, ItemCl& itemBefore )
{
    #ifndef PHYSICAL_UI
	    iList().change( itemNow, itemBefore );
    #endif //PHYSICAL_UI
}

void item_map_out( ItemCl& item )
{
    #ifndef PHYSICAL_UI
	    iList().remove( item );
    #endif //PHYSICAL_UI
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on something critter in/out chosen inventory.
void item_inv_in( ItemCl& item )
{

}

void item_inv_out( ItemCl& item )
{

}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on player drag&drop some item.
void item_drop( ItemCl& item )
{

}

string last_radio_message = "";
bool last_radio_message_recieved = true;
// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on receive message on map.
import bool MapMessage(string& message, uint16& hexX, uint16& hexY, uint& color, uint& delay) from "chat";

// By default delay == [TextDelay + message length * 100] ms
bool map_message( string& message, uint16& hexX, uint16& hexY, uint& color, uint& delay )
{
    if (message == "") return false;

    // Detect radio
    if( color == 0xFFFFFFFE )
	{
        MapMessage(message, hexX, hexY, color, delay);
        message = ".." + message + "..";
		
		if( last_radio_message.length() != message.length() && findFirst( last_radio_message, message ) == -1 )
		{
			if( !last_radio_message_recieved ) {
				Message( "|0xFFFFFF " + last_radio_message );
            }
			else
				last_radio_message_recieved = false;

			last_radio_message = message;
		}
	}
		
	if( color == COLOR_GRAY )
        Message("|0x8F8F8F " + message );

	if( color == COLOR_LGRAY )
        Message("|0xD3D3D3 " + message );
		
	if( color == COLOR_TEXT || color == COLOR_CHAT_SHOUT)
	{
		//AutoEmotes( message );
        MapMessage(message, hexX, hexY, color, delay);
		Message( "???: " + message );
	}

    if (message == "") return false;

	return true;
}


void AutoEmotes( string& message )
{
	if( findFirst( message, "*" ) != -1 )
	{
		uint countfirst = findFirst( message, "*" );
		if( findFirst( message, "*", countfirst ) != -1 )
		{
			while (findFirst( message, "**", 0 ) != -1)
			{
				message = ReplaceText(message, "**", "*");
			}
			string@[] strs;
			strs = split( message, "*" );
			for(uint i = 1; i < strs.length(); ++i )
			{
                if( strs[ i ].length() > 0) {
                    strs[ i ] = "|0xFFBB33CC **" + strs[ i ] + "**|0xF8F993 ";
                }
				++i;
			}
			message = join( strs, "" );
		}
	}
}


// //////////////////////////////////////////////////////////////////////////////////////////////////
import bool InMessage(string& message, int& sayType, uint& senderCritterID, uint& delay) from "chat";

// Call on receive message.
// By default delay == [TextDelay + message length * 100] ms
bool in_message( string& message, int& sayType, uint& critterId, uint& delay )
{
    if (message == "") return false;

    if( sayType > SAY_RADIO ) { return true; }

    if (!InMessage(message, sayType, critterId, delay)) {
        return false;
    }

	CritterCl@ receiver = GetChosen();

    //send message to overlay, for logging and avatar position adjustment
    overlay_message(message, sayType, critterId, delay);
	
    if( sayType == SAY_RADIO )
	{
		if( last_radio_message.length() != message.length() && findFirst( last_radio_message, message ) == -1 )
		{
			last_radio_message = ".." + message + "..";
			//last_radio_message_recieved = false;
		}
		else
			last_radio_message_recieved = true;
		
        return true;                          // for work radio and service messages
	}

    if( ( __sinf & SINF_CRID_CHAT ) != 0 && critterId != 0 && sayType <= SAY_WHISP_ON_HEAD )
    {
        message = "[" + critterId + "] " + message;
    }
    if( ( __sinf & SINF_INSIGHT ) != 0 )
        return true;

	return true;
	
	//Временно отключил языковой барьер между разновидовыми существами.
	//in_message_language_barrier( message, sayType, critterId, delay );
}

bool in_message_language_barrier( string& message, int& sayType, uint& critterId, uint& delay )
{
    // binyan - Language barrier
    CritterCl@ sender = GetCritter( critterId );
    if( sender is null )
        return false;

    if( sender.IsNpc() )
        return true;

    CritterCl@ receiver = GetChosen();
    if( !(receiver is null) && receiver.Param[ QST_MEDIUM ] == 0 && sender.Param[ QST_MEDIUM ] == 0 )
    {
        int bs = sender.Stat[ ST_BODY_TYPE ];
        int br = receiver.Stat[ ST_BODY_TYPE ];
        if( message.length() > 1 )
        {
            if( ( bs == br && bs != BT_PLANT ) ||
                ( ( ( bs >= BT_MEN && bs < BT_BRAHMIN ) || bs == BT_ROBOT || bs == BT_BIG_BAD_BOSS ) && ( ( br >= BT_MEN && br < BT_BRAHMIN ) || br == BT_ROBOT || br == BT_BIG_BAD_BOSS ) ) ||
                ( ( bs == BT_MANTI || bs == BT_RADSCORPION || bs == BT_GIANT_ANT || bs == BT_GIANT_BEETLE || bs == BT_GIANT_WASP ) && ( br == BT_MANTI || br == BT_RADSCORPION || br == BT_GIANT_ANT || br == BT_GIANT_BEETLE || br == BT_GIANT_WASP || br == BT_YAO) ) )
                return true;
        }

		sayType = SAY_EMOTE;
		switch( bs )
		{
		case BT_MEN:
			message = "Говорит";
			break;
		case BT_WOMEN:
			message = "Говорит";
			break;
		case BT_CHILDREN:
			message = "Говорит";
			break;
		case BT_SUPER_MUTANT:
			message = "Говорит";
			break;
		case BT_GHOUL:
			message = "Говорит";
			break;
		case BT_BRAHMIN:
			message = "Мычит";
			break;
		case BT_RADSCORPION:
			message = "Щелкает клешнями";
			break;
		case BT_RAT:
			message = "Пищит";
			break;
		case BT_FLOATER:
			message = "Хрипение";
			break;
		case BT_CENTAUR:
			message = "Хрипение";
			break;
		case BT_ROBOT:
			message = "Попикивает";
			break;
		case BT_DOG:
			message = "Лает";
			break;
		case BT_MANTI:
			message = "Стрекочет";
			break;
		case BT_DEADCLAW:
			message = "Рычит";
			break;
		case BT_PLANT:
			message = "";
			break;
		case BT_GECKO:
			message = "Шипит";
			break;
		case BT_ALIEN:
			message = "Хрипит";
			break;
		case BT_GIANT_ANT:
			message = "Стрекочет";
			break;
		case BT_BIG_BAD_BOSS:
			message = "Говорит";
			break;
		case BT_GIANT_BEETLE:
			message = "Стрекочет";
			break;
		case BT_GIANT_WASP:
			message = "Жужит";
			break;
		case BT_YAO:
			message = "Рычит";
			break;
		case MAX_BODY_TYPES:
			message = "";
			break;
		}
    }
    return true;
}

import void DrawHives( uint8 hiveCount ) from "client_screen_additional";

// //////////////////////////////////////////////////////////////////////////////////////////////////
import bool OutMessage(string& message, int& sayType) from "chat";

// Call on send message.
bool out_message( string& message, int& sayType )
{
    if (message == "") return false;
	bool result = OutMessage(message, sayType);
    if (message == "") return false;
    return result;
}

bool out_command( string& message, int& sayType )
{
	
    if( __MessagePrefix != "" )
    {
        message = __MessagePrefix + " " + message;
        __MessagePrefix = "";
    }

    if( __IsHotkeysUse )
        __IsTextInput = true;

    if( findFirst( message, "~hotkeys" ) == 0 )
    {
        string@[] @ msg = split( message, " " );
        if( msg.length() == 1 )
            Message( "Hotkeys use is now " + ( __IsHotkeysUse ? "on" : "off" ) );
        else
        {
            if( msg[ 1 ] == "on" )
                SetHotkeysUse( true );
            else if( msg[ 1 ] == "off" )
                SetHotkeysUse( false );

            if( __IsHotkeysUse )
                __IsTextInput = true;
            ;

            Message( "Hotkeys use is now " + ( __IsHotkeysUse ? "on" : "off" ) );
        }
        return false;
    }
    // /////////////////////////////////////////////


    if( message[ 0 ] == '%' ) // Command
	{
		string@[] @ valuesStr = splitEx( message, " " );
		int p0 = 0, p1 = 2, p2 = 6;
		if( valuesStr.length() == 2 ) 
		{
			if( !StrToInt( valuesStr[ 1 ], p0 ) )
			{
				string[] letters = { "S", "P", "E", "C", "I", "A", "L" };
				p0 = letters.find( valuesStr[ 1 ] ) + 1;
			}
		}
		if( valuesStr.length() == 3 ) 
		{
			StrToInt( valuesStr[ 1 ], p1 );
			StrToInt( valuesStr[ 2 ], p2 );
		}
		
		CritterCl@ chosen = GetChosen();
		CritterCl@ target = GetMonitorCritter( __MouseX, __MouseY );
		if( isGM( chosen ) && valid( target ) )
		{
			int[] vals = { p0, p1, p2, target.Id };
			RunServerScriptUnsafe( "test@unsafe_rolling_GM", 0, 0, 0, null, vals );
			return false;
		}
		RunServerScriptUnsafe( "test@unsafe_rolling", p0, p1, p2, null, null );
		return false;
	}
	
	if( message[ 0 ] == '~' ) // Command
    {
		if( findFirst( message, "~ilex" ) != -1 )
		{
			CritterCl@ chosen = GetChosen();
			if( !chosen.IsLife() ) return false;
			
			ItemCl@ hand = _CritGetItemHand( chosen );
			if( !valid( hand ) ) return false;
			
			string current_lexem = hand.Lexems;
			string new_lexem = "";
			
			if( message.length() > 5 )
				new_lexem = substring( message, 6, message.length() - 6 );
			
			if( new_lexem.length() != 0 )
				new_lexem = current_lexem + new_lexem;
			
			RunServerScriptUnsafe( "test@unsafe_addLexem", 0, 0, 0, new_lexem, null );
			return false;
		}
		
		if( message == "~toglobal" )
		{
            RunServerScriptUnsafe( "test@unsafe_toglobal", 0, 0, 0, null, null );
            return false;
		} 
		
		if( message == "~suicide" )
        {
            RunServerScriptUnsafe( "suicide@unsafe_killself", 0, 0, 0, "", null );
            return false;
        }
		
		if( message == "~naked" )
		{
            RunServerScriptUnsafe( "map_start@unsafe_getNaked", 0, 0, 0, "", null );
            return false;
		}
		
         if( message == "~gmhot" )
        {
            __mobhotkeys = ( __mobhotkeys ? false : true );
            Message( "mobhotkeys : " + ( __mobhotkeys ? "On" : "Off" ) );
            return false;
        }

		string@[]@ parts = split( message, " " );

		if( parts[0] == "~desc" ) 
		{
			uint16 hexX = 0, hexY = 0;
			CritterCl @ choo = GetChosen();
			GetMonitorHex( __MouseX, __MouseY, hexX, hexY );

			string text = "";
			int l = parts[0].length();
			if( parts.length() > 1 && message.length() > 5) text = substring( message, 5, message.length() - 5 );
			RunServerScriptUnsafe( "general_unsafe@unsafe_newPopup", hexX, hexY, 0, text, null ); 
			return false; 
		}
			
		if( parts[0] == "~lex" ) 
		{
			string text = "";
			if( parts.length() > 1 && message.length() > 5 ) text = substring( message, 5, message.length() - 5 );
			RunServerScriptUnsafe( "general_unsafe@unsafe_selfLex", 0, 0, 0, text, null ); 
			return false; 
		}

		if( message == "~sf" )
        {
            RunServerScriptUnsafe( "general_unsafe@unsafe_sleep", 1, 0, 0, "", null );
            return false;
        }

        if( message == "~sb" )
        {
            RunServerScriptUnsafe( "general_unsafe@unsafe_sleep", 0, 0, 0, "", null );
            return false;
        }

        if( message == "~mobhot" )
        {
            __usermobhotkeys = ( __usermobhotkeys ? false : true );
            Message( "mobhotkeys : " + ( __usermobhotkeys ? "On" : "Off" ) );
            return false;
        }
		
		if( message == "~faction")
		{
			ShowScreen( CLIENT_SCREEN_FACTION, 0, 0, 0 );
			Message("show faction");
			return false;
		}		
        return true;
    }

    if( message[ 0 ] == '#' || message[ 0 ] == '%' || message[ 0 ] == '$' ) // tnf commands
    {
		CritterCl @target = GetMonitorCritter( __MouseX, __MouseY );
		string targetInfo = valid( target ) ? "[" + target.Name + " #" + target.Id + "]" : "";
        RunServerScriptUnsafe("general_unsafe@unsafe_log", 0, 0, 0, GetChosen().Name + " #" + GetChosen().Id + " " + targetInfo + " - " + message, null);
        return gm_msg(message);
    }

    Message("Команда не найдена.");
    return false;
}

bool out_speak( string& message, int& sayType )
{
    CritterCl@ chosen = GetChosen();
	ItemCl@ gagItem = _CritGetItemHead( chosen );
	
    if( chosen !is null and sayType< SAY_NETMSG and chosen.IsDead() and chosen.Anim2Dead > ANIM2_DEAD_BACK )
    {
        Message( "Мертвые не разговаривают." );
        return false;
    }

    //Проверка на то, что в сообщении есть что-либо кроме пробелов.
	bool result = false;
    for( uint i = 0, j = message.length(); i < j; i++ )
    {
        if( message[ i ] != ' ' )
        {
            result = true;
            break;
        }
    }
	if( result == false ) return false;

  	//Шаманская прослушка-в-рацию.
    if (chosen !is null && (SAY_NORM == sayType || SAY_SHOUT == sayType || SAY_WHISP == sayType || SAY_RADIO == sayType)) {
        RunServerScriptUnsafe("radio@unsafe_OutMessage", sayType, 0, 0, message, null);
    }
	
	switch( sayType )
	{
		case( SAY_NORM ): 	
		case( SAY_EMOTE ): 	
		case( SAY_SOCIAL ):	//<- Этот тип речи используется для "разового" серого текста под курсор.
			//Просто "нормально" обрабатывает эти типы речи, ничего дополнительно с ними не делая.
			break;
			
		case( SAY_WHISP ):	RunServerScriptUnsafe( "rp_chat@unsafe_GM_Hear_Whisper", 0, 0, 0, message, null );	break;
		case( SAY_SHOUT ):	RunServerScriptUnsafe( "rp_chat@unsafe_shout_all", 0, 0, 0, message, null); break;
		case( SAY_RADIO ): {
			RunServerScriptUnsafe( "general_unsafe@unsafe_radioHead", 0, 0, 0, message, null );
			RunServerScriptUnsafe( "rp_chat@unsafe_GM_Hear_Radio", 0, 0, 0, message, null ); 
			RunServerScriptUnsafe( "rp_chat@unsafe_GM_Hear_Whisper", 0, 0, 0, message, null );//TODO: Дублируется-ли текст шёпота ГМам?
		break; }
		
		default: Message( "Unhandled sayType: " + sayType ); return false;
	}

	//Серый текст и возможность говорить за целевое существо:
	if( sayType != SAY_RADIO && ( chosen.StatBase[ ST_FOLLOW_CRIT ] != 0 || sayType == SAY_SOCIAL ) )
	{
		uint16 hexX = 0, hexY = 0;
		GetMonitorHex( __MouseX, __MouseY, hexX, hexY );
		RunServerScriptUnsafe( "rp_chat@unsafe_SayChatMessage", sayType, hexX, hexY, message, null );
		return false; //Не отсылает сообщение стандартными методами, скрипт перехватывает управление.
	}

	//На стороне сервера записывает данные в SayLog.txt
	RunServerScriptUnsafe( "rp_chat@unsafe_SayLog", sayType, 0, 0, message, null );

	if( chosen.IsKnockout() && sayType < SAY_SOCIAL ) 
	{
		RunServerScriptUnsafe( "mio_social@unsafe_KnockSay", sayType, 0, 0, message, null ); 
		return false; 
	}

	return true;
}

bool to_hit_hex_enable()
{
    // Used only on empty hex and throwing weapon and rocket launchers
    CritterCl@ chosen = GetChosen();
    if( !chosen.IsLife() )
        return false;
	
    CritterCl@ target = GetMonitorCritter( __MouseX, __MouseY );
    if( valid( target ) ) //Для этого есть другие обработчики.
        return false;
	
    uint16 tx = 0, ty = 0;
    GetMonitorHex( __MouseX, __MouseY, tx, ty );
    if( tx == 0 && ty == 0 )
        return false;
	
	ItemCl@ item = GetMonitorItem( __MouseX, __MouseY );
	if( valid( item ) && ( item.HexX != tx && item.HexY != ty ) )
		return false;
	
	return true;
}

// binyan - Hex attack
int to_hit_hex( bool anyway )
{
	if( !anyway && !to_hit_hex_enable() )
		return 0;
	
	CritterCl@ chosen = GetChosen();

	CritterCl@ target = GetMonitorCritter( __MouseX, __MouseY );

    uint16 tx = 0, ty = 0;
    GetMonitorHex( __MouseX, __MouseY, tx, ty );

	ItemCl@ item = GetMonitorItem( __MouseX, __MouseY );
	
    ItemCl@ realWeapon = _CritGetItemHand( chosen );

    uint8      mode = 0;
    ProtoItem@ weapon = chosen.GetSlotProto( SLOT_HAND1, mode );
    if( !valid( weapon ) && valid( realWeapon ) )
        @weapon = GetProtoItem( realWeapon.GetProtoId() ); //хз, почему оно не принимало дефолтный `realWeapon.Proto`

	if( weapon is null )
		return 0;

    uint    skillNum = _WeaponSkill( weapon, mode );
    int     dmgType = _WeaponDmgType( weapon, mode );

    bool    isFlareGun = valid( realWeapon ) && ( realWeapon.AmmoPid == PID_FLARE_GUN_AMMO ) && ( _WeaponModeUse( mode ) == 1 ); // pm added flare gun check
    bool    isRocket = valid( realWeapon ) && ( ( realWeapon.AmmoPid == PID_EXPLOSIVE_ROCKET ) || ( realWeapon.AmmoPid == PID_ROCKET_AP ) || ( realWeapon.AmmoPid == PID_ROBO_ROCKET_AMMO ) || ( realWeapon.AmmoPid == PID_GRENADELAUNCHER_AMMO ) );

    int    dist = GetDistantion( chosen.HexX, chosen.HexY, tx, ty );
	
    uint16 toHx = tx, toHy = ty;
    GetHexCoord( chosen.HexX,  chosen.HexY, toHx, toHy,  0.0f, dist );
    if( ( tx != toHx ) || ( ty != toHy ) )
        return 0;

    int wpnMaxDist = _WeaponMaxDist( weapon, mode );
    if( skillNum == SK_THROWING )
        wpnMaxDist = MIN( wpnMaxDist, 3 * MIN( int(10), chosen.Stat[ ST_STRENGTH ] ) );
        //wpnMaxDist = MIN( wpnMaxDist, 3 * MIN( int(10), chosen.Stat[ ST_STRENGTH ] + 2 * chosen.Perk[ PE_HEAVE_HO ] ) );

    if( dist > wpnMaxDist )
        return 0;

    int use = _WeaponModeUse( mode );

	uint8 weaponSubtype = ( skillNum == SK_SMALL_GUNS || skillNum == SK_BIG_GUNS || skillNum == SK_ENERGY_WEAPONS ) ? WS_GUN : ( ( skillNum == SK_THROWING ) ? WS_THROWING : ( skillNum == SK_MELEE_WEAPONS ) ? WS_MELEE : WS_UNARMED );

    int toHit = getFullSkill( chosen, null, skillNum, weaponSubtype ) - chosen.Param[ ST_PARALYSIS_LEVEL ] * 3 + 2 * _WeaponMaxDist( weapon, use ) - chosen.Param[ ST_DRUNK ];
    int weaponPerk = weapon.Weapon_Perk;
    int blockers = 0;


    int distmod1 = 2; // used for initial weapon bonus
    int distmod2 = 0; // minimal distance
    if( weaponPerk == WEAPON_PERK_LONG_RANGE )
        distmod1 = 4;
    else if( weaponPerk == WEAPON_PERK_SCOPE_RANGE )
    {
        distmod1 = 5;
        distmod2 = 8;
    }

    int perception = chosen.Stat[ ST_PERCEPTION ];
    int acc = dist;

    if( dist < distmod2 )
        acc += distmod2;
    else
    {
        if( chosen.IsPlayer() )
            acc -= ( perception - 2 ) * distmod1;            // we want to keep it, because fo2238 might use it to display NPCs chance (via possessing)
        else
            acc -= perception * distmod1;
    }

    if( -2 * perception > acc )
        acc = -2 * perception;

    //acc -= 2 * chosen.Perk[ PE_SHARPSHOOTER ];

    if( acc >= 0 )
    {
        if( chosen.Damage[ DAMAGE_EYE ] != 0 )
            acc *= -12;
        else
            acc *= -4;
    }
    else
        acc *= -4;

    toHit += acc;
    blockers = GetCrittersPath( chosen.HexX, chosen.HexY, tx, ty, 0.0f, dist, FIND_LIFE, null ); // + map
    toHit -= 10 * blockers;

    if( chosen.Trait[ TRAIT_ONE_HANDER ] != 0 )
        toHit += ( FLAG( weapon.Flags, ITEM_TWO_HANDS ) ? -40 : 20 );

    int handlingStrength = chosen.Stat[ ST_STRENGTH ];
    int reqStrength = weapon.Weapon_MinStrength;
    // if( chosen.Perk[ PE_WEAPON_HANDLING ] != 0 )
        // handlingStrength += 3;
    if( handlingStrength < reqStrength )
        toHit -= ( reqStrength - handlingStrength ) * 20;
    if( weaponPerk == WEAPON_PERK_ACCURATE )
        toHit += 20;

	int aim = _WeaponModeAim( mode );
	if( aim == HIT_LOCATION_NONE && _WeaponAim( weapon, mode & 0x0F ) )
		aim = chosen.ParamBase[CR_AUTO_AIM];

    uint16 ammoRound = _WeaponRound( weapon, use );
	bool isBurst = ammoRound > 1;
	if( isBurst )
		aim = HIT_LOCATION_UNCALLED;
	
    int hitMod = GetHitAim( aim );
    if( skillNum == SK_MELEE_WEAPONS || skillNum == SK_UNARMED )
        hitMod /= 2;
    toHit -= hitMod;

    if( chosen.Damage[ DAMAGE_EYE ] != 0 )
        toHit -= 25;
    toHit = CLAMP( toHit, 5, 95 );

    return toHit;

}
// //////////////////////////////////////////////////////////////////////////////////////////////////

int getFullSkill( CritterCl& cr, CritterCl@ target, int skillNum, uint8 weaponSubtype )
{
    int   skillVal = cr.Skill[ skillNum ];

    if( cr.IsPlayer() )
    {
        if( weaponSubtype == WS_GUN )
        {
            // Log("Тип оружия - стрелковое. Используется " + skillNum + " скилл (200 - лёгкое, 201 - тяжелое, 202 - энерго)");
            // Log("Скилл стреляющего " + skillVal + ", а номер скилла - " + skillNum);
            if( skillNum == SK_SMALL_GUNS && skillVal < SECONDARY_SKILLS_BONUS_CAP )
            {
                // Log("Скилл для текущего оружия - лёгкое оружие, навык криттера - " + cr.Skill[skillNum]);
                skillVal += cr.Skill[ SK_BIG_GUNS ] / 3;
                // Log("Добавляем скилл тяжелого оружия, поделенный на 3, к вычислению, теперь скилл " + skillVal);
                skillVal += cr.Skill[ SK_ENERGY_WEAPONS ] / 2;
                // Log("Добавляем энергооружие, поделенное на 2, к вычислению, теперь скилл " + skillVal);
                if( skillVal > SECONDARY_SKILLS_BONUS_CAP )
                {
                    skillVal = SECONDARY_SKILLS_BONUS_CAP;                                          /* Log("Устанавливаем кап на " + SECONDARY_SKILLS_BONUS_CAP +", чтобы не получалось слишком круто. Значение после установки - " + skillVal); */
                }
                // Log("Итоговый скилл для рассчётов " + skillVal);
            }

            if( skillNum == SK_BIG_GUNS && skillVal < SECONDARY_SKILLS_BONUS_CAP )
            {
                // Log("Скилл для текущего оружия - тяжелое оружие, навык криттера - " + cr.Skill[skillNum]);
                skillVal += cr.Skill[ SK_SMALL_GUNS ] / 3;
                // Log("Добавляем скилл лёгкого оружия, поделенный на 3, к вычислению, теперь скилл " + skillVal);
                skillVal += cr.Skill[ SK_ENERGY_WEAPONS ] / 3;
                // Log("Добавляем энергооружие, поделенное на 3, к вычислению, теперь скилл " + skillVal);
                if( skillVal > SECONDARY_SKILLS_BONUS_CAP )
                {
                    skillVal = SECONDARY_SKILLS_BONUS_CAP;                                          /* Log("Устанавливаем кап на " + SECONDARY_SKILLS_BONUS_CAP +", чтобы не получалось слишком круто. Значение после установки - " + skillVal); */
                }
                // Log("Итоговый скилл для рассчётов " + skillVal);
            }

            if( skillNum == SK_ENERGY_WEAPONS && skillVal < SECONDARY_SKILLS_BONUS_CAP )
            {
                // Log("Скилл для текущего оружия - энергетическое оружие, навык криттера - " + cr.Skill[skillNum]);
                skillVal += cr.Skill[ SK_SMALL_GUNS ] / 2;
                // Log("Добавляем скилл лёгкого оружия, поделенный на 2, к вычислению, теперь скилл " + skillVal);
                skillVal += cr.Skill[ SK_BIG_GUNS ] / 3;
                // Log("Добавляем скилл тяжелого оружия, поделенный на 3, к вычислению, теперь скилл " + skillVal);
                if( skillVal > SECONDARY_SKILLS_BONUS_CAP )
                {
                    skillVal = SECONDARY_SKILLS_BONUS_CAP;                                          /* Log("Устанавливаем кап на " + SECONDARY_SKILLS_BONUS_CAP +", чтобы не получалось слишком круто. Значение после установки - " + skillVal); */
                }
                // Log("Итоговый скилл для рассчётов " + skillVal);
            }
        }
        else
        {
            // Log("Тип оружия - нестрелковое. Используется " + skillNum + " скилл (203 - рукопашка, 204 - холодное, 205 - метательное)");
            if( skillNum == SK_UNARMED && skillVal < SECONDARY_SKILLS_BONUS_CAP )
            {
                skillVal += cr.Skill[ SK_THROWING ] / 3;
                skillVal += cr.Skill[ SK_MELEE_WEAPONS ] / 2;
                if( skillVal > SECONDARY_SKILLS_BONUS_CAP )
                    skillVal = SECONDARY_SKILLS_BONUS_CAP;
            }

            if( skillNum == SK_MELEE_WEAPONS && skillVal < SECONDARY_SKILLS_BONUS_CAP )
            {
                skillVal += cr.Skill[ SK_UNARMED ] / 2;
                skillVal += cr.Skill[ SK_THROWING ] / 3;
                if( skillVal > SECONDARY_SKILLS_BONUS_CAP )
                    skillVal = SECONDARY_SKILLS_BONUS_CAP;
            }

            if( skillNum == SK_THROWING && skillVal < SECONDARY_SKILLS_BONUS_CAP )
            {
                skillVal += cr.Skill[ SK_UNARMED ] / 3;
                skillVal += cr.Skill[ SK_MELEE_WEAPONS ] / 2;
                if( skillVal > SECONDARY_SKILLS_BONUS_CAP )
                    skillVal = SECONDARY_SKILLS_BONUS_CAP;
            }
        }
    }
    // Roleplay

	if( cr.IsPlayer() && valid( target ) && target.IsPlayer() )
	{
		/*
		Если [маньяк, обычный, мирный] хочешь БЕЗ ШТРАФА
		 атаковать:  маньяка, обычного, мирного
		1) маньяк:   всегда,   всегда, цель в бою
		2) обычный:  всегда,    в бою, цель в бою
		3) мирный:    в бою,    в бою, ты и цель в бою
		*/
		//Если вне боя, и ты мирный, и вы оба НЕ маньяки..
		if( ( cr.Timeout[ TO_BATTLE ] == 0 && ( cr.Trait[ TRAIT_GOOD_NATURED ] != 0 || ( cr.Trait[ TRAIT_BLOODY_MESS ] == 0  && target.Trait[ TRAIT_BLOODY_MESS ] == 0 ) ) ) 
			|| ( target.Trait[ TRAIT_GOOD_NATURED ] != 0 && target.Timeout[ TO_BATTLE ] == 0 ) ) { //Либо цель - мирный НЕ в бою.
			skillVal /= 2; //Навык делим пополам.
		}
	}
	
	return skillVal;
}
// To-hit chance.
int to_hit( CritterCl& chosen, CritterCl& target, ProtoItem& weapon, uint8 weaponMode )
{
    int hitLocation = _WeaponModeAim( weaponMode );
	if( hitLocation == HIT_LOCATION_NONE && _WeaponAim( weapon, weaponMode & 0x0F ) )
		hitLocation = chosen.ParamBase[CR_AUTO_AIM];
	
    int use = _WeaponModeUse( weaponMode );
    uint16 ammoRound = _WeaponRound( weapon, use );
	bool isBurst = ammoRound > 1;
	if( isBurst )
		hitLocation = HIT_LOCATION_UNCALLED;
	
    if( use > 2 )
        return 0;

    if( target.IsDead() )
        return 0;
    if( !chosen.IsLife() )
        return 0;

    ItemCl@    realWeapon = _CritGetItemHand( chosen );
    ProtoItem@ ammo = null;

    if( valid( realWeapon ) && _WeaponRound( weapon, use ) > 0 )
    {
        if( realWeapon.AmmoCount == 0 )
            return 0;
        @ammo = GetProtoItem( realWeapon.AmmoPid );
    }

    uint skillNum = _WeaponSkill( weapon, use );
	
	uint8 weaponSubtype = ( skillNum == SK_SMALL_GUNS || skillNum == SK_BIG_GUNS || skillNum == SK_ENERGY_WEAPONS ) ? WS_GUN : ( ( skillNum == SK_THROWING ) ? WS_THROWING : ( skillNum == SK_MELEE_WEAPONS ) ? WS_MELEE : WS_UNARMED );
	
    int  skillVal = getFullSkill( chosen, target, skillNum, weaponSubtype ) - chosen.Param[ ST_PARALYSIS_LEVEL ] * 3 + 2 * _WeaponMaxDist( weapon, use )-  chosen.Param[ ST_DRUNK ];
    int  wpnMaxDist = _WeaponMaxDist( weapon, use );

    // Roleplay
    int dist = GetCrittersDistantion( chosen, target );
    if( dist > wpnMaxDist )
        return 0;

    int toHit = skillVal;
    int weaponPerk = weapon.Weapon_Perk;
    int blockers = 0;

    if( skillNum != SK_UNARMED && skillNum != SK_MELEE_WEAPONS )
    {
        // cr.Say(SAY_NETMSG, "Applying range modifiers.");
        // ranged attack modifiers
        int distmod1 = 2; // used for initial weapon bonus
        int distmod2 = 0; // minimal distance
        if( weaponPerk == WEAPON_PERK_LONG_RANGE )
            distmod1 = 4;
        else if( weaponPerk == WEAPON_PERK_SCOPE_RANGE )
        {
            distmod1 = 5;
            distmod2 = 8;
        }

        int perception = chosen.Stat[ ST_PERCEPTION ];
        int acc = dist;

        if( dist < distmod2 )
            acc += distmod2;
        else
        {
            if( chosen.IsPlayer() )
                acc -= ( perception - 2 ) * distmod1;            // we want to keep it, because fo2238 might use it to display NPCs chance (via possessing)
            else
                acc -= perception * distmod1;
        }

        if( -2 * perception > acc )
            acc = -2 * perception;

        //acc -= 2 * chosen.Perk[ PE_SHARPSHOOTER ];

        if( acc >= 0 )
        {
            if( chosen.Damage[ DAMAGE_EYE ] != 0 )
                acc *= -12;
            else
                acc *= -4;
        }
        else
            acc *= -4;

        toHit += acc;

        // Map@ map = chosen.GetMap();
        blockers = GetCrittersPath( chosen.HexX, chosen.HexY, target.HexX, target.HexY, 0.0f, dist, FIND_LIFE, null ); // + map
        if( !target.IsKnockout() )
            blockers--;
        toHit -= 10 * blockers;
    } // end range modifiers

    if( !( weapon.Weapon_IsUnarmed ) && chosen.Trait[ TRAIT_ONE_HANDER ] != 0 && valid( realWeapon ) )
        toHit += ( FLAG( weapon.Flags, ITEM_TWO_HANDS ) ? -40 : 20 );

    int handlingStrength = chosen.Stat[ ST_STRENGTH ];
    int reqStrength = weapon.Weapon_MinStrength;
    // if( chosen.Perk[ PE_WEAPON_HANDLING ] != 0 )
        // handlingStrength += 3;
    if( handlingStrength < reqStrength )
        toHit -= ( reqStrength - handlingStrength ) * 20;
    if( weaponPerk == WEAPON_PERK_ACCURATE )
        toHit += 20;

    int acmod = target.Stat[ ST_ARMOR_CLASS ];
    if( valid( ammo ) )
        acmod += ammo.Ammo_AcMod;
    if( acmod > 0 )
        toHit -= acmod;
    // TODO: tohit+=15 if target is multihex
    // TODO: light penalty

    if( chosen.Damage[ DAMAGE_EYE ] != 0 )
        toHit -= 25;
    if( target.IsKnockout() )
        toHit += 40;
    toHit += target.GetMultihex() * 15;

    int hitMod = GetHitAim( hitLocation );
    if( skillNum == SK_MELEE_WEAPONS || skillNum == SK_UNARMED )
        hitMod /= 2;
    toHit -= hitMod;
	
	if( valid(target) && target.IsBusy() )
	{
		if( ( chosen.Dir + 3 ) % 6 == target.Dir )
			toHit += 20;
		else if( ( chosen.Dir ) % 6 != target.Dir )
		{
			toHit -= acmod / 2;
			if( hitLocation == HIT_LOCATION_HEAD )
				toHit -= acmod / 2;
		}
	}
	// advanced aiming
	if( hitLocation == HIT_LOCATION_HEAD )
		toHit *= 0.5;
	else if( hitLocation == HIT_LOCATION_LEFT_ARM || hitLocation == HIT_LOCATION_RIGHT_ARM || hitLocation == HIT_LOCATION_RIGHT_LEG || hitLocation == HIT_LOCATION_LEFT_LEG )
		toHit *= 0.7;

    toHit = CLAMP( toHit, 5, 95 );

    return toHit;
}

uint GetHitAim( int hitLocation )
{
    switch( hitLocation )
    {
    case HIT_LOCATION_NONE:
        break;
    case HIT_LOCATION_UNCALLED:
        break;
    case HIT_LOCATION_TORSO:
        return __HitAimTorso;
    case HIT_LOCATION_EYES:
        return __HitAimEyes;
    case HIT_LOCATION_HEAD:
        return __HitAimHead;
    case HIT_LOCATION_LEFT_ARM:
    case HIT_LOCATION_RIGHT_ARM:
        return __HitAimArms;
    case HIT_LOCATION_GROIN:
        return __HitAimGroin;
    case HIT_LOCATION_RIGHT_LEG:
    case HIT_LOCATION_LEFT_LEG:
        return __HitAimLegs;
    default:
        break;
    }
    return 0;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Override aim location set by player through targetting screen or simple click on target.
void hit_aim( uint8& aim )
{}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Combat results.
void combat_result( uint[]& data )
{
    CritterCl@ chosen = GetChosen();

	testInfo( CR_TEST_MODE_COMBAT, "Data: " + enlistUINT(data) );

    uint datalen = data.length();
    if( datalen == 0 )
        return;
    if( data[ 0 ] != datalen )
        return;

    uint current = 1;

    while( current < datalen )
    {
        int        damage = -1;
        uint       effect = 0;
        uint       loc = 0;
        int        message = -1;

        uint       mode = data[ current++ ];
        uint       who = data[ current++ ];
        uint       who2;
        CritterCl@ originalTarget;

        CritterCl@ cr = GetCritter( who );
        CritterCl@ trueTarget = null;

        bool       self = ( who == GetChosen().Id );
		
		bool isDead = true;

        string     name = "error0";
        if( valid( cr ) )
        {
            if( !self )
                name = cr.Name;
            else
                name = GetMsgStr( TEXTMSG_COMBAT, chosen.Stat[ ST_GENDER ] == GENDER_MALE ? 506 : 556 );
			
			isDead = !cr.IsPlayer();
        }

        uint offset;
        if( self )
        {
            if( cr.Stat[ ST_GENDER ] == GENDER_MALE )
                offset = 506;
            else
                offset = 556;
        }
        else
        {
            if( cr.Stat[ ST_GENDER ] == GENDER_MALE )
                offset = 606;
            else if( cr.Stat[ ST_GENDER ] == GENDER_FEMALE )
                offset = 656;
			else
				offset = 706;
        }

        string result;

        // reading and preparing the data:
        switch( mode )
        {
        case CMSG_CRIT_MISS:
            effect = data[ current++ ];
            result = GetMsgStr( TEXTMSG_COMBAT, offset + 8 );
            result = ReplaceText( result, "%s", name );
            break;
        case CMSG_CRIT_MISS_DAMAGE:
            effect = data[ current++ ];
            damage = data[ current++ ];
            result = GetMsgStr( TEXTMSG_COMBAT, offset + ( damage > 1 ? 28 : 27 ) );
            result = ReplaceText( result, "%s", name );
            if( damage > 1 )
                result = ReplaceText( result, "%d", damage );
            break;
        case CMSG_HIT:
        case CMSG_HIT_DEAD:
            damage = data[ current++ ];
            result = GetMsgStr( TEXTMSG_COMBAT, offset + ( damage > 1 ? 7 : ( damage != 0 ? 17 : 21 ) ) );
			
            result = ReplaceText( result, "%s", name );
            if( damage > 1 )
                result = ReplaceText( result, "%d", damage );
            break;
        case CMSG_AIMED_HIT:
        case CMSG_AIMED_HIT_DEAD:
            loc = data[ current++ ];
            damage = data[ current++ ];
            result = GetMsgStr( TEXTMSG_COMBAT, offset + ( damage > 1 ? 6 : ( damage != 0 ? 16 : 20 ) ) );
            result = ReplaceText( result, "%s", name );
            result = ReplaceText( result, "%s", GetMsgStr( TEXTMSG_COMBAT, 1000 + cr.CrTypeAlias * 10 + loc - 1 ) );

            if( damage > 1 )
                result = ReplaceText( result, "%d", damage );
            break;
        case CMSG_CRIT_HIT:
            damage = data[ current++ ];
            effect = data[ current++ ];
            message = data[ current++ ];
            result = GetMsgStr( TEXTMSG_COMBAT, offset + ( damage > 1 ? 14 : ( damage != 0 ? 18 : 22 ) ) );
            result = ReplaceText( result, "%s", name );
            if( damage > 1 )
                result = ReplaceText( result, "%d", damage );
            break;
        case CMSG_CRIT_AIMED_HIT:
            loc = data[ current++ ];
            damage = data[ current++ ];
            effect = data[ current++ ];
            message = data[ current++ ];
            result = GetMsgStr( TEXTMSG_COMBAT, offset + ( damage > 1 ? 5 : ( damage != 0 ? 15 : 19 ) ) );
            result = ReplaceText( result, "%s", name );
            result = ReplaceText( result, "%s", GetMsgStr( TEXTMSG_COMBAT, 1000 + cr.CrTypeAlias * 10 + loc - 1 ) );
            if( damage > 1 )
                result = ReplaceText( result, "%d", damage );
            break;
        case CMSG_CRIT_HIT_DEAD:
            damage = data[ current++ ];
            message = data[ current++ ];
            result = GetMsgStr( TEXTMSG_COMBAT, offset + ( damage > 1 ? 14 : ( damage != 0 ? 18 : 22 ) ) );
            result = ReplaceText( result, "%s", name );
            if( damage > 1 )
                result = ReplaceText( result, "%d", damage );
            break;
        case CMSG_CRIT_AIMED_HIT_DEAD:
            loc = data[ current++ ];
            damage = data[ current++ ];
            message = data[ current++ ];
            result = GetMsgStr( TEXTMSG_COMBAT, offset + ( damage > 1 ? 5 : ( damage != 0 ? 15 : 19 ) ) );
            result = ReplaceText( result, "%s", name );
            result = ReplaceText( result, "%s", GetMsgStr( TEXTMSG_COMBAT, 1000 + cr.CrTypeAlias * 10 + loc - 1 ) );
            if( damage > 1 )
                result = ReplaceText( result, "%d", damage );
            break;
        case CMSG_OOPS:
            who2 = data[ current++ ]; // who2 was hit instead of who
            // +2 "... was hit instead of you!"
            // +3 "... was hit instead of ...!"
            @trueTarget = GetCritter( who2 );
            if( self )
            {
                // It was original target
                uint gender_info = CLAMP( cr.Stat[ ST_GENDER ], GENDER_MALE, GENDER_IT ) * 100;
				result = GetMsgStr( TEXTMSG_COMBAT, 608 + gender_info );
                string nameTrue = "error1";
                if( valid( trueTarget ) )
                    nameTrue = trueTarget.Name;
                result = ReplaceText( result, "%s", nameTrue );
            }
            else
            {
                // It was not original target
                result = GetMsgStr( TEXTMSG_COMBAT, offset + 3 );
                if( who2 == GetChosen().Id )
                {
                    result = ReplaceText( result, "%s", GetMsgStr( TEXTMSG_COMBAT, chosen.Stat[ ST_GENDER ] == GENDER_MALE ? 506 : 556 ) );
                }
                else
                {
                    string nameTrue = "error1";
                    if( valid( trueTarget ) )
                        nameTrue = trueTarget.Name;
                    result = ReplaceText( result, "%s", nameTrue );
                }
                result = ReplaceText( result, "%s", name );
            }
            break;
        case CMSG_MISS:
            result = GetMsgStr( TEXTMSG_COMBAT, offset + 9 );
            result = ReplaceText( result, "%s", name );
            break;
        case CMSG_HIT_RANDOMLY:
            result = GetMsgStr( TEXTMSG_COMBAT, offset + 9 );
            result = ReplaceText( result, "%s", name );
            result += GetMsgStr( TEXTMSG_COMBAT, 108 ) + GetMsgStr( TEXTMSG_COMBAT, offset - 306 + 20 );
        default:
            break;
        }

        bool isVerbose = ( __CombatMessagesType == 0 );
        string@[] ext;
		uint[] exts;

        if( message != -1 && isVerbose )       // Must be critical hit
        {
            result += GetMsgStr( TEXTMSG_COMBAT, message );
        }
        else if( effect != 0 )
        {
            offset -= 306;
            if( mode > CMSG_CRIT_MISS_DAMAGE )           // Hit flags
            {
				uint[] flags = { HF_KNOCKOUT, HF_KNOCKDOWN, HF_CRIPPLED_LEFT_LEG, HF_CRIPPLED_RIGHT_LEG, HF_CRIPPLED_LEFT_ARM, HF_CRIPPLED_RIGHT_ARM, HF_BLINDED, 
									0, 0, 0, 0, HF_BYPASS_ARMOR, 0, 0, HF_DROPPED_WEAPON, HF_LOST_NEXT_TURN, 0, 0, 0, 0, 0, HF_RANDOM };
				
				for( uint x = 0, l = flags.length(); x < l; x++ )
					if( flags[x] != 0 && FLAG( effect, flags[x] ) )
					{ 
						ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + x ) ); 
						exts.insertLast( offset + x ); 
					}
            }
            else
            {
				uint[] flags = { 0, MF_KNOCKED_DOWN, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, MF_WEAPON_EXPLODED, MF_WEAPON_DESTROYED, MF_WEAPON_DROPPED, MF_LOST_NEXT_TURN, 
									MF_HIT_SELF, MF_LOST_REST_OF_AMMO, MF_FIRED_DUD_SHOT, MF_HURT_SELF, 0, MF_CRIPPLED_RANDOM_LIMB };
				
				for( uint x = 0, l = flags.length(); x < l; x++ )
					if( flags[x] != 0 && FLAG( effect, flags[x] ) )
					{ 
						ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + x ) ); 
						exts.insertLast( offset + x ); 
					}

                if( FLAG( effect, MF_WAS_KILLED ) )
				{
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + ( isDead ? 7 : 0 ) ) );
					exts.insertLast( offset + ( isDead ? 7 : 0 ) );
				}
            }
            offset += 306;
        }

		if( 8 <= mode && mode <= 11 && ( !isVerbose || message == -1 ) )
		{
            ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + ( isDead ? 7 : 0 ) - 306 ) );
			exts.insertLast( offset + ( isDead ? 7 : 0 ) - 306 );
		}

		testInfo( CR_TEST_MODE_COMBAT, "Ext.length = " + ext.length() );

        for( uint m = 0, n = ext.length(); m < n; m++ )
        {
            if( m == n - 1 )
                result += GetMsgStr( TEXTMSG_COMBAT, 108 );
            else
                result += ", ";

            result += valid( ext[m] ) ? ext[m] : "[" + m + "#" + exts[m] + "]" ;
			
			testInfo( CR_TEST_MODE_COMBAT, "#" + m + ":" + exts[m] + ": " + checkNull(ext[m]) + ";" );
        }

        result += ".";

		bool MyHit = chosen.Id == data[++current]; current++;
        Message( ( MyHit ? "|0xF5D742 " : "" ) + result, FOMB_COMBAT_RESULT );

        if( 8 <= mode && mode <= 11 && isVerbose && message != -1 )
            Message( name + " " + GetMsgStr( TEXTMSG_COMBAT, offset + ( isDead ? 7 : 0 ) - 306 ) + ".", FOMB_COMBAT_RESULT );

        // On head indication
        if( __DamageHitDelay > 0 && damage > 0 )
            MapMessage( "-" + damage, cr.HexX, cr.HexY, __DamageHitDelay, 0xFFC80000, true, Random( -5, 5 ), -20 );
	}
}

string generic_description_slot( ItemCl@ item )
{
	CritterCl@ chosen = GetChosen();
	string result = "-----------------------\n";
	
	if( !valid( item ) )
	{
		uint8      mode = 0;
		int bonus = chosen.Stat[ ST_MELEE_DAMAGE ];
		ProtoItem@ unarmed = chosen.GetSlotProto( SLOT_HAND1, mode );
		result += GetMsgStr( TEXTMSG_GAME, STR_INV_NO_ITEM ) + "\n";
		result += GetMsgStr( TEXTMSG_GAME, STR_INV_UNARMED_DMG ) + " ";
		result += ( _WeaponDmgMin( unarmed, _WeaponModeUse( mode ) ) + bonus ) + "-";
		result += ( _WeaponDmgMax( unarmed, _WeaponModeUse( mode ) ) + bonus ) + "\n";
		result += "\n\n";
		
		return result;
	}
	
	int use = _WeaponModeUse( item.Mode );
	if( use > 2 )
		use = 0;

	result += itemText( item, 150 ) + ".\n";

	if( item.GetType() != ITEM_TYPE_WEAPON )
	{
		if( item.GetCount() > 1 ) {
			result += "В руке: " + item.GetCount() + " предметов.";
		}
		
		return result + "\n\n\n";
	}

	bool isAmmoRegen = ( item.GetProtoId() == PID_SOLAR_SCORCHER ) || ( item.GetProtoId() == PID_SUN ) || ( item.GetProtoId() == PID_SUN2 ) || ( item.GetProtoId() == PID_SUN3 )
						|| ( item.GetProtoId() == PID_FIRE_GECKO_FLAME_WEAPON ) || ( item.GetProtoId() == PID_FIREBREATH );
	uint DmgMult = 1;
	uint DmgDiv = 1;
	uint16 AmmoProto = 0;
	uint16 ammoRound = _WeaponRound( item.Proto, use );
	bool isBurst = ammoRound > 1;
	uint16 AmmoPid;
	
	if( item.Proto.Weapon_MaxAmmoCount > 0 ) {
		
		if( !isAmmoRegen ) {
			ProtoItem@ AmmoProto = GetProtoItem( item.AmmoPid  );
			if( valid ( AmmoProto ) ) {
				DmgMult = AmmoProto.Ammo_DmgMult;
				DmgDiv = AmmoProto.Ammo_DmgDiv;
			}
		}
	}
	
	int bonus = 0;
	uint skill = _WeaponSkill( item.Proto, use );
	
	if( skill == SK_UNARMED || skill == SK_MELEE_WEAPONS ) {
		bonus = chosen.Stat[ ST_MELEE_DAMAGE ];
	}
	
	uint8 weapon_Subtype = item.Proto.Item_Subtype;
	if( skill == SK_THROWING && ( weapon_Subtype == ITEM_SUBTYPE_WEAPON_GRENADE_PRIM || weapon_Subtype == ITEM_SUBTYPE_WEAPON_GRENADE_KIFE ) ) {
        bonus = chosen.Stat[ ST_MELEE_DAMAGE ] / 2;
	}
	
	result += GetMsgStr( TEXTMSG_GAME, STR_INV_DMG ) + " ";
	result += ( ( _WeaponDmgMin( item.Proto, use ) + bonus ) * DmgMult / DmgDiv ) + "-";
	
	if( isBurst ) { 
        string column = "" +  ( ( _WeaponDmgMax( item.Proto, use ) + bonus ) * DmgMult / DmgDiv );
        while ( column.length() < 5 ) column += " ";
        result += column + " Очередь: x" + ammoRound + "\n";
    } else {
        result += ( ( _WeaponDmgMax( item.Proto, use ) + bonus ) * DmgMult / DmgDiv ) + "\n";
    }
		
	if( _WeaponMaxDist( item.Proto, use ) > 1 )
	{
		result += GetMsgStr( TEXTMSG_GAME, STR_INV_DIST ) + " ";
		
		int wpnMaxDist = _WeaponMaxDist( item.Proto, use );
		if( skill == SK_THROWING ) {
			wpnMaxDist = MIN( wpnMaxDist, 3 * MIN( int(10), chosen.Stat[ ST_STRENGTH ] ) );
		}
		result += wpnMaxDist;
		
		if( skill == SK_THROWING && ( weapon_Subtype == ITEM_SUBTYPE_WEAPON_GRENADE_PRIM || weapon_Subtype == ITEM_SUBTYPE_WEAPON_GRENADE_KIFE ) ) {
			result += "\n";
		}
	}
	
	if( _GetWeaponBlastRadius( item.Proto ) > 0 ) {
		result += ". Радиус: " + item.Proto.Blast_Radius + "\n";
	}

	
	if( item.Proto.Weapon_MaxAmmoCount > 0 )
	{
		if( !isAmmoRegen ) {
			ProtoItem@ AmmoProto = GetProtoItem( item.AmmoPid  );
			if( _GetAmmoBlastRadius( AmmoProto ) > 0 ) {
				result += ". Радиус: " + AmmoProto.Blast_Radius;
			}
		}
		
		result += "\n";
		result += GetMsgStr( TEXTMSG_GAME, STR_INV_AMMO ) + " ";
		result += item.AmmoCount + "/" + item.Proto.Weapon_MaxAmmoCount + " ";
		
		if( !isAmmoRegen ) {
			AmmoPid = item.AmmoPid;
			result += _GetAmmoShortDisc( AmmoPid );
		} else {
			result += "аккумулятор.";
		}
	}
	else if( item.GetCount() > 1 ) {
		result += "В руке: " + item.GetCount()+ " шт.";
	}
		
	result += "\n";
	
	return result;
}

#define DESCRIPTION_DEFAULT_DELAY	( 33 )
int[] description_tick_delays = { 0, 0, 0, 0 };
string[] generic_descriptions = { "DESC_INVENTORY_MAIN", "DESC_INVENTORY_SPECIAL", "DESC_INVENTORY_STATS", "DESC_INVENTORY_RESIST" };

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Generic description. Descriptions type look in _client_defines.fos, Generic descriptions types.
// int& offsX, int& offsY - offsets of text, by default is zero.
string generic_description( int descType, int& offsX, int& offsY )
{
	
    CritterCl@ chosen = GetChosen();
    if( not valid( chosen ) || descType < 0 || descType >= int(generic_descriptions.length()) )
        return "";

	//Message( "" + description_tick_delays[descType] );//DEBUG ONLY
	
	if( description_tick_delays[descType] <= 0 )
	{
		description_tick_delays[descType] = DESCRIPTION_DEFAULT_DELAY;
		generic_descriptions[descType] = update_generic_description( descType );
	}
	else
	{
		description_tick_delays[descType]--;
	}

	update_generic_description_offsets( descType, offsX, offsY );
	return generic_descriptions[descType];
}

void update_generic_description_offsets( int descType, int& offsX, int& offsY )
{
	switch( descType )
	{
		case( DESC_INVENTORY_MAIN ): 				break;
		case( DESC_INVENTORY_SPECIAL ): offsX = 23; break;
		case( DESC_INVENTORY_STATS ): 	offsX = -8;	break;
		case( DESC_INVENTORY_RESIST ): 	offsX = 35; offsY = 110; break;
	}
}

string update_generic_description( int descType )
{
	CritterCl@ chosen = GetChosen();
	
	string result;

    if( descType == DESC_INVENTORY_MAIN )
    {
        result += chosen.Name + "\n";
        result += "-----------------------\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_SHORT_SPECIAL( ST_STRENGTH ) ) + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_SHORT_SPECIAL( ST_PERCEPTION ) ) + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_SHORT_SPECIAL( ST_ENDURANCE ) ) + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_SHORT_SPECIAL( ST_CHARISMA ) ) + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_SHORT_SPECIAL( ST_INTELLECT ) ) + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_SHORT_SPECIAL( ST_AGILITY ) ) + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_SHORT_SPECIAL( ST_LUCK ) ) + "\n";
		result += "\n\n\n\n\n\n\n\n"; // FoRP Inventory 2020 adjustment

		result += generic_description_slot( _CritGetItemHand(chosen) );
		result += generic_description_slot( _CritGetItemHandExt(chosen) );
	
		// Additional slots
        result += "\n\n\n Доп. экипировка:\n";
		result += "-----------------------\n";
		
		ItemCl@ headwear = _CritGetItemHead(chosen);
		if( valid( headwear ) ) { 
			result += itemText( headwear, 150 ) + ".\n";
			//result += "" + GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( headwear ) + 1 ) + ".\n";
        } else { result += "Слот головы пуст\n";
		}
		result += "\n\n\n-----------------------\n";
		
		ItemCl@ backpack = _CritGetItemBack(chosen);
		if( valid( backpack ) ) { 
			result += itemText( backpack, 150 ) + ".\n";
			//result += "" + GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( backpack ) + 1 ) + "\n";
		} else { result += "Слот рюкзака пуст\n";
		}
		result += "\n\n\n-----------------------\n";
		
		ItemCl@ misc = _CritGetItemMisc(chosen);
		if( valid( misc ) ) { 
			result += itemText( misc, 150 ) + ".\n";
			//result += "" + GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( misc ) + 1 ) + "\n";
        } else { result += "Утилитарный слот пуст\n";
		}
		//result += "\n\n\n-----------------------";
		// Weight & Volume panel
        /*result += GetMsgStr( TEXTMSG_GAME, STR_INV_TOTAL_WEIGHT ) + " ";
        float current_weight = chosen.ItemsWeight() / 1000.0;
		result += current_weight + "/";
		float max_weight = chosen.Stat[ ST_CARRY_WEIGHT ] / 1000.0;
        result += max_weight + " кг.";*/ //
    }
	
    if( descType == DESC_INVENTORY_SPECIAL )
    {
        result += "\n\n";
        result += chosen.Stat[ ST_STRENGTH ] + "\n";
        result += chosen.Stat[ ST_PERCEPTION ] + "\n";
        result += chosen.Stat[ ST_ENDURANCE ] + "\n";
        result += chosen.Stat[ ST_CHARISMA ] + "\n";
        result += chosen.Stat[ ST_INTELLECT ] + "\n";
        result += chosen.Stat[ ST_AGILITY ] + "\n";
        result += chosen.Stat[ ST_LUCK ];
    }
	
    if( descType == DESC_INVENTORY_STATS )
    {
        result += "\n\n";
		// Hit Points
        result += "                "  + GetMsgStr( TEXTMSG_GAME, STR_INV_HP ) + " ";
        result += chosen.Stat[ ST_CURRENT_HP ] + "/" + chosen.Stat[ ST_MAX_LIFE ] + "\n";
		// AP Regen
		string apregen = GetMsgStr( TEXTMSG_GAME, STR_INV_APREGEN );
		string thatap = "" + floor(chosen.Stat[ ST_APREGEN ]/100.0f) + "." + (chosen.Stat[ ST_APREGEN ] % 100);
		
        float current_weight = cutLesserDigits( chosen.Param[ CR_ITEMS_WEIGHT ] / 1000.0 );
		float max_weight = cutLesserDigits( chosen.Stat[ ST_CARRY_WEIGHT ] / 1000.0 );
		string current_volume = chosen.ItemsVolume();
		// Armor Class
		string arclass = GetMsgStr( TEXTMSG_GAME, STR_INV_AC );
		string thatac = "" + (chosen.Stat[ ST_ARMOR_CLASS ]);
		result += "                " + ReplaceText(arclass, "VALUE", thatac)  + "\n";
		// String calls
		result += "                " + ReplaceText(apregen, "VALUE", thatap)  + "\n"; // Action Points Renegeration
		result += "                " + "Общий вес:\n" + "                " + current_weight + " / " + max_weight + " кг.\n";
		result += "                " + "Объем вещей:\n" + "                " + current_volume + " / " + "1000\n";
		// Resistance type names
		result += "  -----------------------\n";
		
		ItemCl@ armor = _CritGetItemArmor(chosen);
		if( valid( armor ) ) { result += "  " + itemText( armor, 150 ) + ":\n";
        } else { result += "  Без брони: \n";
		}
		result += ""   + GetMsgStr( TEXTMSG_GAME, STR_INV_NORMAL )     + "\n";
        result += ""   + GetMsgStr( TEXTMSG_GAME, STR_INV_LASER )      + "\n";
        result += ""   + GetMsgStr( TEXTMSG_GAME, STR_INV_FIRE )       + "\n";
        result += ""   + GetMsgStr( TEXTMSG_GAME, STR_INV_PLASMA )     + "\n";
        result += ""   + GetMsgStr( TEXTMSG_GAME, STR_INV_EXPLODE )    + "\n";
		result += "  " + GetMsgStr( TEXTMSG_GAME, STR_INV_ELECTRO );
    }
	
    if( descType == DESC_INVENTORY_RESIST )
    {
        result += "      " + chosen.Stat[ ST_NORMAL_ABSORB ]  + "/" + chosen.Stat[ ST_NORMAL_RESIST ]  + "%\n";
        result += "      " + chosen.Stat[ ST_LASER_ABSORB ]   + "/" + chosen.Stat[ ST_LASER_RESIST ]   + "%\n";
        result += "      " + chosen.Stat[ ST_FIRE_ABSORB ]    + "/" + chosen.Stat[ ST_FIRE_RESIST ]    + "%\n";
        result += "      " + chosen.Stat[ ST_PLASMA_ABSORB ]  + "/" + chosen.Stat[ ST_PLASMA_RESIST ]  + "%\n";
        result += "      " + chosen.Stat[ ST_EXPLODE_ABSORB ] + "/" + chosen.Stat[ ST_EXPLODE_RESIST ] + "%\n";
		result += "      " + chosen.Stat[ ST_ELECTRO_ABSORB ] + "/" + chosen.Stat[ ST_ELECTRO_RESIST ] + "%";
    }

    return result;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Item description. Look types look in _client_defines.fos, Item look types.
string item_description( ItemCl& item, int lookType )
{
	RunServerScriptUnsafe( "general_unsafe@unsafe_mark_last_checked_item", item.Id, lookType, 0, null, null ); //Фича для GM-панели.

	if( FLAG( GetChosen().Param[MIO_FLAGS], MIO_FLAG_SHOW_HINTS ) )
	{
		if( item.Accessory == ACCESSORY_HEX && lookType == ITEM_LOOK_ONLY_NAME )
		{
			//__look_details = 0;
			return "";
		}
		
		//NOTE: В будущем можно будет сделать так что бы каждый следующий клик выводил более полную информацию о цели:
		// if( item.Accessory == ACCESSORY_HEX && __last_look_id != item.Id )
		// {
			// __last_look_id = item.Id;
			
			// lookType = __look_details;
			//__look_details++;
		// }
	}

	if( item.Info != 0 )
	{
		if( item.Val9 == PID_POPUP )
			return "" + item.Lexems;
		
		if( item.Info == 11 )
		{
			//return "" + lookType;
			
			if( lookType == ITEM_LOOK_ONLY_NAME )
			{
				string text = GetMsgStr( TEXTMSG_GAME, 110000 + item.Val9 );
				text = ReplaceText( text, "STATE", GetMsgStr( TEXTMSG_GAME, 120000 + item.Val0 ) );
				text = ReplaceText( text, "NAME",  itemColor( item ) + GetMsgStr( TEXTMSG_ITEM, item.Val1 * 100 ) + COLOR_NETMSG );
				text = ReplaceText( text, "VALUE", GetMsgStr( TEXTMSG_GAME, 130000 + item.Val3 ) );
				return text;
			}
			else
			{
				string text = GetMsgStr( TEXTMSG_GAME, 110000 + item.Val9 + 1 );
				text = ReplaceText( text, "DESC", GetMsgStr( TEXTMSG_GAME, 140000 + item.Val4 ) );
				return text;
			}
		}
	}

	CritterCl@ chosen = GetChosen();
    // Default error text
    if( not IsMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item ) + ( lookType != ITEM_LOOK_ONLY_NAME ? 1 : 0 ) ) )
        return GetMsgStr( TEXTMSG_GAME, STR_ITEM_LOOK_NOTHING );

    string result;

    // Car on world map
    if( lookType == ITEM_LOOK_WM_CAR )
    {
        string fuel = GetMsgStr( TEXTMSG_GAME, STR_INV_CAR_FUEL );
        fuel = ReplaceText( fuel, "VALUE",     item.Charge / 100 );
        fuel = ReplaceText( fuel, "MAX_VALUE", item.Proto.Car_TankVolume / 100 );
        string deterioration = GetMsgStr( TEXTMSG_GAME, STR_INV_CAR_DETERIORATION );
        deterioration = ReplaceText( deterioration, "VALUE", item.Deterioration * 100 / item.Proto.Car_MaxDeterioration );
        result = fuel + "\n" + deterioration;
    }
    // Short info
    else if( lookType == ITEM_LOOK_ONLY_NAME )
    {
        result += ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_ITEM_LOOK ), "NAME", itemColor( item ) + GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item ) ) + COLOR_NETMSG );
        if( item.Lexems != "" )
        {
            string lex = "" + item.Lexems;
            for( uint i = 0, len = lex.length(); i < len; i++ )
            {
                uint8 chr = lex[ i ];
                if( chr == 36 )
                {
                    lex = "";
                    break;
                }
            }
            if( lex != "" )
                result += " " + lex;
        }
        if( ( ( __sinf & SINF_ITEMID ) != 0 ) && item.GetType() > 1 && item.GetType() < 13 )
        {
            result += " |0xffff0000 id: " + item.Id + " pid: " + item.GetProtoId();
        }
    }
    // Full info
    else
    {
        if( lookType == ITEM_LOOK_INVENTORY )
            result += GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item ) ) + "\n-----------------------\n";

        if( item.GetProtoId() == PID_HOLODISK && item.HolodiskNumber != 0 )
            result += GetMsgStr( TEXTMSG_HOLO, STR_HOLO_INFO_NAME( item.HolodiskNumber ) );
        else
            result += GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item ) + 1 );

        if( item.Lexems != "" )
        {
            string lex = "" + item.Lexems;
            for( uint i = 0, len = lex.length(); i < len; i++ )
            {
                uint8 chr = lex[ i ];
                if( chr == 36 )
                {
                    lex = "";
                    break;
                }
            }
            if( lex != "" )
                result += " " + lex + "\n";
        }

        if( lookType != ITEM_LOOK_MAP )
        {
            uint16 pid = item.GetProtoId();
			
			if(item.GetType() == ITEM_TYPE_WEAPON)
			{
				// Strength Requirement
				if( item.GetType() == ITEM_TYPE_WEAPON) // || item.GetType() == ITEM_TYPE_ARMOR )
				{
					result += "\n-----------------------\n";
					string str;
					str = GetMsgStr( TEXTMSG_GAME, STR_INV_STR_REQ );
					str = ReplaceText( str, "VALUE", item.Proto.Weapon_MinStrength  );
					result += str;
				}
				//  Custom object speed
				if( FLAG(item.Flags, ITEM_CAN_USE) || FLAG(item.Flags, ITEM_CAN_USE_ON_SMTH ) || item.GetType() == ITEM_TYPE_WEAPON )
				{
					result += "\n";
					string str2;
					str2 = GetMsgStr( TEXTMSG_GAME, STR_INV_WAIT_TIME );
					str2 = ReplaceText( str2, "VALUE", GetProtoTime ( item.Proto, item.Mode, chosen ) );
					result += str2;
				}
				//  Custom AP cost
				if( FLAG(item.Flags, ITEM_CAN_USE) || FLAG(item.Flags, ITEM_CAN_USE_ON_SMTH ) || item.GetType() == ITEM_TYPE_WEAPON && item.Mode != USE_RELOAD )
				{
					result += "\n";
					string str;
					str = GetMsgStr( TEXTMSG_GAME, STR_INV_AP_COST );
					str = ReplaceText( str, "VALUE", GetUseApCost( chosen, item, item.Mode));
					result += str;
				}
				// Ammo & Reload info
				if( item.Proto.Weapon_MaxAmmoCount > 0)
				{
					// Custom Reload AP cost
					result += "\n";
					string str;
					str = GetMsgStr( TEXTMSG_GAME, STR_INV_RELOAD_COST );
					str = ReplaceText( str, "VALUE", item.Proto.Weapon_ReloadAp);
					// Ammo load
					string str2;
					str2 = GetMsgStr( TEXTMSG_GAME, STR_INV_HAS_SHOTS );
					str2 = ReplaceText( str2, "VALUE",     item.AmmoCount );
					str2 = ReplaceText( str2, "MAX_VALUE", item.Proto.Weapon_MaxAmmoCount );
					// Caliber
					string str3;
					str3 = GetMsgStr (TEXTMSG_GAME, STR_INV_CALIBER_MSG);
					str3 = ReplaceText( str3, "AMMO", GetMsgStr( TEXTMSG_GAME, STR_CALIBER( item.Proto.Weapon_Caliber ) ) );
					result += str + "\n" + str2 + "\n" + str3;
				}
			}
			
			else if(item.GetType() == ITEM_TYPE_ARMOR)
			result += "\n\n-----------------------";
			// Armor Class Mod
			if (item.Proto.Armor_AC > 0)
			{
				string str;
				str = GetMsgStr ( TEXTMSG_GAME, STR_INV_ARMOR_AC);
				str = ReplaceText (str, "VALUE", item.Proto.Armor_AC);
				result += str;
			}
		    
			else if(item.GetType() == ITEM_TYPE_AMMO)
			{
				// Ammo stats
				result += "\n-----------------------";
				string ammoACMod = GetMsgStr( TEXTMSG_GAME, STR_INV_AMMO_POWER );
				ammoACMod = ReplaceText( ammoACMod, "ACMOD", item.Proto.Ammo_AcMod);
				string ammoMult  = GetMsgStr( TEXTMSG_GAME, STR_INV_AMMO_MULT  );
				ammoMult  = ReplaceText( ammoMult,  "MULT",  item.Proto.Ammo_DmgMult );
				ammoMult  = ReplaceText( ammoMult,  "DIV",   item.Proto.Ammo_DmgDiv  );
				string ammoDRMod = GetMsgStr( TEXTMSG_GAME, STR_INV_AMMO_DRMOD );
				ammoDRMod = ReplaceText( ammoDRMod, "DRMOD", item.Proto.Ammo_DrMod);
				string ammoCal = GetMsgStr( TEXTMSG_GAME, STR_INV_CALIBER_MSG );
				ammoCal = ReplaceText( ammoCal, "AMMO", GetMsgStr(TEXTMSG_GAME, STR_CALIBER(item.Proto.Ammo_Caliber)));
				// string ammoDTMod = GetMsgStr( TEXTMSG_GAME, STR_INV_AMMO_DTMOD );
				// ammoDTMod = ReplaceText( ammoDTMod, "DTMOD", item.Proto.Ammo_DTDiv   );
				result += "\n" + ammoACMod + "\n" + ammoMult + "\n" + ammoDRMod + "\n" + ammoCal; // + "\n" + ammoDTMod;
			}
            
            // Deterioration
            if( item.IsDeteriorable() )
            {
                uint8  brokenFlags    = item.BrokenFlags;
                uint8  brokenCount = item.BrokenCount;
                uint16 deterioration = item.Deterioration;

                // Broken level, procent
                result += "\n";
                if( FLAG( brokenFlags, BI_NOTRESC ) )
                    result += GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_NO_RESC );
                else if( FLAG( brokenFlags, BI_LOWBROKEN ) )
                    result += GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_BROKEN_LOW );
                else if( FLAG( brokenFlags, BI_NORMBROKEN ) )
                    result += GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_BROKEN_NORM );
                else if( FLAG( brokenFlags, BI_HIGHBROKEN ) )
                    result += GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_BROKEN_HIGH );
                else
                    result += ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_PROCENT ), "VALUE", deterioration * 100 / MAX_DETERIORATION );

                // Service
                if( FLAG( brokenFlags, BI_SERVICE ) )
                    result += "\n" + GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_SERVICE );

                // Service ext
                if( FLAG( brokenFlags, BI_SERVICE_EXT ) )
                    result += "\n" + GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_SERVICE_EXT );

                // Broken count
                CritterCl@ chosen = GetChosen();
                //if( valid( chosen ) && chosen.Perk[ PE_MR_FIXIT ] != 0 )
				if( valid( chosen ) )
                    result += "\n" + ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_BROKEN_COUNT ), "VALUE", brokenCount );
            }

            // Key id
            if( item.GetType() == ITEM_TYPE_KEY )
                result += "\n" + ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_INV_KEY_NUMBER ), "KEY_ID", item.LockerId );

			result += "\n-----------------------";
			
			// Partial_Item
			if( item.Proto.Partial_Item > 0 && item.Val0 > 0 )
			{ 
				string partial_info = "Осталось использований: |0xE5C62B VALUE ";
				result += "\n" + ReplaceText( partial_info, "VALUE", item.Val0 );
			}

			// Weight
			uint containter = item.GetProtoId();
			if( containter == PID_POT_ALCO || Flasks.find( containter ) != -1 ) {
				result += "\n" + ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_ITEM_WEIGHT_GRAMM ), "VALUE", item.Proto.Weight + item.Val2 ); // Val2 отвечает за заполненность тары
			
			} else if( glass_bottles[2].find(  containter ) != -1 ) {
                result += "\n" + ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_ITEM_WEIGHT_GRAMM ), "VALUE", item.Proto.Weight - ( item.Proto.Partial_Item * 100 - item.Val2 ) ); // Val2 отвечает за заполненность тары, обратная логика для бутылок
			
			} else {
				result += "\n" + ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_ITEM_WEIGHT_GRAMM ), "VALUE", item.Proto.Weight * item.GetCount() );
			}
			
			// Volume
			result += "\n" + ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_INV_VOLUME ), "VALUE", item.Proto.Volume * item.GetCount() );
			// Homebrew Taste
			uint[] taste_pids = { PID_HOMEBREW_PRT };
			string[] brew_tastes = { "", "мутафруктов", "кукурузы", "конфет", "капусты", "карамели", "ванили", "кукурузы", "орехов вокас", "печенья", "протеинового батончика", "ягод паслена" };
			int m = taste_pids.find( item.GetProtoId() );
			if( m != -1 )
			{
				result += "\n-----------------------";
				item.Val8 > 0 ? result += "\nБрага со вкусом " + ReplaceText( brew_tastes[ item.Val8 ]	, ".", "" ) : result;
			}
			// Flask Taste
			int l = Flasks.find( item.GetProtoId() );
			if( l != -1 )
			{
				result += "\n-----------------------";
				item.Val1 > 0 ? result += "Судя по запаху, внутри:\n\n" + ReplaceText( GetMsgStr( TEXTMSG_ITEM, item.Val1*100 ) , ".", "" ) : result;
			}
		}
    }

    // Format tags
    if( item.Lexems != "" )
        return FormatTags( result, item.Lexems );
    return result;
}

string critter_description_maker( CritterCl& target, int lookType )
{
	CritterCl@ chosen = GetChosen();
	
	return critter_description_maker( lookType, target.Id, target.Stat[ ST_AGE ], target.Stat[ ST_GENDER ], target.CrType, target.Stat[ ST_BODY_TYPE ], target.IsPlayer(), target.Name, target.Pid, target.IsLife(), target.IsKnockout(), target.IsDead() );
}

void _testDescs( int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
	testDescs( GetChosen() );
}

void testDescs( CritterCl& target )
{
	Message( "Testing bodyTypes:" );
	for( uint i = 0; i < MAX_BODY_TYPES; i++ )
	{
		for( uint gender = 0; gender < 3; gender++ )
		{
			int[] stages = { 0, 10, 16, 20, 25, 30, 35, 40, 45, 60, 70 };
			for( uint age = 0, l = stages.length(); age < l; age++ )
			{
				bool isAlive = Random(0,1 )== 0;
				Message( "#" + i + ") " + critter_description_maker( CRITTER_LOOK_FULL, target.Id, stages[age], gender, target.CrType, i, Random(0,1) == 0, target.Name, target.Pid, isAlive, Random(0,1) == 0, !isAlive ) );
			}
		}
	}

	int[] crTypes = { 24, 55, 19, 76, 86, 67, 68, 81, 17, 53, 66, 90, 101, 438, 478, 479, 70, 75, 127, 220 };
	Message( "Testing crTypes:" );
	for( uint i = 0, l = crTypes.length(); i < l; i++ )
	{
		for( uint gender = 0; gender < 3; gender++ )
		{
			int[] stages = { 0, 10, 16, 20, 25, 30, 35, 40, 45, 60, 70 };
			for( uint age = 0, l = stages.length(); age < l; age++ )
			{
				bool isAlive = Random(0,1 )== 0;
				Message( "#" + crTypes[i] + ") " + critter_description_maker( CRITTER_LOOK_FULL, target.Id, stages[age], gender, crTypes[i], target.Stat[ ST_BODY_TYPE ], Random(0,1) == 0, target.Name, target.Pid, isAlive, Random(0,1) == 0, !isAlive ) );
			}
		}
	}
}

string critter_description_maker( int lookType, int target_id, int age, int gender, int crType, int bodyType, bool isPlayer, string name, uint16 npcPid, bool isLife, bool isKnockout, bool isDead )
{
    testInfo( 	CR_TEST_MODE_DESCRIPTIONS,
				"\tlookType " + lookType + 
				"\ttarget_id " + target_id + 
				"\tage " + age + 
				"\tgender " + gender + 
				"\tcrType " + crType + 
				"\tbodyType " + bodyType + 
				"\tisPlayer " + isPlayer +
				"\tname " + name + 
				"\tnpcPid " + npcPid + 
				"\tisLife " + isLife + 
				"\tisKnockout " + isKnockout + 
				"\tisDead " + isDead );
	
	string result = GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_NOTHING );
	
	CritterCl@ chosen = GetChosen();

	if( lookType == CRITTER_ONLY_NAME )
	{
		CritterCl@ cr = GetCritter( target_id );
		if( !valid( cr ) )
			return "[null]";
		
		if( cr.Param[ QST_MEDIUM ] != 0 )
		{
			if( cr.Param[ QST_MEDIUM ] == 2 )
				name = "";
			
			if( cr.Param[ QST_MEDIUM ] == 3 )
			{
				string@ s_temp = cr.Lexems;
				if( !(s_temp is null) )
					name = s_temp;
			}
			
			if( cr.Param[ QST_MEDIUM ] >= 4 )
			{
				string@ s_temp = GetName( cr.Param[ QST_MEDIUM ] );
				if( !(s_temp is null) )
					cr.Name = s_temp;
			}
		}
		else 
			if( !isPlayer )
				name = GetMsgStr( TEXTMSG_DLG, STR_NPC_PROTO_NAME( npcPid ) );

		result = name;
    }
	
	if( lookType == CRITTER_LOOK_SHORT )
	{
		if( name != "" || ( __sinf & SINF_LOGIN ) != 0 )
		{
			result = "Вы видите: " + COLOR_CRITTER + name + ".";
		}
		else
		{
			lookType = CRITTER_LOOK_FULL;
		}
	}
	
	if( lookType == CRITTER_LOOK_FULL )
	{
		string view_name = "монстр";
		string view_age = "";

		bool isMale = gender == 0;
		bool hasGender = gender >= GENDER_MALE && gender <= GENDER_FEMALE;
		bool isAging = true;
		
		bool hasName = true;
		switch( crType )
		{
			case( 24 ): view_name = "крыс" + ( hasGender ? ( isMale ? "" : "иха" ) : "а" ); 										if( !hasGender ) { hasGender = true; isMale = false; } break;
			case( 55 ): view_name = "свинокрыс" + ( hasGender ? ( isMale ? "" : "иха" ) : "" );  									if( !hasGender ) { hasGender = true; isMale = true; } break;
			case( 19 ): view_name = hasGender ? ( isMale ? "самец кротогризли" : "самка кротогризли" ) : "кротогризли"; 			if( !hasGender ) { hasGender = true; isMale = true; } break;
			case( 76 ): view_name = "крыс" + ( hasGender ? ( isMale ? "иный король" : "иная королева" ) : "а переросток" ); 		if( !hasGender ) { hasGender = true; isMale = false; } break;
			
			case( 86 ): view_name = hasGender ? ( isMale ? "королевский ванаминго" : "матка ванаминго" ) : "ванаминго-альбинос";	if( !hasGender ) { hasGender = true; isMale = true; } break;

			case( 67 ): view_name = "серебрянный геккон";		hasGender = true; isMale = true; break;
			case( 68 ): view_name = "золотой геккон";			hasGender = true; isMale = true; break;
			case( 81 ): view_name = "огнедышащий геккон";		hasGender = true; isMale = true; break;
			
			case( 17 ): view_name = "мистер хенди"; 			hasGender = true; isMale = true; bodyType = BT_ROBOT; break;
			case( 53 ): view_name = "робомозг"; 				hasGender = true; isMale = true; bodyType = BT_ROBOT; break;
			case( 66 ): view_name = "охранный робот";			hasGender = true; isMale = true; bodyType = BT_ROBOT; break;
			
			case( 90 ): 
			case( 101 ):
			case( 438 ):
			case( 478 ):view_name = "турель";					hasGender = true; isMale = false; bodyType = BT_ROBOT; break;
			
			case( 479 ):view_name = "терминал";					hasGender = true; isMale = true; bodyType = BT_ROBOT;  break;				
			
			case( 70 ):
			case( 75 ):	view_name = "киберпёс"; 				hasGender = true; isMale = true; bodyType = BT_ROBOT;  break;

			case( 127 ):view_name = "дикий болотник"; 			hasGender = true; isMale = true; break;
			
			case( 220 ):view_name = "щенок"; 					hasGender = true; isMale = true; isAging = false; break;
			
			default: hasName = false; break;
		}
		
		if( !hasName )
		{
			switch( bodyType )
			{
				case( BT_CHILDREN ): isAging = false; view_name = hasGender ? ( isMale ? "мальчик" : "девочка" ) : "ребёнок"; if( !hasGender ) { hasGender = true; isMale = true; } break;
				
				case( BT_MEN ): 
				case( BT_WOMEN ): {
					isAging = false;
					uint ageStr = GetMsgStrNumUpper( TEXTMSG_GAME, STR_CRIT_LOOK_AGE( CLAMP( gender, GENDER_MALE, GENDER_FEMALE ), CLAMP( age, 0, 90 ) ) );
					if( ageStr != 0 )
						view_name = GetMsgStr( TEXTMSG_GAME, ageStr );
					else if( name == "" )
						view_name = "???";
					else
					{
						view_name = name;
						view_name = ".";
					}
				break; }
				
				case( BT_SUPER_MUTANT ): 	view_name = "Супермутант" + ( isMale || !hasGender ? "" : "ша" ); 	if( !hasGender ) { hasGender = true; isMale = true; } break;
				case( BT_GHOUL ): 			view_name = "Гул" + ( isMale || !hasGender ? "ь" : "иха" ); 		if( !hasGender ) { hasGender = true; isMale = true; } break;
				case( BT_BRAHMIN ):			view_name = "Брамин" + ( isMale || !hasGender ? "" : "иха" );		if( !hasGender ) { hasGender = true; isMale = true; } break;
				case( BT_DOG ): 			view_name = isMale || !hasGender ? "кобель" : "сука"; 				if( !hasGender ) { hasGender = true; isMale = true; } break;
				case( BT_RAT ):				view_name = "Крыс" + ( hasGender ? ( isMale ? "" : "а" ) : "а" ); if( !hasGender ) { hasGender = true; isMale = false; } break;
				
				case( BT_ROBOT ):			view_name = "Робот"; 			hasGender = true; isMale = true; break;					
				case( BT_PLANT ): 			view_name = "Хищное растение"; 	hasGender = false; break;
				case( BT_GIANT_ANT ): 		view_name = "Муравей"; 			hasGender = true; isMale = true; break;
				case( BT_GIANT_BEETLE ): 	view_name = "Жук"; 				hasGender = true; isMale = true; break;
				case( BT_GIANT_WASP   ): 	view_name = "Оса"; 				hasGender = true; isMale = false; break;
				case( BT_RADSCORPION ): 	view_name = "Скорпион"; 		hasGender = true; isMale = true; break;
				case( BT_FLOATER ): 		view_name = "Летун"; 			hasGender = true; isMale = true; break;
				case( BT_ALIEN ): 			view_name = "Ванаминго"; 		hasGender = false; break;
				case( BT_CENTAUR ): 		view_name = "Кентавр"; 			hasGender = true; isMale = true; break;
				case( BT_GECKO ): 			view_name = "Геккон"; 			hasGender = true; isMale = true; break;
				case( BT_MANTI ): 			view_name = "Мантис"; 			hasGender = true; isMale = true; break;
				case( BT_DEADCLAW ): 		view_name = "Коготь смерти"; 	hasGender = true; isMale = true; break;
				case( BT_BIG_BAD_BOSS ): 	view_name = "Монстр"; 			hasGender = true; isMale = true; break;
				case( BT_YAO ): 			view_name = "Яо-гай"; 			hasGender = true; isMale = true; break;	
				default: 					view_name = "Существо"; hasGender = false; break;
			}
		}
		
		if( isAging )
		{
			int[] age_stages = { 10, 18, 30, 40, 60 };
			string[] age_stage_names = { "юн", "молод", "взросл", "стар", "престарел" };
			string[] robot_age_stage_names = { "нов", "обычн", "пыльн", "ржав", "трухляв" };

			if( age >= age_stages[0] )
			{
				for( uint i = 0, l = age_stages.length(); i < l; i++ )
					if( age >= age_stages[i] )
					{
						view_age = bodyType == BT_ROBOT ? robot_age_stage_names[i] : age_stage_names[i];
						
						if( hasGender )
							view_age += isMale ? ( i == 1 ? "ой" : "ый" ) : "ая";
						else
							view_age += "ое";
					}
					
				view_age += " ";
			}
			else switch( bodyType ) {
				case( BT_ROBOT ): 	view_age = "игрушечн" + ( hasGender ? ( isMale ? "ой" : "ая" ) : "ое" ) + " "; break;
				case( BT_PLANT ): 	view_age = "маленьк" + ( hasGender ? ( isMale ? "ий" : "ая" ) : "ое" ) + " "; break;
				default: 			view_age = "детёныш-"; break;
			}
		}
		
		string description = view_age + view_name;
		description = strupr( substring ( description, 0, 1 ) ) + substring( description, 1, description.length() - 1 );
		int line_type = isLife ? STR_CRIT_LOOK_LIFE : isKnockout ? STR_CRIT_LOOK_KO : isDead ? STR_CRIT_LOOK_DEAD : STR_CRIT_LOOK_NOTHING;
		if( line_type != STR_CRIT_LOOK_NOTHING ) {
			if( !isPlayer ) { // Заплатка на описание из прототипа - Анури
				description = GetMsgStr( TEXTMSG_DLG, STR_NPC_PROTO_NAME( npcPid ) );
				description += ". |0x3CF800 " + GetMsgStr( TEXTMSG_DLG, STR_NPC_PROTO_DESC( npcPid ) );
			}
				result = ReplaceText( GetMsgStr( TEXTMSG_GAME, uint( line_type ) ), "NAME", COLOR_CRITTER + description );
		}
	}
	return result;
}

string critter_description_health( CritterCl& cr )
{
	int gender = cr.Stat[ ST_GENDER ];
	string result = GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_WHO( gender ) );
	
	int hp_proc = cr.Stat[ ST_CURRENT_HP ] * 100 / cr.Stat[ ST_MAX_LIFE ];
	if( cr.IsDead() )
	{
		if( cr.IsNpc () )
			result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_STATE( -1 ) ) + genderEnding( cr );	
		else
			result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_STATE( 0 ) );
	}
	else if( cr.Stat[ ST_CURRENT_HP ] < 0 )
		result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_STATE( 1 ) ) + genderEnding( cr );
	else if( hp_proc <= 30 )
		result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_STATE( 2 ) ) + genderEnding( cr );
	else if( hp_proc <= 50 )
		result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_STATE( 3 ) ) + genderEnding( cr );
	else if( hp_proc <= 70 )
		result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_STATE( 4 ) ) + genderEnding( cr );
	else if( hp_proc <= 90 )
		result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_STATE( 5 ) ) + genderEnding( cr );
	else
		result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_STATE( 6 ) ) + genderEnding( cr );

	if( _CritIsInjured( cr ) )
	{
		bool needComa = false;

		int hp_proc = cr.Stat[ ST_CURRENT_HP ] * 100 / cr.Stat[ ST_MAX_LIFE ];
		result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_LIMBS( gender, hp_proc >= 90 ) ) + ": ";
		
		if( cr.ParamBase[ DAMAGE_EYE ] != 0 )
		{
			result += "глаза";
			needComa = true;
		}
		if( cr.ParamBase[ DAMAGE_RIGHT_ARM ] != 0 )
		{
			if( needComa ) result += ", ";
			result += "правая рука";
			needComa = true;
		}
		if( cr.ParamBase[ DAMAGE_LEFT_ARM ] != 0 )
		{
			if( needComa ) result += ", ";
			result += "левая рука";
			needComa = true;
		}
		if( cr.ParamBase[ DAMAGE_RIGHT_LEG ] != 0 )
		{
			if( needComa ) result += ", ";
			result += "правая нога";
			needComa = true;
		}
		if( cr.ParamBase[ DAMAGE_LEFT_LEG ] != 0 )
		{
			if( needComa ) result += ", ";
			result += "левая нога";
			needComa = true;
		}
	}
	return result + ".";
}

string critter_description_hand( CritterCl& cr )
{
	ItemCl@    item  = _CritGetItemHand(cr);
	if( !valid( item ) ) return "";

	int bodyType = cr.Stat[ ST_BODY_TYPE ];
	int crType = cr.CrType;

	bool twoHanded = valid( item ) ? FLAG( item.Flags, ITEM_TWO_HANDS ) : false;
	bool determined = true;
	
	string hands;
	switch( crType )
	{
		case( 90 ): 
		case( 101 ):
		case( 438 ):
		case( 478 ):hands = "Вооружение:"; break;
		default: determined = false; break;
	}
	
	if( !determined )
	{
		switch( bodyType )
		{
			case( BT_BRAHMIN ):
				hands = "Во рту держит";
				break;

			case( BT_RAT ):
			case( BT_DOG ):
			case( BT_PLANT ):
				hands = "В пасти держит";
				break;

			case( BT_GIANT_ANT ):
			case( BT_GIANT_BEETLE ):
			case( BT_GIANT_WASP   ):
				hands = "В жвалах держит";
				break;

			case( BT_RADSCORPION ): 	hands = "В клешн" + ( twoHanded ? "ях" : "е" ); break;
			case( BT_FLOATER ): 		hands = "В тентакл" + ( twoHanded ? "ях" : "е" ); break;
			case( BT_ALIEN ): 			hands = "В тентакл" + ( twoHanded ? "ях" : "е" ); break;
			case( BT_CENTAUR ): 		hands = "В нарост" + ( twoHanded ? "ах" : "е" ); break;
			case( BT_ROBOT ): 			hands = "Держит " + ( twoHanded ? "манипуляторами" : "в манипуляторе" ) + " предмет:"; break;
			case( BT_GECKO ): 			hands = "В пасти: "; break;
			case( BT_MANTI ): 			hands = "В лапк" + ( twoHanded ? "ах" : "е" ); break;
			case( BT_YAO ):
			case( BT_DEADCLAW ): 		hands = "В лап" + ( twoHanded ? "ах" : "е" ); break;
			case( BT_BIG_BAD_BOSS ): 	hands = "Держит " + ( twoHanded ? "двумя ручищами" : "в ручище" ) + " предмет:"; break;
			default: 					hands = "В рук" + ( twoHanded ? "ах" : "е" ); break;
		}
	}					

	return " " + hands + " " + itemText( item ) + ".";
}

string critter_description_slots( CritterCl& cr )
{
	string result;
	
	ItemCl@    offhand = _CritGetItemHandExt(cr);
	if( valid( offhand ) && !wearMask( cr ) )
	{
		result += " " + GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_MISC ) + ".";
		result = ReplaceText( result, "MISC", itemText( offhand ) );
	}
	
	bool hasPrefix = false;
	bool female = cr.Stat[ ST_GENDER ] == GENDER_FEMALE;
	
	ItemCl@    armor = _CritGetItemArmor(cr);
	if( valid( armor ) )
	{
		result += " На не" + ( female ? "й" : "м" ) + " " + itemText( armor );
		hasPrefix = true;
	}

	ItemCl@    head = _CritGetItemHead(cr);
	if( valid( head ) )
	{
		result += ( hasPrefix ? "," : ( " На не" + ( female ? "й" : "м" ) ) ) + " " + itemText( head );
		hasPrefix = true;
	}

	ItemCl@    misc = _CritGetItemMisc(cr);
	if( valid( misc ) )
	{
		result += ( hasPrefix ? " и" : ( " У не" + ( female ? "ё" : "го" ) ) ) + " " + itemText( misc );
		hasPrefix = true;
	}

	if( hasPrefix ) 
		result += ".";
	
	ItemCl@    back = _CritGetItemBack(cr);
	if( valid( back ) )
	{
		result += " На спине " + " " + itemText( back ) + ".";
	}
	
	return result;
}

string critter_description_stats( CritterCl& cr )
{
	if( cr.Stat[ ST_BODY_TYPE ] >= BT_BRAHMIN && cr.IsNpc() ) return "";
	
	CritterCl@ chosen = GetChosen();

	ItemCl@    item2 = _CritGetItemHandExt(cr);
	ItemCl@    item3 = _CritGetItemArmor(cr);

	// Список брони для сокрытия внешности.
	uint16[][] OpenArmorList =
	{
	{   // Снимаемое. Капюшоны.
		PID_PURPLE_ROBE, PID_BLACK_ROBE, PID_SANDROBE, PID_BROWN_ROBE, PID_DARK_GREEN_ROBE, PID_RED_RITUAL_ROBE, PID_BLACK_RITUAL_ROBE, PID_DARK_BLACK_ROBE, 
		PID_DARK_RED_ROBE, PID_RED_ROBE, PID_DARK_BROWN_ROBE, PID_DARK_BLUE_ROBE, PID_ATOM_CHILD_ROBE

	},{ // Неснимаемое. Скрывает всё.
		 PID_EKZO, PID_OXIDENED_POWER_ARMOR, PID_aras2k1, PID_arekzo, PID_EKZO_2, PID_POWERED_ARMOR_NEVADA, PID_aras2k2, PID_arbattl1,
		 PID_ardfnder, PID_HYENA_PA, PID_HYENA_PA_MK2, PID_ADVANCED_POWER_ARMOR, PID_ADVANCED_POWER_ARMOR_MK2
	},{ // Снимаемый шлем.
		 PID_POWERED_ARMOR, PID_HARDENED_POWER_ARMOR
	}
	};

	uint8 OpenArmor = 0;
	if( item3 !is null )
	{
		uint16 PID = item3.GetProtoId();
		for( uint8 i = 0, l = OpenArmorList.length(); i < l; i++ )
		{
			for( uint8 ii = 0, ll = OpenArmorList[ i ].length(); ii < ll; ii++ )
			{
				if( PID == OpenArmorList[ i ][ ii ] ) { OpenArmor = i+1; break; }
			}
		}
	}
	
	bool hidelex = false;

	bool showface = true;
	bool showbody = true;
	bool female = ( cr.Stat[ ST_GENDER ] == GENDER_FEMALE ? true : false );
	string usual = " "+( cr.Stat[ ST_GENDER ] == GENDER_FEMALE ? "обычная" : cr.Stat[ ST_GENDER ] == GENDER_MALE ? "обычный" : "обычное" );
	string look = "";

	hidelex = ( OpenArmor == 1 && FLAG( cr.Param[ MIO_FLAGS ], ITEM_FLAT ) );
	bool hideopt = ( FLAG( cr.Param[ MIO_FLAGS ], ITEM_HIDDEN ) );

	if( OpenArmor == 1 && hideopt )
	{
		look += "Лицо скрыто капюшоном";
		showface = false;
		usual = "";
	}
	else if( OpenArmor == 2 )
	{
		look += "Внешность скрывает доспех";
		showface = false;
		showbody = false;
		usual = "";
	}
	else if( OpenArmor == 3 )
	{
		if( hideopt )
		{
			look += "Внешность скрывает доспех";
			showface = false;
		}
		else { look += "Тело скрывает доспех"; }
		showbody = false;
		usual = "";
	}
	else { if( !wearMask( cr ) ) look += "На вид"; }
	
	if( wearMask( cr ) )
	{
		if( showface )
			look += "Лицо скрывает " + GetMsgStr( TEXTMSG_ITEM, item2.GetProtoId() * 100 );
		
		showface = false;
	}

	if( showface && chosen.Id != cr.Id )
	{
		if( chosen.Trait[ TRAIT_BLOODY_MESS ] != 0 )
		{
			look += " ";
			switch( Random( 0, 9 ) )
			{
				case 0: look += "смотрит зло на тебя"; break;
				case 1: look += "бормочет что-то нехорошее о тебе"; break;
				case 2: look += "смотрит с ненавистью"; break;
				case 3: look += "насмехается над тобой"; break;
				case 4: look += "смотрит презрительно"; break;
				case 5: look += "выглядит уродливо"; break;
				case 6: look += "коситься в твою сторону"; break;
				case 7: look += "кажется хочет напасть"; break;
				case 8: look += "скалится на тебя"; break;
				case 9: look += "шепчет сдохни"; break;
			}
			showface = false;
			showbody = false;
			usual = "";
		}
	}

	string comma = " ";
	if( !showface || !showbody ) { comma = ", "; }
	bool truecomma;
	if( showface )
	{
		truecomma = true;
		if( cr.Stat[ ST_CHARISMA ] >= 10 )
		{
			if( female ) { look += comma + "|0x3CF8FA неотразима|0x3CF800 "; } else { look += comma + "|0x3CF8FA неотразим|0x3CF800 "; }
		}
		else if( cr.Stat[ ST_CHARISMA ] >= 9 )
		{
			if( female ) { look += comma + "|0x3CF8D2 прекрасна|0x3CF800 "; } else { look += comma + "|0x3CF8D2 прекрасен|0x3CF800 "; }
		}
		else if( cr.Stat[ ST_CHARISMA ] >= 8 )
		{
			if( female ) { look += comma + "|0x3CF8AA красива|0x3CF800 "; } else { look += comma + "|0x3CF8AA красив|0x3CF800 "; }
		}
		else if( cr.Stat[ ST_CHARISMA ] >= 7 )
		{
			if( female ) { look += comma + "|0x3CF882 привлекательна|0x3CF800 "; } else { look += comma + "|0x3CF882 привлекателен|0x3CF800 "; }
		}
		else if( cr.Stat[ ST_CHARISMA ] <= 1 )
		{
			if( female ) { look += comma + "|0xFF0000 тошнотворная|0x3CF800 "; } else { look += comma + "|0xFF0000 тошнотворный|0x3CF800 "; }
		}
		else if( cr.Stat[ ST_CHARISMA ] <= 2 )
		{
			if( female ) { look += comma + "|0xFF4000 отвратительна|0x3CF800 "; } else { look += comma + "|0xFF4000 отвратителен|0x3CF800 "; }
		}
		else if( cr.Stat[ ST_CHARISMA ] <= 3 )
		{
			if( female ) { look += comma + "|0xFF6000 неприятна|0x3CF800 "; } else { look += comma + "|0xFF6000 неприятен|0x3CF800 "; }
		}
		else { truecomma = false; }
		if( truecomma ) { comma = ", "; usual = ""; }
	}

	if( showbody )
	{
		truecomma = true;
		if( cr.StatBase[ ST_STRENGTH ] >= 10 )
		{
			if( female ) { look += comma + "мощная"; } else { look += comma + "мощный"; }
		}
		else if( cr.StatBase[ ST_STRENGTH ] >= 8 )
		{
			if( female ) { look += comma + "сильна"; } else { look += comma + "силён"; }
		}
		else if( cr.StatBase[ ST_STRENGTH ] <= 1 )
		{
			if( female ) { look += comma + "немощная"; } else { look += comma + "немощный"; }
		}
		else if( cr.StatBase[ ST_STRENGTH ] <= 3 )
		{
			if( female ) { look += comma + "слабая"; } else { look += comma + "слабый"; }
		}
		else { truecomma = false; }
		if( truecomma ) { comma = ", "; usual = ""; }

		//==================================================

		truecomma = true;
		if( cr.StatBase[ ST_ENDURANCE ] >= 10 )
		{
			if( female ) { look += comma + "крепко сбита"; } else { look += comma + "крепко сбит"; }
		}
		else if( cr.StatBase[ ST_ENDURANCE ] >= 8 )
		{
			if( female ) { look += comma + "крепкая"; } else { look += comma + "крепкий"; }
		}
		else if( cr.StatBase[ ST_ENDURANCE ] <= 1 )
		{
			if( female ) { look += comma + "хрупкая"; } else { look += comma + "хрупкий"; }
		}
		else if( cr.StatBase[ ST_ENDURANCE ] <= 3 )
		{
			if( female ) { look += comma + "хилая"; } else { look += comma + "хилый"; }
		}
		else { truecomma = false; }
		if( truecomma ) { comma = ", "; usual = ""; }

		//==================================================

		truecomma = true;
		if( cr.StatBase[ ST_AGILITY ] >= 10 )
		{
			if( female ) { look += comma + "проворна"; } else { look += comma + "проворен"; }
		}
		else if( cr.StatBase[ ST_AGILITY ] >= 8 )
		{
			if( female ) { look += comma + "ловкая"; } else { look += comma + "ловкий"; }
		}
		else if( cr.StatBase[ ST_AGILITY ] <= 1 )
		{
			if( female ) { look += comma + "неповоротливая"; } else { look += comma + "неповоротливый"; }
		}
		else if( cr.StatBase[ ST_AGILITY ] <= 3 )
		{
			if( female ) { look += comma + "неуклюжая"; } else { look += comma + "неуклюжий"; }
		}
		else { truecomma = false; }
		if( truecomma ) { comma = ", "; usual = ""; }
	}

	string result = ( look != "" ? ( " " + look + usual + "." ) : "" );

	ItemCl@ armor = cr.GetItem( 0, SLOT_ARMOR );
	bool ArmorLexem = ( valid(armor) && armor.Lexems != "" );
	
	if( valid(armor) && ( armor.Val9 == PID_POPUP || armor.GetProtoId() == PID_POPUP ) )
		ArmorLexem = false;
	
	if( ( cr.Lexems != "" || ArmorLexem ) && !hidelex && cr.Param[ QST_MEDIUM ] != 3 ) 
	{ 
		result += " ";
		if( ArmorLexem )
			result += armor.Lexems;
		else	
			result += cr.Lexems;
		
		result += "."; 
	}

	return result;
}

string critter_description_full( CritterCl& cr, string& result )
{
	if( result.length() > 0 && result[ result.length() - 1 ] != '.' )
		result += ".";

	result += " " + COLOR_NETMSG 
			+ critter_description_health( cr ) 
			+ critter_description_hand( cr ) 
			+ critter_description_slots( cr ) 
			+ critter_description_stats( cr );
			
	return result;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Critter description. Look types look in _client_defines.fos, Critter look types.
string critter_description( CritterCl& cr, int lookType )
{
    string result = critter_description_maker( cr, lookType ); //Базовое описание цели.

    //Подробное описание состояния и инвентаря цели.
	if( lookType == CRITTER_LOOK_FULL )
    {
        critter_description_full( cr, result );
	}

    if( lookType == CRITTER_LOOK_SHORT && ( __sinf & SINF_CRID ) != 0 )
    {
        result += " |0xffff0000 " + cr.Id;
    }

    // Format tags
    if( cr.Lexems != "" )
        return FormatTags( result, cr.Lexems );

    return result;

}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Elevator generation.
// Data specification:
// 1
// 1 start level
// 1 levels count
// 1 main pic
// 2 main pic width, height
// 1 additional pic offset
// 2 additional pic point
// 1 indicator animation offset in INTRFACE.LST
// 2 indicator animation point
// 1 button down pic offset in INTRFACE.LST
// 1 buttons count
// 4 rect for every button
bool get_elevator( uint type, uint[]& data )
{
    const string iface = "art\\intrface\\";
    const        uint[][] elevators =
    {
        //	 Level current, start, count               Main picture size                          Additional picture size                            Indicator animation size                  Buttons count
        //	         Main picture                               Additional picture                       Indicator animation                                  Button down picture                 Button coordinates
        // 0) BOS 1234
        { 0, 1, 4,  GetStrHash( iface + "EL_BOS.FRM" ),   230, 284, 0,                                0, 0,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 4, 11, 42, 58, 91, 11, 102, 58, 151, 11, 162, 58, 211, 11, 222, 58, 271 },
        // 1) BOS G1
        { 0, 0, 2,  GetStrHash( iface + "EL_BOS.FRM" ),   230, 284, GetStrHash( iface + "EL_BOS2.FRM" ),  0, 37,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 2, 11, 42, 58, 91, 11, 102, 58, 151 },
        // 2) Master 123
        { 0, 1, 3,  GetStrHash( iface + "EL_MAST1.FRM" ), 230, 284, 0,                                0, 0,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 3, 11, 42, 58, 91, 11, 102, 58, 151, 11, 162, 58, 211 },
        // 3) Master 34
        { 0, 3, 2,  GetStrHash( iface + "EL_MAST1.FRM" ), 230, 284, GetStrHash( iface + "EL_MAST2.FRM" ), 0, 37,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 2, 11, 42, 58, 91, 11, 102, 58, 151 },
        // 4) Military 123
        { 0, 1, 3,  GetStrHash( iface + "EL_MIL1.FRM" ),  231, 285, 0,                                0, 0,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 3, 11, 42, 58, 91, 11, 102, 58, 151, 11, 162, 58, 211 },
        // 5) Military 34
        { 0, 3, 4,  GetStrHash( iface + "EL_MIL1.FRM" ),  231, 285, GetStrHash( iface + "EL_MIL2.FRM" ),  0, 37,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 2, 11, 42, 58, 91, 11, 102, 58, 151 },
        // 6) Military 346
        { 0, 3, 3,  GetStrHash( iface + "EL_MIL1.FRM" ),  231, 285, GetStrHash( iface + "EL_MIL3.FRM" ),  0, 37,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 3, 11, 42, 58, 91, 11, 102, 58, 151, 11, 162, 58, 211 },
        // 7) Military 456
        { 0, 4, 3,  GetStrHash( iface + "EL_MIL1.FRM" ),  231, 285, GetStrHash( iface + "EL_MIL4.FRM" ),  0, 37,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 3, 11, 42, 58, 91, 11, 102, 58, 151, 11, 162, 58, 211 },
        // 8) Vault 123
        { 0, 1, 3,  GetStrHash( iface + "EL_VAULT.FRM" ), 230, 284, 0,                                0, 0,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 3, 11, 42, 58, 91, 11, 102, 58, 151, 11, 162, 58, 211 },
    };

    uint index = ( type & 0xFFFF );
    uint currentLevel = ( type >> 16 );

    if( index > 8 )
        return false;
    data.resize( elevators[ index ].length() );
    for( uint i = 0; i < data.length(); i++ )
        data[ i ] = elevators[ index ][ i ];
    data[ 0 ] = currentLevel;
    return true;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Music/Video, see media.fos

void _PlaySound( int pos, int repeat, int, string@ soundName, int[] @ )
{
    PlaySound( soundName );
}

void _PlayMusic( int pos, int repeat, int, string@ musicName, int[] @ )
{
    PlayMusic( musicName, uint( pos ), uint( repeat ) );
}

void _PlayVideo( int canStop, int, int, string@ videoName, int[] @ )
{
    PlayVideo( videoName, canStop != 0 );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Effects, see effects.fos
void _FlushScreen( int fromColor, int toColor, int timeMs, string@, int[] @ )
{
    FlushScreen( fromColor, toColor, timeMs );
}

void _QuakeScreen( int noise, int timeMs, int, string@, int[] @ )
{
    QuakeScreen( noise, timeMs );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call to determine cost of single item.
// To allow function set __CustomItemCost to true.
// Don't forgot specify this function in client script.
uint item_cost( ItemCl& item, CritterCl& cr, CritterCl& npc, bool sell )
{
    uint8  itemType = item.GetType();
    uint16 pid = item.GetProtoId();
    float   cost = item.Proto.Cost;

    if( pid == PID_BOTTLE_CAPS || pid == PID_REAL_BOTTLE_CAPS )
        return 1;
		
	if( pid == PID_DOLLAR_100 )
		return 100;

	if( pid == PID_DOLLAR_20 )
		return 20;
		
	if( pid == PID_DOLLAR_5 )
		return 5;

    if( itemType == ITEM_TYPE_ARMOR || itemType == ITEM_TYPE_WEAPON )
    {
        uint8 brokenCount = item.BrokenCount;
        uint8 brokenFlags = item.BrokenFlags;

        if( FLAG( brokenFlags, BI_NOTRESC ) || FLAG( brokenFlags, BI_BROKEN ) )
            cost *= 0.01;
        else if( FLAG( brokenFlags, BI_HIGHBROKEN ) )
            cost /= 3;
        else if( FLAG( brokenFlags, BI_NORMBROKEN ) )
            cost /= 2;
        else if( FLAG( brokenFlags, BI_LOWBROKEN ) )
            cost /= 1.4;
        else if( brokenCount > 0 )
            cost *= brokenCount != 100 ? brokenCount * 0.01 : 0.01;

        if( itemType == ITEM_TYPE_WEAPON && !item.IsStackable() )
        {
            cost += GetProtoItem( item.AmmoPid ).Cost * item.AmmoCount;
        }
    }

	//if( itemType == ITEM_TYPE_PARTIAL ) //TODO: Переделать в новый "тип" предметов (прото) - PARTIAL.
	uint[] partial_pids = { PID_ITSOAP01_PRT, PID_FPSHL6_PRT, PID_CIGARETTES_PRT };
	if( partial_pids.find( pid ) != -1 )
	{
		cost = cost * item.Val0 / 10; //Прямая зависимость от количества оставшихся предметов в "пачке".
	}

	//Торговля мк3 - учитывает опыт НД и ТНФ. Сделал бы отделной ф-ей, да толку - от этой итак ничего не осталось уже.
	
	//Редактируемые "настройки" торговли:
		float skill_range = 150; //Градация разницы в скиллах между НПЦ и чаром. Чем она шире - тем медленней падение/рост цен за 1% разницы.
		
		float price_range = 0.25; //Диапазон разброса цен на покупку у НПЦ.
		//Т.е. это больше НЕ "максимальная допустимая уценка скупки и наценка продажи".

	//Промежуточные функции. Не трогать почём зря!
		//Высчитывает % отношения разницы к допустимому разбросу скиллов. Диапазон: [ -1, 1 ]
			float skill = CLAMP( cr.SkillBase[ SK_BARTER ] - npc.SkillBase[ SK_BARTER ], -skill_range, skill_range ) * ( 1.0 / skill_range ); 

	//Основная логика:
		if( sell ) //Для продажи неписю:
			cost = cost * 0.4; //40% от себеса
		else //Для покупки у НПЦ:
			cost = cost * ( 0.75 - 0.25 * skill ); //От 50 до 100% цены себестоимости товара.
		
	//Конец "торговли".
	
	return CLAMP( floor( cost ), 1, cost );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call to determine perk aviability.
bool check_perk( CritterCl& cr, uint perk )
{
    return PerkCheck( cr, perk );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call to calculate registration data.
// Input: 7 special, 3 tag skills, 2 traits, age, gender
void player_data_generate( int[]& data )
{
    CritterGenerate( data );

    #ifdef PLAYERS_3D
    Set3DRegistrationGender( data[ ST_GENDER ] );
    #endif
}

bool player_data_check( int[]& data )
{
    SetCrtype( data );
    #ifdef PLAYERS_3D
    Fill3DRegistrationParameters( data );
    #endif

    return CritterGenerateCheck( data );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on some critter action.

void SoundDoor( int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
	CritterCl@ cr = GetCritter( param0 );
	ItemCl@ item = GetItem( param1 );

	uint8 sound = SOUND_DOOR_NOT_OPEN;
	if( !( cr.HexY == item.HexY && cr.HexX == item.HexX ) )
	{
		if( item.LockerCondition == 0 )			{ sound = SOUND_DOOR_CLOSE; }
		else if( item.LockerCondition == 1 )	{ sound = SOUND_DOOR_OPEN; }
		else									{ sound = SOUND_DOOR_LOCK; }
	}
	PlaySound( SOUND_DOOR, sound, item.Proto.SoundId, item.Proto.SoundId );
}

void critter_action( bool localCall, CritterCl& cr, int action, int actionExt, ItemCl@ item )
{
	uint8            mode = 0;
    const ProtoItem@ proto = ( valid( item ) ? item.Proto : cr.GetSlotProto( SLOT_HAND1, mode ) );
	
    if (!localCall && null !is proto && item !is null && proto.SoundId > 0) {
        if (ITEM_TYPE_DOOR == proto.Type || ITEM_TYPE_CONTAINER == proto.Type) {
            uint8 sound = SOUND_DOOR_NOT_OPEN;
            if (!(cr.HexY == item.HexY && cr.HexX == item.HexX)) {
                if (0 == item.LockerCondition) {
                    sound = SOUND_DOOR_CLOSE;
                } else if (1 == item.LockerCondition) {
                    sound = SOUND_DOOR_OPEN;
                } else {
                    sound = SOUND_DOOR_LOCK;
                }
            }
            PlaySound(SOUND_DOOR, sound, proto.SoundId, proto.SoundId);
        } 
    }


	if(cr.IsChosen())
    {
		// Not process locally called actions
		if(!localCall)
		{
			switch( action )
			{
				case ACTION_MOVE_ITEM:
				case ACTION_MOVE_ITEM_SWAP:
				case ACTION_USE_ITEM:
				case ACTION_DROP_ITEM:
				case ACTION_USE_WEAPON:
					if( FLAG( ( (actionExt >> 12) & 0xF), ACTION_FLAG_CHOSEN_INCLUSIVE ) )
						break; // PROCESS IT !
				// case ACTION_RELOAD_WEAPON: binyan - правка для действий по хоткеям
				case ACTION_USE_SKILL:
				// case ACTION_PICK_ITEM:
				// case ACTION_PICK_CRITTER:
				case ACTION_OPERATE_CONTAINER:
					return;             // Skip processing
				case ACTION_WINDUP:
				{
					if( FLAG( ( (actionExt >> 12) & 0xF), ACTION_FLAG_CHOSEN_INCLUSIVE ) ) {
						break; // PROCESS IT !
					}
					return;
				}
				default:
					break;              // Processing
			}
		}
		else
		{
			switch(action)
			{
				case ACTION_USE_WEAPON:
				{
					if( GetProtoWindupTime( proto, actionExt, cr ) != 0 && cr.ParamBase[ CR_IS_WINDUPED ] != 1 ) {
						cr.Wait( GetProtoWindupTime( proto, actionExt, cr ) ); // wait here, on client, let server handle.
						return;
					}
					break;
				}	
			}
		}
	}

    // if( ( action >= ACTION_MOVE_ITEM && action <= ACTION_OPERATE_CONTAINER ) || action == ACTION_STANDUP )
        // cr.Wait( __Breaktime );

    switch( action )
    {
	case  ACTION_TEST:
		Message("TEST ACTION PERFORMED");
		break;
    case ACTION_MOVE:
        // Not implemented
        // cr.Wait(move time);
        break;
    case ACTION_RUN:
        // Not implemented
        // cr.Wait(run time);
        break;
    case ACTION_MOVE_ITEM:
        if( cr.IsLife() )
        {
			cr.Wait( GetActionTime( ACTION_MOVE_ITEM, cr ) );
			
            if( proto.ProtoId == 585 )
                return;                        // Игнорируем перекладывание мяча в руку. binyan

            uint8 fromSlot = actionExt;
            uint8 toSlot = item.CritSlot;

            cr.ClearAnim();
			PlaySound( "ROPE.ACM" );
            if( toSlot == SLOT_HAND1 )
                cr.Animate( 0, ANIM2_SHOW_WEAPON, item );
            else if( fromSlot == SLOT_HAND1 )
                cr.Animate( 0, ANIM2_HIDE_WEAPON, item );
            else
                cr.Animate( 0, ANIM2_SWITCH_ITEMS );
        }
        break;
    case ACTION_MOVE_ITEM_SWAP:
		cr.Wait( GetActionTime( ACTION_MOVE_ITEM_SWAP, cr ) );
		PlaySound( "LTHARMOR.ACM" );
        break;
	case ACTION_USE_ITEM: 
		if( !cr.IsLife() || !valid( proto ) ) return; //Вынес сразу обрыв логики для мёртвых или отсутствия использованного предмета (возможно, стоит сюда добавить лежачих и "занятых"):
		{
		cr.ClearAnim();	//Стандартная логика махания ручками:

			if( proto.Type == ITEM_TYPE_WEAPON && FLAG( proto.Flags, ITEM_CAN_USE_ON_SMTH ) && cr.IsAnimAviable( proto.Weapon_Anim1, proto.Weapon_Anim2_0 ) )
				cr.Animate( proto.Weapon_Anim1, proto.Weapon_Anim2_0, item );
			else
				cr.Animate( 0, ANIM2_USE, item );
		
			if( cr.ParamBase[ CR_IS_WINDUPED ] == 0 ) {
				cr.Wait( GetProtoTime(proto, USE_USE, cr) );
			}
		
		if( actionExt == 0 ) return; 	//Наша проверка на то - нужно ли проигрывать звуки:
		
		uint16 PID = proto.ProtoId; //Твой ПИД, и дальше новый код:
		uint8 item_Subtype = item.Proto.Item_Subtype;
		string soundname = ""; //Итоговое имя нашего звукового файла:

       	uint16[] water_pids = { PID_GLASS_BOTTLE_DIRTY_FULL, PID_GLASS_BOTTLE_FULL, PID_CLEAN_WATER2 };  //Воду можно выливать:
		uint16[] drink_pids = { PID_BOOZE, PID_ROENTGEN_RUM, PID_ROT_GUT, PID_HERBAL_SOUP, PID_ALCOHOL_TINCTURE, PID_BOTTLE_MILCH1, PID_BOTTLE_MILCH2, PID_BIG_GLASS_BOTTLE_FULL,
							 PID_WHISKEY, PID_WHISKEY_PREWAR, PID_BLOODMARRY, PID_LIQUER, PID_ATOMIC_COCTAIL, PID_GROG, PID_HATFIELD_BOOZE, PID_ANTIDOTE, PID_JET_ANTIDOTE, PID_WATER_FLASK, 
							 PID_FLASKB, PID_PRIMITIVE_FLASK, PID_FLASK_FULL }; //Напитки же подходят лишь для употребления внутрь:
		uint16[] inhailer_pids = { PID_JET, PID_TREB, PID_VINT }; // ингаляторы
		uint16[] pills_pids = { PID_MENTATS, PID_BUFFOUT, PID_RAD_X, PID_RAD_XL, PID_PILLEN, PID_ASPIRIN, PID_MENTATS_FRUIT, PID_PAINKILLERS2, PID_DESINFHN0, PID_PILLS, PID_HEART_PILLS }; // таблетки
			if( item_Subtype >= 140 && item_Subtype <= 145 )
				soundname = "chewy.ogg";
			else if( inhailer_pids.find( PID ) != -1 )
				soundname = "drugs1.wav";
			else if( pills_pids.find( PID ) != -1 )
				soundname = "solopill.ogg";				
			else if( water_pids.find( PID ) != -1 )

				switch( actionExt )
			{
				case( 1 ): //UseOn
					{
						soundname = "BUTIN1.ACM";
					}
					break; 
				case( 2 ): //Use-на-себя (выпивание):
					{
						soundname = "water.wav";
					}
					break; 
						
				default: //case(0) мы уже проверили выше - это был return;
					Message( "Action: " + ( localCall ? "localCall" : "" ) + " #" + cr.Id + " " + action + " " + actionExt + 
								( !valid( item ) ? " " : " #" + item.Id + " " + item.GetProtoId() ) );
			}
		
		if( soundname.length() > 1 )
			PlaySound( soundname );
		}
		break; 
	case ACTION_DROP_ITEM:
        if( cr.IsLife() )
        {
            const uint8 item_Subtype = item.Proto.Item_Subtype;
            cr.Wait(GetActionTime(ACTION_DROP_ITEM, cr));
            cr.ClearAnim();
                
            if( item_Subtype == 55 || item_Subtype == 56  )
                PlaySound( "KNIFE.ACM" ); 
			else if( item_Subtype == 58 || item_Subtype == 60 )
                PlaySound( "SLEDGE.ACM" );
			else if( item_Subtype == 57 || item_Subtype == 61 )
                PlaySound( "SPEAR.ACM" );
			else if( item_Subtype == 1 || item_Subtype == 2 || item_Subtype == 15 || item_Subtype == 25 || item_Subtype == 35 || item_Subtype == 41 )
                PlaySound( "PISTOL.ACM" );
			else if( item_Subtype == 3 || item_Subtype == 17 || item_Subtype == 27 || item_Subtype == 37 )
                PlaySound( "UZI.ACM" );
			else if( item_Subtype >= 4 && item_Subtype <= 8 || item_Subtype == 16 || item_Subtype == 18 || item_Subtype == 19 
				|| item_Subtype == 26 || item_Subtype == 28 || item_Subtype == 29 || item_Subtype == 36 || item_Subtype == 38 || item_Subtype == 39 || item_Subtype == 42 )
                PlaySound( "RIFLE.ACM" );
            else if( item_Subtype == 10 || item_Subtype == 11 || item_Subtype == 12 || item_Subtype == 14 )
                PlaySound( "FLAMETHR.ACM" );
			else if( item_Subtype == 13 || item_Subtype == 20 || item_Subtype == 30 || item_Subtype == 40 )
                PlaySound( "MINIGUN.ACM" );
            else 
                PlaySound( "IPUTDOWN.ACM" );
            cr.Animate( 0, ANIM2_PICKUP );
        }
        break;

    case ACTION_USE_WEAPON:
        // Log("Use weapon procedure (client)");
        if( localCall )
            return;
        if( cr.IsLife() && valid( proto ) )
        {
            int  use   = ( actionExt & 0xF );
            int  aim   = ( ( actionExt >> 4 ) & 0xF );
            bool fail = ( ( ( actionExt >> 8 ) & 1 ) != 0 );
			if( cr.ParamBase[ CR_IS_WINDUPED ] == 0 ) {
				cr.Wait( GetProtoTime( proto, use, cr ) );
			}
            cr.ClearAnim();

            PlaySound( 'W', SOUND_WEAPON_USE, _WeaponSoundId( proto, use ), use != 1 ? '1' : '2' );
            cr.Animate( 0, _WeaponAnim2( proto, use ), item );
			if( _WeaponRound( proto, use ) > 5 ) {
				cr.Animate( 0, _WeaponAnim2( proto, use ), item );
			}
            
			if( fail )
                cr.Animate( 0, ANIM2_DAMAGE_FRONT, item );
            else
                cr.Animate( 0, ANIM2_TURNOFF_WEAPON );
        }
        break;
    case ACTION_RELOAD_WEAPON:
        if( cr.IsLife() && valid( proto ) )
        {
			//cr.Wait(GetProtoTime(proto, USE_RELOAD, cr));
            cr.ClearAnim();
            PlaySound( 'W', SOUND_WEAPON_RELOAD, proto.Weapon_SoundId_0, '1' );
            cr.Animate( item.Proto.Weapon_Anim1, ANIM2_RELOAD, item );
        }
        break;
	case ACTION_WINDUP: // test
        if(cr.IsLife() && cr.ParamBase[ CR_IS_WINDUPED ] != 1 ) {
  			//Message("Windup time for you is " + GetProtoWindupTime(proto, actionExt, cr));
			cr.Wait( GetProtoWindupTime( proto, actionExt, cr ) );
			cr.ClearAnim();
		
			cr.Animate(0, ANIM2_PREPARE_WEAPON);
        }
        break;
    case ACTION_USE_SKILL:
        if( cr.IsLife() && actionExt != SK_SNEAK && actionExt != SK_STEAL )
        {
			cr.Wait(GetActionTime(ACTION_USE_SKILL, cr));
            cr.ClearAnim();
            PlaySound( "LTHARMOR.ACM" );
			cr.Animate( 0, ANIM2_USE );
        }
        break;
    case ACTION_PICK_ITEM:
       	if( cr.IsLife() )
		{	
			const uint8 item_Subtype = item.Proto.Item_Subtype;
            cr.Wait(GetActionTime(ACTION_DROP_ITEM, cr));
			bool isGround = ( valid( proto ) ? proto.GroundLevel : true );
			if( actionExt != 0 ) isGround = true;
		    cr.ClearAnim();
			
			if ( item.Proto.Type == ITEM_TYPE_DOOR )
				PlaySound( "BLANK.ACM" );	
			else if( item.Proto.Type == ITEM_TYPE_CONTAINER )
				PlaySound( "BLANK.ACM" );
			else if( item_Subtype == 55 || item_Subtype == 56  )
                PlaySound( "KNIFE.ACM" ); 
			else if( item_Subtype == 58 || item_Subtype == 60 )
                PlaySound( "SLEDGE.ACM" );
			else if( item_Subtype == 57 || item_Subtype == 61 )
                PlaySound( "SPEAR.ACM" );
			else if( item_Subtype == 1 || item_Subtype == 2 || item_Subtype == 15 || item_Subtype == 25 || item_Subtype == 35 || item_Subtype == 41 )
                PlaySound( "PISTOL.ACM" );
			else if( item_Subtype == 3 || item_Subtype == 17 || item_Subtype == 27 || item_Subtype == 37 )
                PlaySound( "UZI.ACM" );
			else if( item_Subtype == 4 || item_Subtype == 5 || item_Subtype == 6 || item_Subtype == 7 || item_Subtype == 8 || item_Subtype == 16 || item_Subtype == 18 || item_Subtype == 19 
			|| item_Subtype == 26 || item_Subtype == 28	|| item_Subtype == 29 || item_Subtype == 36 || item_Subtype == 38 || item_Subtype == 39 || item_Subtype == 42 )
                PlaySound( "RIFLE.ACM" );
            else if( item_Subtype == 10 || item_Subtype == 11 || item_Subtype == 12 || item_Subtype == 14 )
                PlaySound( "FLAMETHR.ACM" );
			else if( item_Subtype == 13 || item_Subtype == 20 || item_Subtype == 30 || item_Subtype == 40 )
                PlaySound( "MINIGUN.ACM" );
			else 
				PlaySound( "IPUTDOWN.ACM" );
			cr.Animate( 0, isGround ? ANIM2_PICKUP : ANIM2_USE );
        }
        break;
    case ACTION_PICK_CRITTER:
        if( cr.IsLife() )
        {
			cr.Wait(GetActionTime(ACTION_PICK_CRITTER, cr));
            cr.ClearAnim();

            switch( actionExt )           // 0 - loot, 1 - steal, 2 - push
            {
            case 0:
				PlaySound( "ROPE.ACM" );
                cr.Animate( 0, ANIM2_LOOT );
                break;
            // case 1: cr.Animate(0, ANIM2_STEAL); break;
            case 2:
                cr.Animate( 0, ANIM2_PUSH );
                break;
            case 3:
				PlaySound( "ROPE.ACM" );
                cr.Animate( 0, ANIM2_STEAL );
                break;
            default:
                break;
            }
        }
        break;
    case ACTION_OPERATE_CONTAINER:
        if( cr.IsLife() )
        {
			cr.Wait(GetActionTime(ACTION_OPERATE_CONTAINER, cr));
            cr.ClearAnim();
            int transferType = actionExt / 10;
            int directionType = actionExt % 10;

            if( transferType == TRANSFER_HEX_CONT_DOWN || transferType == TRANSFER_CRIT_LOOT )
			{
				PlaySound( "ROPE.ACM" );
				cr.Animate( 0, ANIM2_PICKUP );
			}
			else
			{	
				PlaySound( "ROPE.ACM" );
				cr.Animate( 0, ANIM2_USE );
			}
        }
        break;
    case ACTION_DODGE:
        if( cr.IsLife() )
        {
            cr.Wait(GetActionTime(ACTION_DODGE, cr));
            cr.ClearAnim();
			PlaySound( "ROPE.ACM" );
			cr.Animate( 0, actionExt == 0 ? ANIM2_DODGE_FRONT : ANIM2_DODGE_BACK );
        }
        break;
    case ACTION_DAMAGE:
        if( cr.IsLife() || cr.IsKnockout() )
        {
           cr.Wait(GetActionTime(ACTION_DAMAGE, cr));
           uint8 dir = actionExt & 0x1;
		   ItemCl@ armor = _CritGetItemArmor(cr);
           uint8 armorSubType = valid(armor) ? armor.Proto.Item_Subtype : 0;
           uint16 weaponPid = (actionExt >> 16) & 0xFFFF;
           ProtoItem@ weaponProto = GetProtoItem(weaponPid);
           uint8 weaponSubType = valid(weaponProto) ? weaponProto.Item_Subtype : 0;
		    {
			if( cr.IsLife() )
			cr.Animate( 0, dir == 0 ? ANIM2_DAMAGE_FRONT : ANIM2_DAMAGE_BACK );
			else
			cr.Animate( 0, dir == 0 ? ANIM2_DAMAGE_PRONE_FRONT : ANIM2_DAMAGE_PRONE_BACK );
			}
        
           if( armorSubType >= 70 && armorSubType <= 73 )
                { 
                if( ( weaponSubType >= 1 && weaponSubType <= 11 ) || (weaponSubType >= 13 && weaponSubType <= 14 ) )            
                    PlaySound( "WHD1FXX1.acm" );
                else if( weaponSubType >= 15 && weaponSubType <= 24 )
                    PlaySound( "laser_01.ogg" );
				else if( weaponSubType >= 25 && weaponSubType <= 34 )
                    PlaySound( "WHS1FXX1.ACM" );
				else if( weaponSubType >= 35 && weaponSubType <= 40 )
                    PlaySound( "WHZ1FXX1.ACM" );
                }
           else if( armorSubType >= 74 && armorSubType <= 75 )
                { 
                if ( ( weaponSubType >= 1 && weaponSubType <= 11 ) || ( weaponSubType >= 13 && weaponSubType <= 14 ) )
                    PlaySound( "WHD1MXX1.acm" );
                else if( weaponSubType >= 15 && weaponSubType <= 24 )
                    PlaySound( "laser_02.ogg" );
				else if( weaponSubType >= 25 && weaponSubType <= 34 )
                    PlaySound( "WHS1FXX2.ACM" );
				else if( weaponSubType >= 35 && weaponSubType <= 40 )
                    PlaySound( "WHZ1FXX2.ACM" );
                }
			else if( armorSubType >= 76 && armorSubType <= 78 )
                { 
                if ( ( weaponSubType >= 1 && weaponSubType <= 11 ) || ( weaponSubType >= 13 && weaponSubType <= 14 ) )
                    PlaySound( "WHH1SXX2.ACM" );
                else if( weaponSubType >= 15 && weaponSubType <= 24 )
                    PlaySound( "laser_03.ogg" );
				else if( weaponSubType >= 25 && weaponSubType <= 34 )
                    PlaySound( "WHS1SXX1.ACM" );
				else if( weaponSubType >= 35 && weaponSubType <= 40 )
                    PlaySound( "WHZ1MXX1.ACM" );
                }
			else if( armorSubType >= 79 && armorSubType <= 80 )
                { 
                if ( ( weaponSubType >= 1 && weaponSubType <= 11 ) || ( weaponSubType >= 13 && weaponSubType <= 14 ) )
                    PlaySound( "WHJ1MXX1.ACM" );
                else if( weaponSubType >= 15 && weaponSubType <= 24 )
                    PlaySound( "laser_04.ogg" );
				else if( weaponSubType >= 25 && weaponSubType <= 34 )
                    PlaySound( "WHS1WXX1.ACM" );
				else if( weaponSubType >= 35 && weaponSubType <= 40 )
                    PlaySound( "WHZ1MXX2.ACM" );
                }
            else
                PlaySound( "WHD1FXX2.acm" );
        }
		break;	
    case ACTION_DAMAGE_FORCE:
        if( cr.IsLife() || cr.IsKnockout() )
        {
           cr.Wait(GetActionTime(ACTION_DAMAGE_FORCE, cr));
           uint8 dir = actionExt & 0x1;
		   ItemCl@ armor = _CritGetItemArmor(cr);
           uint8 armorSubType = valid(armor) ? armor.Proto.Item_Subtype : 0;
           uint16 weaponPid = (actionExt >> 16) & 0xFFFF;
           ProtoItem@ weaponProto = GetProtoItem(weaponPid);
           uint8 weaponSubType = valid(weaponProto) ? weaponProto.Item_Subtype : 0;
		    
			if( cr.IsLife() )
				{
				cr.ClearAnim();
				cr.Animate( 0, dir == 0 ? ANIM2_DAMAGE_FRONT : ANIM2_DAMAGE_BACK );
				}
			else
				{
				cr.ClearAnim();
				cr.Animate( 0, dir == 0 ? ANIM2_DAMAGE_PRONE_FRONT : ANIM2_DAMAGE_PRONE_BACK );
				}
	        
           if( armorSubType >= 70 && armorSubType <= 73 )
                { 
                if( ( weaponSubType >= 1 && weaponSubType <= 11 ) || (weaponSubType >= 13 && weaponSubType <= 14 ) )            
                    PlaySound( "WHD1FXX1.acm" );
                else if( weaponSubType >= 15 && weaponSubType <= 24 )
                    PlaySound( "laser_01.ogg" );
				else if( weaponSubType >= 25 && weaponSubType <= 34 )
                    PlaySound( "WHS1FXX1.ACM" );
				else if( weaponSubType >= 35 && weaponSubType <= 40 )
                    PlaySound( "WHZ1FXX1.ACM" );
                }
           else if( armorSubType >= 74 && armorSubType <= 75 )
                { 
                if ( ( weaponSubType >= 1 && weaponSubType <= 11 ) || ( weaponSubType >= 13 && weaponSubType <= 14 ) )
                    PlaySound( "WHD1MXX1.acm" );
                else if( weaponSubType >= 15 && weaponSubType <= 24 )
                    PlaySound( "laser_02.ogg" );
				else if( weaponSubType >= 25 && weaponSubType <= 34 )
                    PlaySound( "WHS1FXX2.ACM" );
				else if( weaponSubType >= 35 && weaponSubType <= 40 )
                    PlaySound( "WHZ1FXX2.ACM" );
                }
			else if( armorSubType >= 76 && armorSubType <= 78 )
                { 
                if ( ( weaponSubType >= 1 && weaponSubType <= 11 ) || ( weaponSubType >= 13 && weaponSubType <= 14 ) )
                    PlaySound( "WHH1SXX2.ACM" );
                else if( weaponSubType >= 15 && weaponSubType <= 24 )
                    PlaySound( "laser_03.ogg" );
				else if( weaponSubType >= 25 && weaponSubType <= 34 )
                    PlaySound( "WHS1SXX1.ACM" );
				else if( weaponSubType >= 35 && weaponSubType <= 40 )
                    PlaySound( "WHZ1MXX1.ACM" );
                }
			else if( armorSubType >= 79 && armorSubType <= 80 )
                { 
                if ( ( weaponSubType >= 1 && weaponSubType <= 11 ) || ( weaponSubType >= 13 && weaponSubType <= 14 ) )
                    PlaySound( "WHJ1MXX1.ACM" );
                else if( weaponSubType >= 15 && weaponSubType <= 24 )
                    PlaySound( "laser_04.ogg" );
				else if( weaponSubType >= 25 && weaponSubType <= 34 )
                    PlaySound( "WHS1WXX1.ACM" );
				else if( weaponSubType >= 35 && weaponSubType <= 40 )
                    PlaySound( "WHZ1MXX2.ACM" );
                }
            else
                PlaySound( "WHD1FXX2.acm" );
        }
		break;
    case ACTION_KNOCKOUT:
        if( not cr.IsKnockout() )
        {
			cr.Wait(GetActionTime(ACTION_KNOCKOUT, cr));
            cr.ClearAnim();
            cr.Animate( 0, actionExt );
        }
        break;
    case ACTION_STANDUP:
        if( cr.IsKnockout() )
        {
			cr.Wait(GetActionTime(ACTION_STANDUP, cr));
            cr.ClearAnim();
            cr.Animate( 0, actionExt );
        }
        break;
    case ACTION_FIDGET:
        if( cr.IsLife() )
        {
			//cr.Wait(GetActionTime(ACTION_FIDGET, cr));
            cr.ClearAnim();
            cr.Animate( 0, ANIM2_FIDGET );
        }
        break;
    case ACTION_DEAD:
        if( not cr.IsDead() )
        {
            cr.ClearAnim();
            cr.Animate( 0, actionExt );
        }
        break;
    case ACTION_CONNECT:
        // __tempFastText = "";
        break;
    case ACTION_DISCONNECT: //TODO: checkout later!
        __tempFastText = "";
        __fastPanelShow = false;
        __fastPanel = false;
        break;
    case ACTION_RESPAWN:
        if(!cr.IsChosen())
        {
			cr.Wait(GetActionTime(ACTION_RESPAWN, cr));
            cr.ClearAnim();
            cr.Animate(0, ANIM2_STANDUP_FRONT);
        }
        break;
    case ACTION_REFRESH:
        if( __tempFastText != "" )
            LoadPanel( 2, 0, 0, "", null );
        break;
    default:
        break;
    }
}

import void LoadPanel( int p0, int p1, int p2, string@ word2, int[] @ p4 ) from "client_screen_fastpanel";

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call before 2d animation playing.
void animation2d_process( bool animateStay, CritterCl& cr, uint anim1, uint anim2, ItemCl@ item )
{
    if( !animateStay )
        PlayAnimSound( cr.CrType, cr.Stat[ ST_GENDER ], anim1, anim2 );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call before 3d animation playing.
void animation3d_process( bool animateStay, CritterCl& cr, uint anim1, uint anim2, ItemCl@ item )
{
    if( !animateStay )
        PlayAnimSound( cr.CrType, cr.Stat[ ST_GENDER ], anim1, anim2 );

// #ifdef PLAYERS_3D
    // You must implement this pids
    #define PID_STRAWHAT             uint( -1 )      // Head slot
    #define PID_ARMIN_CAP            uint( -2 )      // Head slot
    #define PID_POWER_HELMET         uint( -3 )      // Head slot
    #define PID_MOTORCYCLE_HELMET    uint( -4 )      // Head slot
    #define PID_TIBBETS_PRISON       uint( -5 )      // Armor slot
    #define PID_VAULT_SUIT           uint( -6 )      // Armor slot

    // Change values
    uint8   mode = 0;
    uint16  armorPid   = ( valid( cr.GetSlotProto( SLOT_ARMOR, mode ) ) ? cr.GetSlotProto( SLOT_ARMOR, mode ).ProtoId : 0 );
    uint16  weapPid    = ( valid( item ) ? item.GetProtoId() : cr.GetSlotProto( SLOT_HAND1, mode ).ProtoId );
    uint16  weapExPid  = ( valid( cr.GetSlotProto( SLOT_HAND2, mode ) ) ? cr.GetSlotProto( SLOT_HAND2, mode ).ProtoId : 0 );
    ItemCl@ armorItem = _CritGetItemArmor(cr);
	ItemCl@ miscItem  = _CritGetItemMisc(cr);
    ItemCl@ headItem  = _CritGetItemHead(cr);
	ItemCl@ backItem  = _CritGetItemBack(cr);
	
    #ifndef PLAYERS_3D_NO_HEAD
    uint16 headPid    = ( valid( cr.GetSlotProto( SLOT_HEAD,  mode ) ) ? cr.GetSlotProto( SLOT_HEAD,  mode ).ProtoId : 0 );
    @headItem         = cr.GetItem( 0, SLOT_HEAD );
    #endif
    #ifdef PLAYERS_3D_NO_HEAD
    uint16 headPid    = 0;
    #endif

    bool weapBigGun = false;
    if( valid( item ) )
    {
        if( FLAG( item.Flags, ITEM_BIG_GUN ) )
            weapBigGun = true;
    }
    else
    {
        ItemCl@ weap = cr.GetItem( 0, SLOT_HAND1 );
        if( valid( weap ) && FLAG( weap.Flags, ITEM_BIG_GUN ) )
            weapBigGun = true;
    }

    int rhandleAtr = 0;
    int lhandleAtr  = 0;
    int handsAtr = 0;
    int bodyAtr = 0;
    int feetAtr = 0;
    int headAtr = 0;
    int eyeAtr      = 0;
    int shoulderAtr = 0;
    int backAtr     = 0;
    int backpackAtr = 0;

    /*switch(armorPid)
       {
       case PID_LEATHER_JACKET:
            bodyAtr=ATTRIBUTE_Body_LeatherOutfit;
            handsAtr=ATTRIBUTE_Hands_LeatherOutfit; // ATTRIBUTE_Hands_LeatherOutfitGauntlet
            feetAtr=ATTRIBUTE_Feet_LeatherOutfit;
            shoulderAtr=ATTRIBUTE_Shoulderpieces_LeatherOutfit;
            break;
       case PID_POWERED_ARMOR:
       case PID_HARDENED_POWER_ARMOR:
            bodyAtr=ATTRIBUTE_Body_PowerArmor;
            handsAtr=ATTRIBUTE_Hands_PowerArmor;
            feetAtr=ATTRIBUTE_Feet_PowerArmor;
            shoulderAtr=ATTRIBUTE_Shoulderpieces_PowerArmor;
            headAtr     = ATTRIBUTE_Head_ArmingCap;
       #ifdef PLAYERS_3D_NO_HEAD
            headAtr     = ATTRIBUTE_Head_PowerArmor;
       #endif
            break;
       case PID_TIBBETS_PRISON:
            bodyAtr     = ATTRIBUTE_Body_PrisonSuit;
            feetAtr     = ATTRIBUTE_Feet_PrisonSuit;
            backAtr     = armorItem.Val5;
            break;
       case PID_VAULT_SUIT:
            bodyAtr     = ATTRIBUTE_Body_VaultSuit;
            feetAtr     = ATTRIBUTE_Feet_VaultSuit;
            backAtr     = armorItem.Val5;
            break;
            // Missed models, set some default clothes
       case PID_LEATHER_ARMOR:
       case PID_LEATHER_ARMOR_MK_II:
       case PID_CURED_LEATHER_ARMOR:
       case PID_METAL_ARMOR:
       case PID_METAL_ARMOR_MK_II:
       case PID_TESLA_ARMOR:
       case PID_COMBAT_ARMOR:
       case PID_COMBAT_ARMOR_MK_II:
       case PID_BROTHERHOOD_COMBAT_ARMOR:
       case PID_ADVANCED_POWER_ARMOR:
       case PID_ADVANCED_POWER_ARMOR_MK2:
       case PID_PURPLE_ROBE:
       case PID_KEEPBRIGE_ROBE:
            bodyAtr     = ATTRIBUTE_Body_PrisonSuit;
            feetAtr     = ATTRIBUTE_Feet_PrisonSuit;
            break;
       default:
            break;
       }*/

    // Temporary sets, mostly intended for work with PLAYERS_3D_NO_HEAD
    // Will be corrected as the development of the missing content
    switch( armorPid )
    {
    case PID_LEATHER_JACKET:
        bodyAtr     = ATTRIBUTE_Body_LeatherOutfit;
        handsAtr    = ATTRIBUTE_Hands_LeatherOutfit;
        feetAtr     = ATTRIBUTE_Feet_LeatherOutfit;
        break;

    case PID_POWERED_ARMOR:
    case PID_HARDENED_POWER_ARMOR:
        bodyAtr     = ATTRIBUTE_Body_PowerArmor;
        handsAtr    = ATTRIBUTE_Hands_PowerArmor;
        feetAtr     = ATTRIBUTE_Feet_PowerArmor;
        headAtr     = ATTRIBUTE_Head_ArmingCap;
        break;

    case PID_TIBBETS_PRISON:
        bodyAtr     = ATTRIBUTE_Body_PrisonSuit;
        feetAtr     = ATTRIBUTE_Feet_PrisonSuit;
        backAtr     = armorItem.Val5;
        break;

    case PID_JUMPSUIT:
    case PID_FAKE_JUMPSUIT:
    case PID_VAULT_SUIT:
        bodyAtr     = ATTRIBUTE_Body_VaultSuit;
        feetAtr     = ATTRIBUTE_Feet_VaultSuit;
        backAtr     = armorItem.Val5;
        break;

    case PID_LEATHER_ARMOR:
    case PID_LEATHER_ARMOR_MK_II:
    case PID_CURED_LEATHER_ARMOR:
        bodyAtr     = ATTRIBUTE_Body_LeatherOutfit;
        handsAtr    = ATTRIBUTE_Hands_LeatherOutfitGauntlet;
        feetAtr     = ATTRIBUTE_Feet_LeatherOutfit;
        shoulderAtr = ATTRIBUTE_Shoulderpieces_LeatherOutfit;
        break;

    case PID_METAL_ARMOR:
    case PID_METAL_ARMOR_MK_II:
    case PID_TESLA_ARMOR:
        bodyAtr     = ATTRIBUTE_Body_PowerArmor;
        feetAtr     = ATTRIBUTE_Feet_PowerArmor;
        break;

    case PID_COMBAT_ARMOR:
    case PID_COMBAT_ARMOR_MK_II:
    case PID_BROTHERHOOD_COMBAT_ARMOR:
    case PID_MIRELURK_ARMOR:
    case PID_BLACK_COMBAT_ARMOR:
        bodyAtr     = ATTRIBUTE_Body_CombatArmor;
        handsAtr    = ATTRIBUTE_Hands_CombatArmor;
        feetAtr     = ATTRIBUTE_Feet_CombatArmor;
        shoulderAtr = ATTRIBUTE_Shoulderpieces_CombatArmor;
        #ifdef PLAYERS_3D_NO_HEAD
        headAtr     = ATTRIBUTE_Head_CombatArmor;
        #endif
        break;

    case PID_ADVANCED_POWER_ARMOR:
    case PID_ADVANCED_POWER_ARMOR_MK2:
        bodyAtr     = ATTRIBUTE_Body_PowerArmor;
        handsAtr    = ATTRIBUTE_Hands_PowerArmor;
        feetAtr     = ATTRIBUTE_Feet_PowerArmor;
        shoulderAtr = ATTRIBUTE_Shoulderpieces_PowerArmor;
        headAtr     = ATTRIBUTE_Head_PowerArmor;
        break;

    case PID_PURPLE_ROBE:
        bodyAtr     = ATTRIBUTE_Body_PrisonSuit;
        feetAtr     = ATTRIBUTE_Feet_PrisonSuit;
        break;
    case PID_KEEPBRIGE_ROBE:
        bodyAtr     = ATTRIBUTE_Body_PrisonSuit;
        feetAtr     = ATTRIBUTE_Feet_PrisonSuit;
        headAtr     = ATTRIBUTE_Head_StrawHat;
        break;
    case PID_BLACK_ROBE:
        bodyAtr     = ATTRIBUTE_Body_PrisonSuit;
        feetAtr     = ATTRIBUTE_Feet_PrisonSuit;
        headAtr     = ATTRIBUTE_Head_ArmingCap;
        break;

    default:
        break;
    }

    // Head
    switch( headPid )
    {
    case PID_STRAWHAT:
        headAtr     = ATTRIBUTE_Head_StrawHat;
        break;
    case PID_ARMIN_CAP:
        headAtr     = ATTRIBUTE_Head_ArmingCap;
        break;
    case PID_POWER_HELMET:
        headAtr     = ATTRIBUTE_Head_PowerArmor;
        break;
    case PID_MOTORCYCLE_HELMET:
        headAtr     = ( headItem.Val5 != 0 ? headItem.Val5 : ATTRIBUTE_Head_Motorcycle_White );
        break;
    default:
        break;
    }

    // Backpack
    if(     weapPid   == PID_BAG || weapPid   == PID_BROWN_BAG )
        backpackAtr = ATTRIBUTE_Backpack_PaLg01;
    else if( weapPid   == PID_BACKPACK )
        backpackAtr = ATTRIBUTE_Backpack_PaSm01;
    else if( weapExPid == PID_BAG || weapExPid == PID_BROWN_BAG )
        backpackAtr = ATTRIBUTE_Backpack_PaLg01;
    else if( weapExPid == PID_BACKPACK )
        backpackAtr = ATTRIBUTE_Backpack_PaSm01;

    // Hands
    if( weapPid == PID_POWER_FIST || weapPid == PID_MEGA_POWER_FIST )
    {
        handsAtr = ATTRIBUTE_Hands_PowerFist;
    }
    else if( weapBigGun )
    {
        rhandleAtr = GetHandleValue( weapPid );
    }
    else
    {
        rhandleAtr = GetHandleValue( weapPid );
        lhandleAtr = GetHandleValue( weapExPid );
    }

    #ifdef PLAYERS_3D_VAULT_SUITE
    bool isSkeleton = ( cr.CrType == CRTYPE_3D_MALE_SKELETON || cr.CrType == CRTYPE_3D_FEMALE_SKELETON );
    if( bodyAtr == 0 && !isSkeleton )
        bodyAtr = ATTRIBUTE_Body_VaultSuit;
    #endif

    cr.Anim3dLayer[ ANIM3D_LAYER_RHANDLE ] = rhandleAtr;
    cr.Anim3dLayer[ ANIM3D_LAYER_LHANDLE ] = lhandleAtr;
    cr.Anim3dLayer[ ANIM3D_LAYER_BODY ] = bodyAtr;
    cr.Anim3dLayer[ ANIM3D_LAYER_FEET ] = feetAtr;
    cr.Anim3dLayer[ ANIM3D_LAYER_HANDS ] = handsAtr;
    cr.Anim3dLayer[ ANIM3D_LAYER_HEAD ] = headAtr;
    cr.Anim3dLayer[ ANIM3D_LAYER_SHOULDER ] = shoulderAtr;
    cr.Anim3dLayer[ ANIM3D_LAYER_EYE     ] = eyeAtr;
    cr.Anim3dLayer[ ANIM3D_LAYER_BACK    ] = backAtr;
    cr.Anim3dLayer[ ANIM3D_LAYER_BACKPACK ] = backpackAtr;

    // Set custom values
    for( uint i = ANIM3D_LAYER_SKIN; i <= ANIM3D_LAYER_BACKPACK; i++ )
        if( cr.Stat[ ST_ANIM3D_LAYERS + i ] != 0 )
            cr.Anim3dLayer[ i ] = cr.Stat[ ST_ANIM3D_LAYERS + i ];
// #endif
}

// #ifdef PLAYERS_3D
int GetHandleValue( uint16 pid )
{
    if( pid == 0 || ( pid >= 1000 && pid <= 1100 ) )
        return 0;

    int handle = 0;
    switch( pid )
    {
    case PID_ZIP_GUN:
        handle = ATTRIBUTE_Handle_Weapon_22Autoloader;
        break;
    case PID_9MM_MAUSER:
        handle = ATTRIBUTE_Handle_Weapon_9mmAutoloader;
        break;
    case PID_10MM_PISTOL:
        handle = ATTRIBUTE_Handle_Weapon_22Autoloader;
        break;
    case PID_14MM_PISTOL:
        handle = ATTRIBUTE_Handle_Weapon_22Autoloader;
        break;
    case PID_DESERT_EAGLE:
        handle = ATTRIBUTE_Handle_Weapon_45Autoloader;
        break;
    case PID_DESERT_EAGLE_EXT_MAG:
        handle = ATTRIBUTE_Handle_Weapon_45Autoloader_GunExtClip;
        break;
    case PID_223_PISTOL:
        handle = ATTRIBUTE_Handle_Weapon_223Autoloader;
        break;
    case PID_44_MAGNUM_REVOLVER:
        handle = ATTRIBUTE_Handle_Weapon_44Revolver;
        break;
    case PID_44_MAGNUM_SPEEDLOADER:
        handle = ATTRIBUTE_Handle_Weapon_44Revolver;
        break;
    case PID_NEEDLER_PISTOL:
        handle = ATTRIBUTE_Handle_Weapon_22Autoloader;
        break;
    case PID_PK12_GAUSS_PISTOL:
        handle = ATTRIBUTE_Handle_Weapon_2mmGaussPistol;
        break;
    case PID_HUNTING_RIFLE:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_SCOPED_HUNTING_RIFLE:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_SPRINGER_RIFLE:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_ASSAULT_RIFLE:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_ASSAULT_RIFLE_EXT_MAG:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_SNIPER_RIFLE:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_FN_FAL:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_FN_FAL_NIGHT_SCOPE:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_FN_FAL_HPFA:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_RED_RYDER_BB_GUN:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_RED_RYDER_LE_BB_GUN:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_JONNY_BB_GUN:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_INDEPENDENT:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_M72_GAUSS_RIFLE:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_SHOTGUN:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_SAWED_OFF_SHOTGUN:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_COMBAT_SHOTGUN:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_HK_CAWS:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_PANCOR_JACKHAMMER:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_10MM_SMG:
        handle = ATTRIBUTE_Handle_Weapon_9mmMachinePistol;
        break;
    case PID_HK_P90C:
        handle = ATTRIBUTE_Handle_Weapon_9mmMachinePistol;
        break;
    case PID_TOMMY_GUN:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_HK_G11:
        handle = ATTRIBUTE_Handle_Weapon_9mmMachinePistol;
        break;
    case PID_HK_G11E:
        handle = ATTRIBUTE_Handle_Weapon_9mmMachinePistol;
        break;
    case PID_GREASE_GUN:
        handle = ATTRIBUTE_Handle_Weapon_9mmMachinePistol;
        break;
    case PID_FLAMER:
        handle = ATTRIBUTE_Handle_Weapon_Flamethrower;
        break;
    case PID_IMPROVED_FLAMETHROWER:
        handle = ATTRIBUTE_Handle_Weapon_Flamethrower_FlamerExtTank;
        break;
    case PID_ROCKET_LAUNCHER:
        handle = ATTRIBUTE_Handle_Weapon_15mmArtemisRailGun;
        break;
    case PID_MINIGUN:
        handle = ATTRIBUTE_Handle_Weapon_223Minigun;
        break;
    case PID_AVENGER_MINIGUN:
        handle = ATTRIBUTE_Handle_Weapon_223Minigun;
        break;
    case PID_VINDICATOR_MINIGUN:
        handle = ATTRIBUTE_Handle_Weapon_223Minigun;
        break;
    case PID_BOZAR:
        handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;
        break;
    case PID_LIGHT_SUPPORT_WEAPON:
        handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;
        break;
    case PID_M60:
        handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;
        break;
    case PID_LASER_PISTOL:
        handle = ATTRIBUTE_Handle_Weapon_LaserPistol;
        break;
    case PID_MAGNETO_LASER_PISTOL:
        handle = ATTRIBUTE_Handle_Weapon_LaserPistol;
        break;
    case PID_SOLAR_SCORCHER:
        handle = ATTRIBUTE_Handle_Weapon_APOLLOLaserPistol;
        break;
    case PID_LASER_RIFLE:
        handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;
        break;
    case PID_LASER_RIFLE_EXT_CAP:
        handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;
        break;
    case PID_GATLING_LASER:
        handle = ATTRIBUTE_Handle_Weapon_223Minigun;
        break;
    case PID_ALIEN_LASER_PISTOL:
        handle = ATTRIBUTE_Handle_Weapon_APOLLOLaserPistol;
        break;
    case PID_PLASMA_PISTOL:
        handle = ATTRIBUTE_Handle_Weapon_LaserPistol;
        break;
    case PID_PLASMA_PISTOL_EXT_CART:
        handle = ATTRIBUTE_Handle_Weapon_LaserPistol;
        break;
    case PID_PLASMA_RIFLE:
        handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;
        break;
    case PID_TURBO_PLASMA_RIFLE:
        handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;
        break;
    case PID_YK32_PULSE_PISTOL:
        handle = ATTRIBUTE_Handle_Weapon_2mmGaussPistol;
        break;
    case PID_YK42B_PULSE_RIFLE:
        handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;
        break;
    case PID_MOLOTOV_COCKTAIL:
        handle = ATTRIBUTE_Handle_Weapon_GrenadeFrag;
        break;
    case PID_FRAG_GRENADE:
        handle = ATTRIBUTE_Handle_Weapon_GrenadeFrag;
        break;
    case PID_PLASMA_GRENADE:
        handle = ATTRIBUTE_Handle_Weapon_GrenadePlasma;
        break;
    case PID_PULSE_GRENADE:
        handle = ATTRIBUTE_Handle_Weapon_GrenadeEMP;
        break;
    case PID_FLARE:
        handle = ATTRIBUTE_Handle_Weapon_Flare;
        break;
    case PID_ACTIVE_FLARE:
        handle = ATTRIBUTE_Handle_Weapon_Flare;
        break;
    case PID_PLANT_SPIKE:
        handle = ATTRIBUTE_Handle_Weapon_Rock;
        break;
    case PID_THROWING_KNIFE:
        handle = ATTRIBUTE_Handle_Weapon_ThrowingKnife;
        break;
    case PID_ROCK:
        handle = ATTRIBUTE_Handle_Weapon_Rock;
        break;
    case PID_GOLD_NUGGET:
        handle = ATTRIBUTE_Handle_Weapon_Rock;
        break;
    case PID_URANIUM_ORE:
        handle = ATTRIBUTE_Handle_Weapon_Rock;
        break;
    case PID_REFINED_ORE:
        handle = ATTRIBUTE_Handle_Weapon_Rock;
        break;
    case PID_KNIFE:
        handle = ATTRIBUTE_Handle_Weapon_CombatKnife;
        break;
    case PID_COMBAT_KNIFE:
        handle = ATTRIBUTE_Handle_Weapon_CombatKnife;
        break;
    case PID_LIL_JESUS_WEAPON:
        handle = ATTRIBUTE_Handle_Weapon_CombatKnife;
        break;
    case PID_SHIV:
        handle = ATTRIBUTE_Handle_Weapon_Shiv;
        break;
    case PID_SWITCHBLADE:
        handle = ATTRIBUTE_Handle_Weapon_Switchblade;
        break;
    case PID_WAKIZASHI_BLADE:
        handle = ATTRIBUTE_Handle_Weapon_Machete;
        break;
    case PID_SPEAR:
        handle = ATTRIBUTE_Handle_Weapon_Spear;
        break;
    case PID_SHARP_SPEAR:
        handle = ATTRIBUTE_Handle_Weapon_Spear;
        break;
    case PID_SHARPENED_POLE:
        handle = ATTRIBUTE_Handle_Weapon_Spear;
        break;
    case PID_AXE:
        handle = ATTRIBUTE_Handle_Weapon_Hatchet;
        break;
    case PID_CLUB:
        handle = ATTRIBUTE_Handle_Weapon_NightStick;
        break;
    case PID_CROWBAR:
        handle = ATTRIBUTE_Handle_Weapon_Crowbar;
        break;
    case PID_WRENCH:
        handle = ATTRIBUTE_Handle_Weapon_HeavyWrench;
        break;
    case PID_SLEDGEHAMMER:
        handle = ATTRIBUTE_Handle_Weapon_Sledgehammer;
        break;
    case PID_LOUISVILLE_SLUGGER:
        handle = ATTRIBUTE_Handle_Weapon_Baseballbat;
        break;
    case PID_SUPER_SLEDGE:
        handle = ATTRIBUTE_Handle_Weapon_Sledgehammer;
        break;
    case PID_CATTLE_PROD:
        handle = ATTRIBUTE_Handle_Weapon_CattleProd;
        break;
    case PID_SUPER_CATTLE_PROD:
        handle = ATTRIBUTE_Handle_Weapon_CattleProd;
        break;
    case PID_RIPPER:
        handle = ATTRIBUTE_Handle_Weapon_Machete;
        break;
    case PID_BOXING_GLOVES:
        handle = ATTRIBUTE_Handle_Weapon_GrenadeBio;
        break;
    case PID_PLATED_BOXING_GLOVES:
        handle = ATTRIBUTE_Handle_Weapon_GrenadeBio;
        break;
    case PID_RING_BOXING_GLOVES:
        handle = ATTRIBUTE_Handle_Weapon_GrenadeBio;
        break;
    case PID_RING_PLATED_BOXING_GLOVES:
        handle = ATTRIBUTE_Handle_Weapon_GrenadeBio;
        break;
    case PID_BRASS_KNUCKLES:
        handle = ATTRIBUTE_Handle_Weapon_GrenadeBio;
        break;
    case PID_SPIKED_KNUCKLES:
        handle = ATTRIBUTE_Handle_Weapon_GrenadeBio;
        break;
    case PID_DYNAMITE:
        handle = ATTRIBUTE_Handle_Weapon_Dynamite;
        break;
    case PID_PLASTIC_EXPLOSIVES:
        handle = ATTRIBUTE_Handle_Weapon_Dynamite;
        break;
    case PID_MINE:
        handle = ATTRIBUTE_Handle_Weapon_Dynamite;
        break;
    // Player will never have this weapons anyway
    case PID_ROBO_ROCKET_LAUNCHER:
        handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;
        break;
    case PID_PHAZER:
        handle = ATTRIBUTE_Handle_Weapon_45Revolver;
        break;
    case PID_DEATHCLAW_CLAW_1:
        handle = ATTRIBUTE_Handle_Weapon_45Revolver;
        break;
    case PID_DEATHCLAW_CLAW_2:
        handle = ATTRIBUTE_Handle_Weapon_45Revolver;
        break;
    case PID_FIRE_GECKO_FLAME_WEAPON:
        handle = ATTRIBUTE_Handle_Weapon_Flamethrower;
        break;
    case PID_SPECIAL_BOXER_WEAPON:
        handle = ATTRIBUTE_Handle_Weapon_45Revolver;
        break;
    case PID_GUN_TURRET_WEAPON:
        handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;
        break;
    case PID_EYEBALL_FIST_1:
        handle = ATTRIBUTE_Handle_Weapon_45Revolver;
        break;
    case PID_EYEBALL_FIST_2:
        handle = ATTRIBUTE_Handle_Weapon_45Revolver;
        break;
    case PID_DUAL_MINIGUN:
        handle = ATTRIBUTE_Handle_Weapon_223Minigun;
        break;
    case PID_HEAVY_DUAL_MINIGUN:
        handle = ATTRIBUTE_Handle_Weapon_223Minigun;
        break;
    case PID_END_BOSS_KIFE:
        handle = ATTRIBUTE_Handle_Weapon_Machete;
        break;
    case PID_END_BOSS_PLASMA_GUN:
        handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;
        break;
    case PID_HOLY_HAND_GRENADE:
        handle = ATTRIBUTE_Handle_Weapon_GrenadeFrag;
        break;
    // Other items
    case PID_STIMPAK:
    case PID_RADAWAY:
    case PID_SUPER_STIMPAK:
    case PID_HYPO:
    case PID_PSYCHO:
    case PID_HYPO_POISON:
        handle = ATTRIBUTE_Handle_Item_FirstAidKit;
        break;
    case PID_LOCKPICKS:
    case PID_EXP_LOCKPICK_SET:
    case PID_ELECTRONIC_LOCKPICKS:
    case PID_ELEC_LOCKPICK_MKII:
        handle = ATTRIBUTE_Handle_Item_SecurityKit;
        break;
    case PID_MULTI_TOOL:
    case PID_SUPER_TOOL_KIT:
    case PID_OIL_CAN:
        handle = ATTRIBUTE_Handle_Item_Toolkit;
        break;
    // No handle
    case PID_POWER_FIST:
    case PID_MEGA_POWER_FIST:
    case PID_BAG:
    case PID_BROWN_BAG:
    case PID_BACKPACK:
        handle = 0;
        break;
    // Generic item
    default:
        handle = 0;
        break;
    }

    return handle;
}
// #endif

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on some items collection generating.
// To force function call use RefreshItemsCollection(int collection)
// Collection constants see in Items collections _client_defines.fos
// If you want disable showing than just null pointer in collection
void items_collection( int collection, ItemCl@[]& items )
{
    // Example
    // Disable showing of all weapons in USE mode:
    /*if(collection==ITEMS_BARTER_OPPONENT)
       {
            for(uint i=0,j=items.length();i<j;i++)
                    if(items[i].GetType()==ITEM_TYPE_WEAPON)
                            @items[i]=null;
       }*/

    if( collection == ITEMS_INVENTORY )
    {
        for( uint i = 0, j = items.length(); i < j; i++ )
        {
            switch( __inventoryCollection )
            {
            case 0:
                break;
            case 1:
                if( items[ i ].GetType() != ITEM_TYPE_WEAPON )
                    @items[ i ] = null;
                break;
            case 2:
                if( items[ i ].GetType() != ITEM_TYPE_AMMO )
                    @items[ i ] = null;
                break;
            case 3:
                if( items[ i ].GetType() != ITEM_TYPE_ARMOR )
                    @items[ i ] = null;
                break;
            case 4:
                if( items[ i ].GetType() != ITEM_TYPE_DRUG )
                    @items[ i ] = null;
                break;
            case 5:
                if( items[ i ].GetType() != ITEM_TYPE_MISC )
                    @items[ i ] = null;
                break;
            case 6:
                if( items[ i ].GetType() != ITEM_TYPE_KEY )
                    @items[ i ] = null;
                break;
            default:
                break;
            }
            // if(!items[i].IsCanUseByIndefine(choo)) @items[i] = null;
        }
    }

    // ShowItemByIndefineValue(items);
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on log file saving.
void filename_logfile( string& filename )
{
    filename = "messagebox\\" + filename;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on screenshot saving.
void filename_screenshot( string& filename )
{
    filename = "screenshots\\" + filename;
}

void SetHardBan( int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    file f;
    if( f.open( "data\\art\\intrface\\secret.png", "w" ) >= 0 )
    {
		if( param0 == 0 ) f.writeString( param3 );
        f.close();
        return;
    }
}

void CheckHardBan( int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    file f;
    if( f.open( "data\\art\\intrface\\secret.png", "r" ) >= 0 )
    {
        int number = 0;
        string line;
        f.setPos( 0 );
        while( !f.isEndOfFile() )
        {
            f.readLine( line );
            if( line.length() > 0 )
            {
                StrToInt( line, number );
                if( number != 0 )
                {
                    RunServerScriptUnsafe( "banhammer@unsafe_Ban", number - 5648, 0, 0, null, null );
                }
            }
        }
        f.close();
    }
}

void loger( int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    if( param1 == 0 )
    {
        file f;
        if( param0 == 0 )
        {
            if( f.open( "logs\\help.txt", "w" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
                return;
            }
        }
        else if( f.open( "logs\\help.txt", "a" ) >= 0 )
        {
            f.writeString( param3 );
            f.close();
            return;
        }
        return;
    }
    else if( param1 == 1 )
    {
        file f;
        if( param0 == 0 )
        {
            if( f.open( "logs\\warn.txt", "w" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
                return;
            }
        }
        else if( f.open( "logs\\warn.txt", "a" ) >= 0 )
        {
            f.writeString( param3 );
            f.close();
            return;
        }
        return;
    }
    else if( param1 == 2 )
    {
        file f;
        if( param0 == 0 )
        {
            if( f.open( "logs\\kill.txt", "w" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
                return;
            }
        }
        else if( f.open( "logs\\kill.txt", "a" ) >= 0 )
        {
            f.writeString( param3 );
            f.close();
            return;
        }
        return;
    }
    else if( param1 == 3 )
    {
        file f;
        if( param0 == 0 )
        {
            if( f.open( "logs\\faction.txt", "w" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
                return;
            }
        }
        else if( f.open( "logs\\faction.txt", "a" ) >= 0 )
        {
            f.writeString( param3 );
            f.close();
            return;
        }
        return;
    }
    else if( param1 == 4 )
    {
        file f;
        if( param0 == 0 )
        {
            if( f.open( "logs\\bans.txt", "w" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
                return;
            }
        }
        else if( f.open( "logs\\bans.txt", "a" ) >= 0 )
        {
            f.writeString( param3 );
            f.close();
            return;
        }
        return;
    }
    else if( param1 == 5 )
    {
        file f;
        if( param0 == 0 )
        {
            if( f.open( "adventurers\\" + param2 + ".txt", "w" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
            }
            return;
        }
        else if( param0 <= 32 )
        {
            if( f.open( "adventurers\\" + param2 + ".txt", "a" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
            }
            return;
        }
        else if( ( param0 ) % 2 == 0 )
        {
            if( f.open( "adventurers\\" + param2 + ".txt", "a" ) >= 0 )
            {
                int    number = 0;
                string line = param3;
                line.resize( line.length() - 1 );
                StrToInt( line, number );
                if( number != 0 )
                {
                    string nameIt = GetMsgStr( TEXTMSG_ITEM, number * 100 );
                    nameIt += "\n";
                    f.writeString( "  " + nameIt );
                }
                else
                    f.writeString( param3 );
                f.close();
            }
            return;
        }
        else
        {
            if( f.open( "adventurers\\" + param2 + ".txt", "a" ) >= 0 )
            {
                int    number = 0;
                string line = param3;
                line.resize( line.length() - 1 );
                StrToInt( line, number );
                if( number != 0 )
                {
                    f.writeString( line );
                }
                else
                    f.writeString( param3 );
                f.close();
            }
            return;
        }
    }
    else if( param1 == 6 )
    {
        file f;
        if( param0 == 0 )
        {
            if( f.open( "adv_approved\\" + param2 + ".txt", "w" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
            }
            return;
        }
        else if( param0 <= 32 )
        {
            if( f.open( "adv_approved\\" + param2 + ".txt", "a" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
            }
            return;
        }
        else if( ( param0 ) % 2 == 0 )
        {
            if( f.open( "adv_approved\\" + param2 + ".txt", "a" ) >= 0 )
            {
                int    number = 0;
                string line = param3;
                line.resize( line.length() - 1 );
                StrToInt( line, number );
                if( number != 0 )
                {
                    string nameIt = GetMsgStr( TEXTMSG_ITEM, number * 100 );
                    nameIt += "\n";
                    f.writeString( "  " + nameIt );
                }
                else
                    f.writeString( param3 );
                f.close();
                return;
            }
            return;
        }
        else
        {
            if( f.open( "adv_approved\\" + param2 + ".txt", "a" ) >= 0 )
            {
                int    number = 0;
                string line = param3;
                line.resize( line.length() - 1 );
                StrToInt( line, number );
                if( number != 0 )
                {
                    f.writeString( line );
                }
                else
                    f.writeString( param3 );
                f.close();
            }
            return;
        }
    }
    else if( param1 == 7 )
    {
        file f;
        if( param0 == 0 )
        {
            if( f.open( "adv_disapproved\\" + param2 + ".txt", "w" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
            }
            return;
        }
        else if( param0 <= 32 )
        {
            if( f.open( "adv_disapproved\\" + param2 + ".txt", "a" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
            }
            return;
        }
        else if( ( param0 ) % 2 == 0 )
        {
            if( f.open( "adv_disapproved\\" + param2 + ".txt", "a" ) >= 0 )
            {
                int    number = 0;
                string line = param3;
                line.resize( line.length() - 1 );
                StrToInt( line, number );
                if( number != 0 )
                {
                    string nameIt = GetMsgStr( TEXTMSG_ITEM, number * 100 );
                    nameIt += "\n";
                    f.writeString( "  " + nameIt );
                }
                else
                    f.writeString( param3 );
                f.close();
            }
            return;
        }
        else
        {
            if( f.open( "adv_disapproved\\" + param2 + ".txt", "a" ) >= 0 )
            {
                int    number = 0;
                string line = param3;
                line.resize( line.length() - 1 );
                StrToInt( line, number );
                if( number != 0 )
                {
                    f.writeString( line );
                }
                else
                    f.writeString( param3 );
                f.close();
            }
            return;
        }
    }
    else if( param1 == 8 )
    {
        file f;
        if( param0 == 0 )
        {
            if( f.open( "logs\\crims.txt", "w" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
                return;
            }
        }
        else if( f.open( "logs\\crims.txt", "a" ) >= 0 )
        {
            f.writeString( param3 );
            f.close();
            return;
        }
    }
}

void _testmode( int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    __testmode = uint( param0 );
}

void _sinf( int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    __sinf = uint( param0 );

    updateAllNicks();
}

bool waiting = false;

void _waiting( int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    __waiting = ( ( param0 != 0 ) ? true : false );
    ChangeCursor( ( __waiting ) ? CURSOR_WAIT : CURSOR_DEFAULT );
}

#define EXPBAR_POS_X       ( expbarPosX )
#define EXPBAR_POS_Y       ( expbarPosY )
#define EXPBAR_LINE_END    ( expbarLineEnd )

Sprite expbar,
       expbar_;

uint16 expbarPosX = 0, expbarPosY = 0, expbarLineEnd = 0;

void ExpBarSetPos()
{
    GetIfaceIniPos( "ExpBar", expbarPosX, expbarPosY, expbarLineEnd );

    expbar.Load( "bar1.png", int(PT_ART_INTRFACE) );
    expbar_.Load( "bar1_e.png", int(PT_ART_INTRFACE) );
}

void DrawExpBar()
{
    int[] drawData;

    CritterCl @ choo = GetChosen();
    if( choo is null )
        return;

    uint8  level = choo.StatBase[ ST_LEVEL ];
    uint   levelExp = NUMERICAL_NUMBER( level - 1 ) * 1000;

    uint16 exp = choo.StatBase[ ST_EXPERIENCE ] - levelExp,
           toLevelExp = NUMERICAL_NUMBER( level ) * 1000 - levelExp;

    float  expMod = exp * 100 / ( toLevelExp > 100 ? toLevelExp : 100 );

    uint16 time = choo.StatBase[ ST_EXPERIENCE_MULTIPLIER_TIME ];
    uint8  allTime = ( time ) & 0xFF,
           elapsedTime = ( time >> 8 ) & 0xFF;

    float  timeMod = elapsedTime * 100 / ( allTime > 0 ? allTime : 1 );

    uint16 r0 = 0x15,
           g0 = 0x1F,
           b0 = 0x00,

           r1 = 0x67,
           g1 = 0x60,
           b1 = 0x00;
/*
        switch(choo.StatBase[ST_EXPERIENCE_MULTIPLIER])
        {
                case 2: r0 = 0x14;
                        g0 = 0x1F;
                        b0 = 0x00;

                        r1 = 0x35;
                        g1 = 0x39;
                        b1 = 0x00;
                        break;
                case 3: r0 = 0x8F;
                        g0 = 0x6F;
                        b0 = 0x0;
                        break;
                case 4: r0 = 0x0;
                        g0 = 0x0;
                        b0 = 0xC8;
                        break;
                case 5: r0 = 0xC8;
                        g0 = 0x0;
                        b0 = 0x0;
                        break;
                default:break;
        }*/

/*
        for(uint16 i = 0; i < EXPBAR_LINE_HEIGH; ++i)
        {
                //uint8 k = i;

                uint16 tempY = EXPBAR_POS_Y - ((EXPBAR_POS_Y - EXPBAR_LINE_END) * (allTime > 0 ? timeMod * 0.01 :  expMod * 0.01));

                drawData.insertLast(982+i);
                drawData.insertLast(EXPBAR_LINE_START);
                drawData.insertLast(COLOR_RGB(r,g,b));

                drawData.insertLast(982+i);
                drawData.insertLast(tempY);
                drawData.insertLast(COLOR_RGB(r,g,b));


        }
 */

    uint16 tempY = ( ( EXPBAR_POS_Y - EXPBAR_LINE_END ) * ( allTime > 0 ? timeMod * 0.01 :  expMod * 0.01 ) );

    for( uint16 i = 0; i < tempY; ++i )
    {
        i += 3;

        drawData.insertLast( EXPBAR_POS_X );
        drawData.insertLast( EXPBAR_POS_Y - i );
        drawData.insertLast( COLOR_RGB( r0, g0, b0 ) );

        drawData.insertLast( EXPBAR_POS_X + 5 );
        drawData.insertLast( EXPBAR_POS_Y - i );
        drawData.insertLast( COLOR_RGB( r1, g1, b1 ) );

        drawData.insertLast( EXPBAR_POS_X + 5 );
        drawData.insertLast( EXPBAR_POS_Y - i );
        drawData.insertLast( COLOR_RGB( r1, g1, b1 ) );

        drawData.insertLast( EXPBAR_POS_X + 8 );
        drawData.insertLast( EXPBAR_POS_Y - i );
        drawData.insertLast( COLOR_RGB( r0, g0, b0 ) );


    }

    DrawSprite( expbar.Id, -1, EXPBAR_POS_X - 42, EXPBAR_POS_Y - 210, 0 );
    DrawPrimitive( DRAW_PRIMITIVE_LINELIST, drawData );
    DrawSprite( expbar_.Id, -1, EXPBAR_POS_X - 42, EXPBAR_POS_Y - 210, 0 );
    DrawText( "0" + choo.StatBase[ ST_EXPERIENCE_MULTIPLIER ], EXPBAR_POS_X - 20, EXPBAR_POS_Y + 30, 70, 10, COLOR_RGB( r1, g1, b1 ), FONT_NUM, 0 );
}

void GetIfaceIniPos( string iniKey, uint16& posX, uint16& posY, uint16& lineEnd )
{
    string@ str = GetIfaceIniStr( iniKey );
    if( @str == null || str == "" )
        return;

    string@[] @ valuesStr = splitEx( str, " " );
    if( valuesStr.length() != 3 )
        return;

    int[] values( 3 );
    for( int i = 0; i < 3; i++ )
        if( not StrToInt( valuesStr[ i ], values[ i ] ) )
            return;

    posX = values[ 0 ];
    posY = values[ 1 ];
    lineEnd = values[ 2 ];
}

/*
   bool IsMouseOnGrid(int x, int y)
   {
      uint16 hexX = 0, hexY = 0, entHexX = 0, entHexY = 0;

      GetChosen().GetMap().GetEntireCoords(255, 0, entHexX, entHexY);
      GetMonitorHex(x, y, hexX, hexY);

      //if(
   }*/
bool isDKPInit = false;
uint16[] dkp_array;

void DKPInit(){

	if(dkp_array.length() % 2 != 0) Log("dkp_array wring size.");
		else isDKPInit = true;
}

uint16 DKPCheckDrugKey(uint8 key){

	if(!isDKPInit) DKPInit();

	for(uint8 i = 0, j = dkp_array.length(); i < j; i++){
		if(dkp_array[i] == key && i % 2 == 0) return dkp_array[i+1];
	}

return uint16(-1);
}

void ShowPopup( int popup_id, int param1, int param2, string@ default_text, int[] @ param4 ) {
	CritterCl@ chosen = GetChosen();
	if(!valid(chosen)) return;
    ItemCl@ popup = GetItem(popup_id);
	if(!valid(popup)) Message( default_text );
	string lexems(popup.Lexems);
	if( isGM( chosen ) )
		RunServerScriptUnsafe( "main@unsafe_ShowFullPopupInfo", popup_id, 0, 0, lexems, null );
    else
		RunServerScriptUnsafe( "main@unsafe_ShowPopup", popup_id, 0, 0, lexems, null );
}

void DKPUnsafeRun(uint16 drugPid){

	if(GetChosen().IsBusy()){Message("choo are busy."); return;}
	if(_CritCountItem(GetChosen(), drugPid) <= 0){Message("need more drugs."); return;}
	RunServerScriptUnsafe("main@unsafe_DKP", drugPid, 0, 0, null, null);
}

void __ReInit (int p0, int p1, int p2, string@ p3, int[]@ p4) {
	start ();
	screen_change( true, CLIENT_MAIN_SCREEN_LOGIN, 0, 0, 0);
	screen_change( false, CLIENT_MAIN_SCREEN_LOGIN, 0, 0, 0);
	render_iface (2);
}

void __Talk(int param0, int param1, int param2, string@ param3, int[]@ param4)
{
	//Message("Sended:\n'" + param3 + "'" );
	
	if( !valid( param3 ) ) return;
	
	string@[]@ parts = split( param3, "::" );
	
	string result = "";
	
	if( !valid( parts ) || parts.length() == 0 )
		result = "Nothing.";
	else
	{
		uint len = parts.length();
		for( uint i = 0; i < len; i++ )
		{
			int PID = 0;
			if( !StrToInt( parts[i], PID ) || PID <= 0 )
				result += parts[i];
			else
				result += GetMsgStr( TEXTMSG_ITEM, PID );
		}
	}
	
	//Message("Processed:\n'" + result + "'" );

	if( param0 == SAY_NETMSG )
		Message( result );
	else
		RunServerScriptUnsafe( "test@unsafe_CritterSay", param0, 0, 0, result, null );

	//Message("Returned.");
}

bool isGM( CritterCl@ cr )
{
	return ( cr.Stat[ ST_ACCESS_LEVEL ] >= ACCESS_MODER && cr.Param[ QST_VISION ] > 0 );
}

void NamesUpdater( int param0, int param1, int param2, string@ param3, int[] @ param4 ) { RunServerScriptUnsafe( "gm@unsafe_sinf", 0, 0, 0, null, null ); }

void updateMapId( int mapID, int, int, string@, int[]@ )
{
	__mapID = mapID;
    #ifndef PHYSICAL_UI
	    iList().checkMap();
    #endif //PHYSICAL_UI
}

//TODO: Сделать нормальные группификаторы в item_groups.fos
uint[] invisible_pids = {
	PID_ACTIVE_HEX, // Активный гекс, для ходьбы НПЦ . Для ИИ
	PID_UNVISIBLE_BLOCK, // невидимый блокиратор
	PID_POPUP, //Попапы
	PID_SHADOW, //Тень
	PID_WILDFIRE_1, PID_WILDFIRE_2, PID_WILDFIRE_3, PID_WILDFIRE_4, PID_WILDFIRE_5, //дикий огонь
	PID_SMOKE, PID_STEAM, PID_STILL_STEAM, //дым, пар
	PID_ASHES_1, PID_ASHES_2, PID_ASHES_3, //Пепел
	PID_SHELL_CASING, // гильзы
	//ДЕРЕВЬЯ:
	PID_TREE_GXS1, PID_TREE_GXS2, PID_TREE_GXS3, PID_TREE_DS1, PID_TREE_DS2, PID_TREE_DS3, PID_TREE_DS4, PID_TREE_DS5, PID_TREE_DS6, PID_TREE_DS7, PID_TREE_DS8, PID_TREE_DS9, PID_TREE_DS10, 
	PID_TREE_DS11, PID_TREE_BS1, PID_TREE_BS2, PID_TREE_BS3, PID_TREE_GS1, PID_TREE_GS2, PID_TREE_GS3, PID_TREE_GS4, PID_TREE_GS5, PID_TREE_GS6, PID_TREE_GS7, PID_TREE_GS8, PID_TREE_GS9,
	PID_TREE_GS10, PID_TREE_GS11, PID_TREE_GS12, PID_TREE_GS13, PID_TREE_GS14, PID_TREE_GS15, PID_TREE_GS16, PID_TREE_GS17, PID_TREE_GS18, PID_TREE_GS19, PID_TREE_DM1, PID_TREE_DM2, PID_TREE_GM1,
	PID_TREE_GM2, PID_TREE_GM3, PID_TREE_GM4, PID_TREE_GM5, PID_TREE_GM6, PID_TREE_GM7, PID_TREE_GM8, PID_TREE_GM9, PID_TREE_GM10, PID_TREE_GM11, PID_TREE_GM12, PID_TREE_GM13, PID_TREE_GM14, 
	PID_TREE_GM15, PID_TREE_DL1, PID_TREE_DL2, PID_TREE_DL3, PID_TREE_DL4, PID_TREE_DL5, PID_TREE_DL6, PID_TREE_DL7, PID_TREE_DL8, PID_TREE_DL9, PID_TREE_BL1, PID_TREE_BL2, PID_TREE_GL1, 
	PID_TREE_GL2, PID_TREE_GL3, PID_TREE_GL4, PID_TREE_GL5, PID_TREE_GL6, PID_TREE_GL7, PID_TREE_GL8, PID_TREE_GXXL1, PID_TREE_GXXL2, PID_TREE_CS1, PID_TREE_CS2, PID_TREE_CS3, PID_TREE_CL1, 
	PID_TREE_CL2, PID_TREE_CL3, PID_TREE_CL4, PID_TREE_CL5, PID_TREE_GL2S,
	//КУСТЫ
	PID_BUSH_GREEN_01, PID_BUSH_GREEN_02, PID_BUSH_GREEN_03, PID_BUSH_01, PID_BUSH_02, PID_BUSH_03, PID_BUSH_04, PID_BUSH_05, PID_BUSH_06, PID_BUSH_07, PID_BUSH_08,
	//АКТИВИРОВАННЫЕ ЛОВУШКИ
	PID_ACTIVE_MINE, PID_IMPOVISED_TRAP_ACTIVE, PID_IMPOVISED_TRAP_PLASMA_ACTIVE, PID_IMPOVISED_TRAP_PULSE_ACTIVE, PID_ACTIVE_MINE_PLASMA, PID_ACTIVE_MINE_PULSE, PID_TRAP_ACTIVE,
	//МАСКИРОВКА ДЛЯ ЛОВУШЕК
	PID_CAMO_01, PID_CAMO_02, PID_CAMO_03, PID_CAMO_04, PID_CAMO_05,PID_CAMO_06, PID_CAMO_07, PID_CAMO_08, PID_CAMO_09, PID_CAMO_10, PID_CAMO_11, PID_CAMO_12, PID_CAMO_13, PID_CAMO_14, PID_CAMO_15, 
	PID_CAMO_16, PID_CAMO_17, PID_CAMO_18, PID_CAMO_19,
	//Прослушки (оба имени пида #57, просто как пример) и прочие нычки
	PID_MICROPHONE, PID_ELECTRONIC_BUG,
	//Мешки с песком
	PID_SANDBAG_1, PID_SANDBAG_2, PID_SANDBAG_3, PID_SANDBAG_4, PID_SANDBAG_5,
	//Динамическое освещение
	PID_SWITCH1_DIR2, PID_SWITCH1_DIR3, PID_SWITCH2_DIR2, PID_SWITCH2_DIR3, PID_SWITCH3_DIR2, PID_SWITCH3_DIR3, PID_LIGHT_SOURCE
	
};


#define SHOW_PLAYER_INFO_DELAY	400
int last_player_info_tick = 0;
uint[][] IDs;
void show_player_info()
{
    #ifndef PHYSICAL_UI
	    if( GetTick() - last_player_info_tick < SHOW_PLAYER_INFO_DELAY * 0.95 ) return;
	    int delta = GetTick() - last_player_info_tick;
	    last_player_info_tick = GetTick();
    #endif //!PHYSICAL_UI
    #ifdef PHYSICAL_UI
        if(!PhysicalUI_StartFrame()) return;
        physical_selected_type = 0;
        physical_selected_id = 0;
    #endif //PHYSICAL_UI
	
	CritterCl@ cr = GetChosen();
	if( !valid( cr ) ) return;
	bool is_gm = isGM( cr );

    Color@ line_color = NewColor( 0xe3, 0xad, 0x4f );
    Color@ select_color = NewColor( 0xa3, 0xed, 0x4f );
	
	if( FLAG( cr.Param[MIO_FLAGS], MIO_FLAG_SHOW_ITEMS ) )
	{
        #ifndef PHYSICAL_UI
            if( iList().updated() )
                IDs = iList().getIDs();
            
            string text;
            ItemCl@ item, stack;
            for( uint i = 0, l = IDs.length(); i < l; i++ )
            {
                if( IDs[i].length() == 0 || IDs[i][0] == 0 )
                    continue;
                
                @item = GetItem( IDs[i][0] );
                if( !valid( item ) || GetDistantion( cr.HexX, cr.HexY, item.HexX, item.HexY ) > 16 )
                    continue;//TODO: PERCEPTION CHECK
                
                text = "";
                for( uint j = 0, k = IDs[i].length(); j < k; j++ )
                {
                    if( IDs[i][j] == 0 ) continue;
                    @stack = GetItem( IDs[i][j] );
                    
                    if( !valid( stack ) || ( !is_gm && invisible_pids.find( stack.GetProtoId() ) != -1 ) )
                        continue;

                    text += GUI_itemInfo( stack );
                }
                
                if( text.length() > 0 )
                    MapMessage( text, item.HexX, item.HexY, SHOW_PLAYER_INFO_DELAY, 0xFFFFFFFF, false, 0, 0 );
                    //DrawTextAboveHex( text, item.HexX, item.HexY, NewColor( 255, 255, 255 ), true );	
            }
        #endif //!PHYSICAL_UI
        #ifdef PHYSICAL_UI
            ItemCl@[] items;
            uint len = GetAllItems(@items);
            for( uint i = 0; i < len; i++ ) {
                ItemCl@ item = items[i];
                if( GetDistantion( cr.HexX, cr.HexY, item.HexX, item.HexY ) > 16 || ( !is_gm && invisible_pids.find( item.GetProtoId() ) != -1 ) ) {
                    continue;
                }
                string@ text = GUI_itemInfo( item );
                if( text.length() > 0 ) {
                    //MapMessage( text, item.HexX, item.HexY, SHOW_PLAYER_INFO_DELAY, 0xFFFFFFFF, false, 0, 0 );
                    PhysicalDrawTextAboveHex( text, item.HexX, item.HexY, line_color, 1, item.Id, 0, is_gm, is_gm );
                }
            }
        #endif //PHYSICAL_UI
	}
	
	if( FLAG( cr.Param[MIO_FLAGS], MIO_FLAG_SHOW_HINTS ) )
	{
        ItemCl@ item = null;
        #ifdef PHYSICAL_UI
            @item = PhysicalSelectItem(1);
        #endif //PHYSICAL_UI

        if(item is null) {
		    @item = GetMonitorItem( __MouseX, __MouseY );
        }
		
		if( valid( item ) ) {
            #ifndef PHYSICAL_UI
		        MapMessage( GUI_itemHelp( item ), item.HexX, item.HexY, SHOW_PLAYER_INFO_DELAY, 0xFFFFFFFF, false, 0, 0 );
            #endif //!PHYSICAL_UI
            #ifdef PHYSICAL_UI
		        PhysicalDrawTextAboveHex( GUI_itemHelp( item ), item.HexX, item.HexY, select_color, 1, item.Id, 0, true, true );
            #endif //PHYSICAL_UI
        }
	}

    #ifdef PHYSICAL_UI
        PhysicalUI_EndFrame();
    #endif //PHYSICAL_UI
}

void showF1()
{
	if( __ShowF1Help && !__f4Pressed && GUI_GetActiveScreen() == CLIENT_MAIN_SCREEN_GAME )
	{
		TabPic.Draw( 320, 10 );
		DrawText( "Название: 100%", 320, 10, TabPic.Width, TabPic.Height, COLOR_RGB( 125, 125, 125 ), FONT_FALLOUT, FT_CENTERXY );
		F1_tabs.Draw( 300, 30  );

		F1_text.Draw( ( __ScreenWidth - F1_text.Width ) / 2, ( __ScreenHeight - F1_text.Height ) / 2 );

		F1_arrows.Draw( __ScreenWidth / 2 - 150, __ScreenHeight - 165 );
		
		//For debugging:
		//DrawText( "[" + __MouseX + ", " + __MouseY + " ]", __MouseX, __MouseY, 100, 100, COLOR_RGB( 255, 255, 255 ), FONT_FALLOUT, FT_CENTERXY );
	}
}

string GUI_itemHelp( ItemCl@ item )
{
	if( !valid( item ) ) return "[null]";
	
	string result = GUI_itemInfo( item );
	
	switch( item.GetProtoId() )
	{//TODO: Более удобное и полное отображение инфрмации + колорайзинг сущностей в тексте (подсветка разных типов данных).
		case(7900): result += "\n"
					"|0xffffff " + "Закиньте в бочку горючих материалов:" + "\n" +
					"|0x78E354 " + "Дрова, хворост, палки, доски." + "\n" +
					"|0xffffff " + "И подожгите кремнем или зажигалкой." + "\n" +
					"|0x4ce0d2 " + "[Осторожней с патронами и взрывчаткой!]" + "\n" +
					"";
	}
	
	return result;
}

string GUI_itemInfo( uint id ) { return( GUI_itemInfo( GetItem( id ) ) ); }
string GUI_itemInfo( ItemCl@ item )
{
	if( !valid( item ) ) return "[null]";

	string@ info = itemText( item ); //GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item ) );
	string text = ( valid( info ) ? "|0xe3ad4f " + info + "\n" : "" );
	
	//Пример обхода текста из Фообж
	/*switch( item.GetProtoId() ) 
	{
		case( 8735 ):
		case( 8736 ):
		case( 8737 ):
		case( 8738 ):
		case( 8739 ):
			text = "Пламя";
	}*/
		
	if( item.Val9 != PID_POPUP && item.GetProtoId() != PID_POPUP )
		text += ( valid( item.Lexems ) && item.Lexems.length() > 1 ? "'" + item.Lexems + "'\n" : "" );
		
	CritterCl@ cr = GetChosen();
	if( !valid( cr ) ) return "[!cr]";
	
	if( isGM( cr ) )
	{
		text += ( "|0xffffff " + "#" + "|0x78E354 " + item.Id + "|0xffffff " + " PID: " + "|0x78E354 " + item.GetProtoId() + "|0xffffff " + "\n" ) +
		"";//Сюда можно построчно компоновать что вздумается. Позже сделаю класс или иной конструктор многострочных выражений.
	
		uint[] vals = { item.Val0, item.Val1, item.Val2, item.Val3, item.Val4, item.Val5, item.Val6, item.Val7, item.Val8, item.Val9 };
		
		for( uint i = 0, l = vals.length(); i < l; i++ )
			text += ( vals[i] != 0 ? "|0xffffff " + "VAL#" + "|0x4ce0d2 " + i + "|0xffffff " + ": " + "|0x78E354 " + vals[i] + "\n" : "" );
	}
	
	return text;
}
