// Author: Mio
// Социальные приправы.

#include "_macros.fos"
#include "_colors.fos"

// Основные.
import string Colorizing( int number, string[] list, int[] listX ) from "mio_deviants_toolkit";
import string Dictkeys( int number, string[] list, int[] listX ) from "mio_deviants_toolkit";
import int MenuChoice( int storage, uint answerI, string cell, bool rec ) from "mio_deviants_toolkit";
import string[] StatusMaker( Critter& initiator, Critter@ target, string[] list, int[] listX, uint8[] listV ) from "mio_deviants_toolkit";

// Упаковка.
import int BitUnpacker( int storage, uint8 index, uint8 bit ) from "mio_deviants_toolkit";
import int BitZeroing( int storage, uint8 index, uint8 bit ) from "mio_deviants_toolkit";
import int BitPacker( int cell, int storage, uint8 index, uint8 bit ) from "mio_deviants_toolkit";
import int BitChange( int number, int storage, uint8 index, uint8 bit ) from "mio_deviants_toolkit";

// Сторонние.
import void ChangeCritterSpeed( Critter& cr ) from "speed";

import uint8 ChoiceMask( int[] list ) from "mio_deviants_toolkit";



// ####################################################################################################
// #                                       Obvious AID Manager                                        #
// ####################################################################################################

// ДЛЯ ВСЕХ.
#define TARGETID								( ST_VAR0 )					// Параметр криттера содержащий ID, с которым происходит взаимодействие.
#define TARGETPID								( ST_VAR1 )					// Параметр криттера содержащий PID, с которым происходит взаимодействие.
#define MENU_STORAGE							( ST_VAR2 )					// Параметр криттера содержащий выбор меню.
#define MENU_PAGE								( ST_VAR3 )					// Параметр криттера содержащий дополнительные данные меню-журналов.

// Пачки.
#define NUM_MENU_PAGE							( 1 )						// Страница. Начальный индекс.
#define BIT_MENU_PAGE							( 4 )						// 
#define NUM_MENU_SIGN							( 32 )						// Знак. Начальный индекс.
#define BIT_MENU_SIGN							( 1 )						// 

#define STARTING_POINT							( 1 )						// Начало отсчёта.
#define INDEX									# ( X ) ( X - STARTING_POINT )

// Types.
#define TYPE_NONE								( 0 )
#define TYPE_ITEM								( 1 )
#define TYPE_MAP								( 2 )
#define TYPE_CRITTER							( 3 )
#define TYPE_CRITTER_PARAM						( 4 )
#define TYPE_CRITTER_NEEDS						( 5 )
#define TYPE_CRITTER_COMBAT						( 6 )
#define TYPE_CRITTER_DIFFERENT					( 7 )
#define TYPE_LOC_NAVIGATION						( 8 )



// ####################################################################################################
// #                                        Condition Control                                         #
// ####################################################################################################

// Condition Control.

#define NUM_HIDEFACE							( 1 )						// Закрыто лицо.
#define BIT_HIDEFACE							( 1 )						// 
#define NUM_HIDELEX								( 2 )						// Закрыто лексему.
#define BIT_HIDELEX								( 1 )						// 
#define NUM_SHOWSPAM							( 3 )						// Отображение точек при печати.
#define BIT_SHOWSPAM							( 1 )						// 
#define NUM_VOICEVOLUME							( 4 )						// Громкость речи.
#define BIT_VOICEVOLUME							( 2 )						// 
#define NUM_SLEEPMODE							( 30 )						// Режим ожидания.
#define BIT_SLEEPMODE							( 1 )						// 
#define NUM_DELIRIUM							( 31 )						// Галлюны.
#define BIT_DELIRIUM							( 1 )						// 
#define NUM_DRAGGING							( 32 )						// Тащит тело.
#define BIT_DRAGGING							( 1 )						// 

bool F_Hideface( Critter& player )          { return BitUnpacker( player.Param[ MIO_FLAGS ], INDEX( NUM_HIDEFACE ), BIT_HIDEFACE ) == 1; }
void F_Hideface( Critter& player, int num ) { player.ParamBase[ MIO_FLAGS ] = BitPacker( num, player.Param[ MIO_FLAGS ], INDEX( NUM_HIDEFACE ), BIT_HIDEFACE ); }
bool F_Hidelex( Critter& player )          { return BitUnpacker( player.Param[ MIO_FLAGS ], INDEX( NUM_HIDELEX ), BIT_HIDELEX ) == 1; }
void F_Hidelex( Critter& player, int num ) { player.ParamBase[ MIO_FLAGS ] = BitPacker( num, player.Param[ MIO_FLAGS ], INDEX( NUM_HIDELEX ), BIT_HIDELEX ); }
bool F_Showspam( Critter& player )          { return BitUnpacker( player.Param[ MIO_FLAGS ], INDEX( NUM_SHOWSPAM ), BIT_SHOWSPAM ) == 1; }
void F_Showspam( Critter& player, int num ) { player.ParamBase[ MIO_FLAGS ] = BitPacker( num, player.Param[ MIO_FLAGS ], INDEX( NUM_SHOWSPAM ), BIT_SHOWSPAM ); }
uint8 F_VoiceVolume( Critter& player )          { return BitUnpacker( player.Param[ MIO_FLAGS ], INDEX( NUM_VOICEVOLUME ), BIT_VOICEVOLUME ); }
void F_VoiceVolume( Critter& player, int num ) { player.ParamBase[ MIO_FLAGS ] = BitPacker( num, player.Param[ MIO_FLAGS ], INDEX( NUM_VOICEVOLUME ), BIT_VOICEVOLUME ); }
bool F_Sleepmode( Critter& player )          { return BitUnpacker( player.Param[ MIO_FLAGS ], INDEX( NUM_SLEEPMODE ), BIT_SLEEPMODE ) == 1; }
void F_Sleepmode( Critter& player, int num ) { player.ParamBase[ MIO_FLAGS ] = BitPacker( num, player.Param[ MIO_FLAGS ], INDEX( NUM_SLEEPMODE ), BIT_SLEEPMODE ); }
bool F_Delirium( Critter& player )          { return BitUnpacker( player.Param[ MIO_FLAGS ], INDEX( NUM_DELIRIUM ), BIT_DELIRIUM ) == 1; }
void F_Delirium( Critter& player, int num ) { player.ParamBase[ MIO_FLAGS ] = BitPacker( num, player.Param[ MIO_FLAGS ], INDEX( NUM_DELIRIUM ), BIT_DELIRIUM ); }
bool F_Dragging( Critter& player )          { return BitUnpacker( player.Param[ MIO_FLAGS ], INDEX( NUM_DRAGGING ), BIT_DRAGGING ) == 1; }
void F_Dragging( Critter& player, int num ) { player.ParamBase[ MIO_FLAGS ] = BitPacker( num, player.Param[ MIO_FLAGS ], INDEX( NUM_DRAGGING ), BIT_DRAGGING ); }



// ####################################################################################################
// #                                           Compression                                            #
// ####################################################################################################

string Centering( string list ) // Центрирование текста в меню.
{
	if( list.length() > 16 ) { return list; }
	string tab = "";
	for( uint8 i = 0, l = ( 18 - list.length() ); i < l; i++ ) { tab += " "; }
	return tab+list;
}
void MenuMaker( Critter& initiator, string[] list, string@ headline, string@ pointer ) // Генератор менюшек.
{
	uint8 length = list.length();
	initiator.ShowScreen( SCREEN_DIALOGBOX, length, pointer );
	initiator.Say( SAY_DIALOGBOX_TEXT, headline );
	for( uint8 i = 0; i < length; i++ ) { initiator.Say( SAY_DIALOGBOX_BUTTON( i ), Centering( list[ i ] ) ); }
	initiator.Say( SAY_DIALOGBOX_BUTTON( length ), Centering( "Отмена" ) );
}

string Color( uint color ) { return "|"+color+" "; }
void ShortRec( Critter& player, string cell, uint num ) { player.ParamBase[ MENU_STORAGE ] = MenuChoice( player.Param[ MENU_STORAGE ], num, cell, true ); }
void PageReset( Critter& player ) { player.ParamBase[ MENU_PAGE ] = BitZeroing( player.Param[ MENU_PAGE ], INDEX( NUM_MENU_PAGE ), BIT_MENU_PAGE ); }
void Empty( Critter& player, uint answerI, string& answerS ) { null; }



// ================================================== Обработчики ==================================================

void Dispatcher( Critter& player, uint answerI, string& answerS ) // Координатор меню.
{
	ShortRec( player, "MENU_CHOICE", answerI );

	int storage = 		player.Param[ MENU_STORAGE ];
	uint8 branch = 		MenuChoice( storage, 0, "MENU_BRANCH", false );
	uint8 depth = 		MenuChoice( storage, 0, "MENU_DEPTH", false );
	uint8 count = 		MenuChoice( storage, 0, "MENU_COUNT", false );

	bool BACK = 		( answerI == count-1 );
	if( depth == 0 )	{ BACK = false; }
	if( BACK )			{ depth--; ShortRec( player, "MENU_DEPTH", depth ); }

	uint8 menumark_1 = 	MenuChoice( storage, 0, "MENU_MENUMARK_1", false );
	uint8 menumark_2 = 	MenuChoice( storage, 0, "MENU_MENUMARK_2", false );

	//player.Say( SAY_NETMSG, "dpt: "+depth +" - answerI: "+answerI +"/"+count );

	if( branch == 0 )
	{
		if( depth == 0 )
		{
			if( BACK ) { CP_BASIC( player ); return; }																	// Рекурсия.
			if( answerI == 0 ) { MenuTALKVOLUME( player, answerI, "" ); }												// Голос			- Меню.
			if( answerI == 1 ) { MenuOVERVIEW( player, answerI, "" ); }													// Обзор			- Меню.
			if( answerI == 2 ) { MenuDEBUG( player, answerI, "Фикс заглючившей скорости:" ); }							// Debug			- Меню.
			ShortRec( player, "MENU_MENUMARK_1", answerI );
			ShortRec( player, "MENU_DEPTH", depth+1 );
			return;
		}

		if( menumark_1 == 0 )
		{
			if( depth == 1 ) { ChangeTALKVOLUME( player, answerI, "" ); return; }										// Голос			- Логика.
		}
		if( menumark_1 == 1 )
		{
			if( depth == 1 )
			{
				if( answerI == 0 ) { ChangeMASK( player, answerI, "" ); return; }										// Харя				- Логика.
				if( answerI == 1 ) { ChangeHIDELEX( player, answerI, "" ); return; }									// Лексема			- Логика.
				if( answerI == 2 ) { ChangeSPAM( player, answerI, "" ); return; }										// Спам				- Логика.
			}
		}
		if( menumark_1 == 2 )
		{
			if( depth == 1 ) { ChangeDEBUG( player, answerI, "" ); return; }											// Debug			- Логика.
		}
	}
}



// ####################################################################################################
// #                                               MENU                                               #
// ####################################################################################################

void unsafe_CONTROL_PANEL_PLAYER( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
	player.ParamBase[ MENU_STORAGE ] = 0;

	if( param2 == 0 )
	{
		CP_BASIC( player );
		return;
	}
}

void unsafe_QuickSoundTuning( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
	int8 VVO = F_VoiceVolume( player );
	int8 VV = VVO;
	string[] listV = { "50", "20", "10", "5" };
	if( param0 == 0 )
	{
		player.Say( SAY_NETMSG, "|0x606060 Громкость голоса: " +listV[ VV ]+ " шагов." );
	}
	if( param0 == 1 )
	{
		VV = CLAMP( VV+1, 0, 3 );
		F_VoiceVolume( player, VV );
		if( VV != VVO ) { player.Say( SAY_NETMSG, "|0x606060 Громкость голоса: " +listV[ VV ]+ " шагов." ); }
	}
	else if( param0 == 2 )
	{
		VV = CLAMP( VV-1, 0, 3 );
		F_VoiceVolume( player, VV );
		if( VV != VVO ) { player.Say( SAY_NETMSG, "|0x606060 Громкость голоса: " +listV[ VV ]+ " шагов." ); }
	}
}

// ================================================== Обработчики ==================================================

string UserMenuInfo( Critter& player )
{
	string voicedist = "50";
		 if( F_VoiceVolume( player ) == 1 ) { voicedist = "20"; }
	else if( F_VoiceVolume( player ) == 2 ) { voicedist = "10"; }
	else if( F_VoiceVolume( player ) == 3 ) { voicedist =  "5"; }

	string s1 = ( F_Hideface( player ) ? "|0x900000 Лицо скрываю" : "|0x3CF800 Лицо открыто" );
	string s2 = ( F_Hidelex( player ) ? "|0x900000 Приметы скрываю" : "|0x3CF800 Приметы видны" );
	string s3 = ( F_Showspam( player ) ? "|0x900000 Набор текста скрываю" : "|0x3CF800 Набор текста отображаю" );

	string result = "|0x606060 Громкость речи: "+voicedist+" шагов"+"\n" +s1+"\n" +s2+"\n" +s3+"\n";

	return result;
}



// ####################################################################################################
// #                                            Main Menu                                             #
// ####################################################################################################

void CP_BASIC( Critter& player )
{
	string[] list = { "Голос", "Обзор", "Debug" };
	ShortRec( player, "MENU_BRANCH", 0 );
	MenuMaker( player, list, UserMenuInfo( player ), "Dispatcher" );
}

void MenuTALKVOLUME( Critter& player, uint answerI, string& answerS )
{
	string[] list = { "Чеддер стайл", "Громко", "Спокойно", "Вполголоса", "<<< Назад" };
	ShortRec( player, "MENU_COUNT", list.length() );
	MenuMaker( player, list, UserMenuInfo( player ), "Dispatcher" );
}
void MenuOVERVIEW( Critter& player, uint answerI, string& answerS )
{
	string[] list = { "Скрывать лицо", "Скрывать лексему", "Извещение печати", "<<< Назад" };
	ShortRec( player, "MENU_COUNT", list.length() );
	MenuMaker( player, list, UserMenuInfo( player ), "Dispatcher" );
}
void MenuDEBUG( Critter& player, uint answerI, string& answerS )
{
	string[] list = { "Пересчет скорости", "<<< Назад" };
	ShortRec( player, "MENU_COUNT", list.length() );
	MenuMaker( player, list, answerS, "Dispatcher" );
}

void ChangeTALKVOLUME( Critter& player, uint answerI, string& answerS )
{
	F_VoiceVolume( player, answerI );
	MenuTALKVOLUME( player, answerI, "" );
}
void ChangeMASK( Critter& player, uint answerI, string& answerS )
{
	if( F_Hideface( player ) )
	{
		F_Hideface( player, 0 );
		ArmorEffects( player, 1 );
	}
	else
	{
		F_Hideface( player, 1 );
		ArmorEffects( player, 1 );
	}
	MenuOVERVIEW( player, answerI, "" );
}
void ChangeHIDELEX( Critter& player, uint answerI, string& answerS )
{
	if( F_Hidelex( player ) ) { F_Hidelex( player, 0 ); } else { F_Hidelex( player, 1 ); }
	MenuOVERVIEW( player, answerI, "" );
}
void ChangeSPAM( Critter& player, uint answerI, string& answerS )
{
	if( F_Showspam( player ) ) { F_Showspam( player, 0 ); } else { F_Showspam( player, 1 ); }
	MenuOVERVIEW( player, answerI, "" );
}
void ChangeDEBUG( Critter& player, uint answerI, string& answerS )
{
	ChangeCritterSpeed( player );
	MenuDEBUG( player, answerI, "|0xFF0000 Пересчитано!" );
}







// ================================================== Мелочёвка ==================================================

void ShowTheWay( Critter& cr, Critter@ targetCr )
{
	if( targetCr is null )
	{
		if( cr.Karma[ KARMA_SEPARATED ] == 0 ) { cr.Say( SAY_NETMSG, "Карта местности, на которой какие-то непонятные каракули." ); }
		return;
	}

	if( cr.Karma[ KARMA_SEPARATED ] == 1 )
	{
		cr.Say( SAY_EMOTE_ON_HEAD, "Показывает обходные пути" );
		targetCr.KarmaBase[ KARMA_SEPARATED ] = 1;
	}
}

void CoinUse( Critter& cr, Item& item )
{
	string emote = "Подкидывает монетку: ";
	string side = Random( 0, 1 ) == 1 ? "Бермин" : "Бак";
	string result = "";

	cr.Say( SAY_NORM, Color( COLOR_TEXT )+"- " +Color( COLOR_YELLOW )+side +Color( COLOR_TEXT )+" -" );
	cr.Say( SAY_EMOTE_ON_HEAD, emote + " " + Color( COLOR_TEXT )+side+Color( COLOR_EMOTE ) );
}

// ####################################################################################################
// #                                               Dice                                               #
// ####################################################################################################

void DiceUse( Critter& cr, Item& item )
{
	string emote = cr.Param[ ST_GENDER ] == 0 ? "Выбросил" : ( cr.Param[ ST_GENDER ] == 1 ? "Выбросила" : "Выбросило" );
	uint8 variable = Random( 1, 6 );
	if( item.Val5 != 0 && item.Val5 != variable )
	{
		if( Random( 0, 9 ) < item.Val6 ) { variable = item.Val5; }
	}

	cr.Say( SAY_NORM, Color( COLOR_TEXT )+"- " +Color( COLOR_YELLOW )+variable +Color( COLOR_TEXT )+" -" );
	cr.Say( SAY_EMOTE_ON_HEAD, emote + " " + variable );
}
void DiceAdjustment( Critter& cr, Item& targetItem )
{
	cr.ParamBase[ TARGETID ] = targetItem.Id;

	string PickUp = FLAG( targetItem.Flags, ITEM_CAN_PICKUP ) ? "Поднимаемые" : "Настольные";
	string[] list = { PickUp, "*Утяжелить*" };
	MenuMaker( cr, list, "Что делать с костями?", "DiceModification" );
}
void DiceModification( Critter& cr, uint answerI, string& answerS )
{
	if( answerI == 0 )
	{
		Item @ ItemDice = GetItem( cr.Param[ TARGETID ] );
		FLAG( ItemDice.Flags, ITEM_CAN_PICKUP ) ? UNSETFLAG( ItemDice.Flags, ITEM_CAN_PICKUP ) : SETFLAG( ItemDice.Flags, ITEM_CAN_PICKUP );
		DiceAdjustment( cr, ItemDice );
		return;
	}
	if( answerI == 1 )
	{
		if( cr.Timeout[ TO_SK_REPAIR ] > 0 ) { cr.Say( SAY_NETMSG, "Это слишком кропотливо. Вам нужно отдохнуть." ); return; }
		string[] list = { "Баланс", "1", "2", "3", "4", "5", "6" };
		MenuMaker( cr, list, "Какую сторону утяжелять?", "LoadingDice" );
	}
}
void LoadingDice( Critter& cr, uint answerI, string& answerS )
{
	cr.ParamBase[ MENU_STORAGE ] = answerI;
	if( answerI == 0 ) { LoadingDiceEnd( cr, answerI, "" ); return; }

	string[] list = { "10%", "20%", "30%", "40%", "50%", "60%", "70%", "80%", "90%", "100%" };
	MenuMaker( cr, list, "Степень утяжеления:", "LoadingDiceEnd" );
}
void LoadingDiceEnd( Critter& cr, uint answerI, string& answerS )
{
	answerI++;
	uint8 luck = Random( 150, 300 ) - ( answerI * 10 );
	cr.TimeoutBase[ TO_SK_REPAIR ] = __FullSecond + REAL_MINUTE( 10 );
	if( luck > cr.Param[ SK_REPAIR ] ) { cr.Say( SAY_NETMSG, "Вы утомляетесь от этой ювелирной работы, так и не достигнув желаемого результата." ); return; }

	Item @ ItemDice = GetItem( cr.Param[ TARGETID ] );
	cr.ParamBase[ TARGETID ] = 0;
	if( !valid( ItemDice ) ) { return; }

	//int skill = cr.Skill[ SK_REPAIR ];
	uint8 side = cr.Param[ MENU_STORAGE ];

	ItemDice.Val5 = side;
	ItemDice.Val6 = answerI;
	if( side != 0 ) { cr.Say( SAY_NETMSG, "Вы утяжелили кость на стороне " + side + " на " + answerI + "0%" ); }
	else { cr.Say( SAY_NETMSG, "Вы восстановили вселенское равновесие, сбалансировав игральную кость." ); }
	cr.Say( SAY_EMOTE, "Возится с игральной костью" );
}



// ####################################################################################################
// #                                              Cards                                               #
// ####################################################################################################

int[] CardsSide( int storage )
{
	int[] color = {};
	for( uint8 i = 0; i < 27; i++ ) { color.insertLast( BitUnpacker( storage, i, 1 ) ); }
	return color;
}

void CardsUse( Critter& cr, Item& item )
{
	if( item.Val3 == 0 && item.Val4 == 0 ) { cr.Say( SAY_NETMSG, "Колода опустела, нужно перетасовать." ); return; }

	string emote = cr.Param[ ST_GENDER ] == 0 ? "Вытянул" : ( cr.Param[ ST_GENDER ] == 1 ? "Вытянула" : "Вытянуло" );
	int[] SideMask;
	bool colorSide = Random( 0, 1 ) == 0 ? false : true;
	if( colorSide )
	{
		if( item.Val3 > 0 ) { SideMask = CardsSide( item.Val3 ); } else { SideMask = CardsSide( item.Val4 ); colorSide = false; }
	}
	else
	{
		if( item.Val4 > 0 ) { SideMask = CardsSide( item.Val4 ); } else { SideMask = CardsSide( item.Val3 ); colorSide = true; }
	}
	int Card = ChoiceMask( SideMask );
	string[] picture = { "вальта", "даму", "короля", "туза" };
	string[] picturechat = { "Валет", "Дама", "Король", "Туз" };
	string[] lear = { "буби", "черви", "треф", "пик" };
	string result = " ";
	string resultchat = " ";
	if( colorSide )
	{
		if( Card <= 12 )
		{
			if( Card <= 8 ) { result += ( Card + 2 )+"-ку " +lear[ 0 ]; resultchat += ( Card + 2 )+" " +Color( COLOR_LRED )+lear[ 0 ]; }
			else { result += picture[ Card - 9 ] +" "+lear[ 0 ]; resultchat += picturechat[ Card - 9 ] +" "+Color( COLOR_LRED )+lear[ 0 ]; }
		}
		else if( Card <= 25 )
		{
			if( Card <= 21 ) { result += ( Card - 11 )+"-ку " +lear[ 1 ]; resultchat += ( Card - 11 )+" " +Color( COLOR_LRED )+lear[ 1 ]; }
			else { result += picture[ Card - 22 ] +" "+lear[ 1 ]; resultchat += picturechat[ Card - 22 ] +" "+Color( COLOR_LRED )+lear[ 1 ]; }
		}
		else { result += "цветного джокера"; resultchat += Color( COLOR_LRED )+"Цветной джокер"; }

		item.Val3 = BitZeroing( item.Val3, Card, 1 );
	}
	else
	{
		if( Card <= 12 )
		{
			if( Card <= 8 ) { result += ( Card + 2 )+"-ку " +lear[ 2 ]; resultchat += ( Card + 2 )+" " +Color( COLOR_GRAY )+lear[ 2 ]; }
			else { result += picture[ Card - 9 ] +" "+lear[ 2 ]; resultchat += picturechat[ Card - 9 ] +" "+Color( COLOR_GRAY )+lear[ 2 ]; }
		}
		else if( Card <= 25 )
		{
			if( Card <= 21 ) { result += ( Card - 11 )+"-ку " +lear[ 3 ]; resultchat += ( Card - 11 )+" " +Color( COLOR_GRAY )+lear[ 3 ]; }
			else { result += picture[ Card - 22 ] +" "+lear[ 3 ]; resultchat += picturechat[ Card - 22 ] +" "+Color( COLOR_GRAY )+lear[ 3 ]; }
		}
		else { result += "бесцветного джокера"; resultchat += Color( COLOR_GRAY )+"Бесцветный джокер"; }

		item.Val4 = BitZeroing( item.Val4, Card, 1 );
	}

	cr.Say( SAY_NORM, Color( COLOR_TEXT )+"-" +Color( COLOR_YELLOW )+resultchat +Color( COLOR_TEXT )+" -" );
	cr.Say( SAY_EMOTE_ON_HEAD, emote + result );
}
void CardsAdjustment( Critter& cr, Item& targetItem )
{
	cr.ParamBase[ TARGETID ] = targetItem.Id;

	string PickUp = FLAG( targetItem.Flags, ITEM_CAN_PICKUP ) ? "Поднимаемые" : "Настольные";
	string[] list = { "Тасовать", PickUp, "*Крап*" };
	MenuMaker( cr, list, "Что делать с картами?", "CardsModification" );
}
void CardsModification( Critter& cr, uint answerI, string& answerS )
{
	if( answerI == 0 )
	{
		Item @ ItemCards = GetItem( cr.Param[ TARGETID ] );
		ItemCards.Val3 = 134217727;
		ItemCards.Val4 = 134217727;
		cr.Action( ACTION_PICK_CRITTER, 3, null );
		cr.Say( SAY_EMOTE, "Тасует карты" );
		return;
	}
	if( answerI == 1 )
	{
		Item @ ItemCards = GetItem( cr.Param[ TARGETID ] );
		FLAG( ItemCards.Flags, ITEM_CAN_PICKUP ) ? UNSETFLAG( ItemCards.Flags, ITEM_CAN_PICKUP ) : SETFLAG( ItemCards.Flags, ITEM_CAN_PICKUP );
		CardsAdjustment( cr, ItemCards );
		return;
	}
	if( answerI == 2 )
	{
		cr.Say( SAY_NETMSG, "Кому-то расхотелось этим заниматься." );
	}
}



// ####################################################################################################
// #                                            Hide Face                                             #
// ####################################################################################################

import uint GetAllPlayers( Critter@[]& crs ) from "manager";
void ArmorEffects( Critter& cr, int8 sign )
{
	bool hidename = B_Showname( cr );
	uint QST = cr.Param[ QST_MEDIUM ];
	bool update = false;

	if( sign == 1 && hidename )
	{
		if( QST != 2 )
		{
			cr.ParamBase[ QST_MEDIUM ] = 2;
			update = true;
		}
	}
	else
	{
		if( QST != 0 )
		{
			cr.ParamBase[ QST_MEDIUM ] = 0;
			update = true;
		}
	}

	if( update )
	{
		Critter@[] crs;
		GetAllPlayers( crs );
		for( uint i = 0, l = crs.length(); i < l; i++ ) { crs[ i ].RunClientScript( "client_main@NamesUpdater", 0, 0, 0, null, null ); }
	}
}
bool B_Showname( Critter& cr )
{
	Item@ item = cr.GetItem( 0, SLOT_ARMOR );
	if( item is null ) { return false; }

	uint16[][] OpenArmorList =
	{
		{
			PID_PURPLE_ROBE, PID_BLACK_ROBE, PID_SANDROBE, PID_BROWN_ROBE, PID_DARK_GREEN_ROBE, PID_RED_RITUAL_ROBE, PID_BLACK_RITUAL_ROBE, PID_DARK_BLACK_ROBE, 
			PID_DARK_RED_ROBE, PID_RED_ROBE, PID_DARK_BROWN_ROBE, PID_DARK_BLUE_ROBE, PID_ATOM_CHILD_ROBE

		},{
			PID_EKZO, PID_OXIDENED_POWER_ARMOR, PID_aras2k1, PID_arekzo, PID_POWERED_ARMOR, PID_EKZO_2, PID_POWERED_ARMOR_NEVADA, PID_aras2k2, PID_arbattl1,
			PID_ardfnder, PID_HYENA_PA, PID_HYENA_PA_MK2, PID_HARDENED_POWER_ARMOR, PID_ADVANCED_POWER_ARMOR, PID_ADVANCED_POWER_ARMOR_MK2
		}
	};
	uint8 OpenArmor = 0;
	uint16 PID = item.GetProtoId();

	for( uint8 i = 0, l = OpenArmorList.length(); i < l; i++ )
	{
		for( uint8 ii = 0, ll = OpenArmorList[ i ].length(); ii < ll; ii++ )
		{
			if( PID == OpenArmorList[ i ][ ii ] ) { OpenArmor = i+1; break; }
		}
	}

	bool hidename = false;
	if( OpenArmor == 1 && FLAG( cr.Param[ MIO_FLAGS ], ITEM_HIDDEN ) ) { hidename = true; }
	else if( OpenArmor == 2 ) { hidename = true; }

	return hidename;
}


