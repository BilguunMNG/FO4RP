// Author: Anuri

#include "_utils.fos"
#include "entire_h.fos"

import uint8 checkSand( Map& map, uint16 tx, uint16 ty ) from "qmap_sand";
import uint8 checkCave( Map& map, uint16 tx, uint16 ty ) from "qmap_cave";

//PLANT_PARAMETERS
#define GROWTH_STAGE				Val0 		// Стадия роста растения
#define RESOURCE_CAPACITY 			Val1 		// валка для записи кол-ва полезных плодов
#define DEATH_STAGE					Val2 		// Стадия смерти растения
#define EVENT 						Val3 		// валка для записи тайм-ивента

//PLANT_RESOURCE_CAPACITY
#define BROC_RESOURCE_CAPACITY 		( Random( 1, 2 ) )
#define XANDER_RESOURCE_CAPACITY 	( Random( 1, 4 ) )
#define MUSH_LOW_RESOURCE_CAPACITY 	( 1 )
#define DEFAULT_RESOURCE_CAPACITY 	( 1 )

//MAP_DATA
#define MAP_TIME_DATA   			( 1 )

const uint16[] map_pids =   	{ fort_cave, rdr1_2, rdr1_3, rdr2_2, rdr2_3, rdr3_1, rdr3_1_mine1, rdr3_1_mine2, rdr4_1, rdr4_1_mine1, rdr5_3, rdr6_1_mine1, rdr2_1, rdr2_1dn, rdr1_1, rdr0_1, rdr0_2, rdr0_3, toxic_pit, lair_of_death, rdr_canyon, rdr_up_3_1, rdr_up_3_2, rdr_up_3_3, rdr_up_2_1, rdr_up_2_2, rdr_up_2_3 };
const uint16[] plant_amount = 	{	 15,		25, 	25, 	 7, 	7,      5,		  3,			10,			5,	 	   2,		  10,		20,	       	10,		  5,	  5,	  7,	   10,	  5,	   15,			10, 		15,			  10,		 15,		20,				10,		   5,		   10   };

//===============PLANT_SPAWNER_MECHANIC===============//

void PlantAutoInit() //export to gameplay.fos
{    
    Map@[] maps;
    for( int i = 0, iend = GetAllMaps( 0, maps ); i < iend; i++)
	{   
		CheckMapEvent( maps[i] );
	}
}

uint e_SpawnPlants( int[] @ values )
{
	Map @ map = GetMap( values[ 0 ] );
	if( !valid( map ) ) { return 0; }
	
	SpawnPlants( map );

	EraseTimeEvent( map.GetData( MAP_TIME_DATA ) );
	map.SetData( MAP_TIME_DATA, CreateTimeEvent( AFTER( DELAY_FOR_HARVESTABLE_LOOT_RESPAWN ), "e_SpawnPlants", values, true ) );
	return 0;
}
 
bool SpawnPlants( Map& map )
{
    if( map.CountEntire( MAP_EDGE_ENTIRE ) != 1 )
	{
		Log( "No entire at map PID #" + map.GetProtoId() + "." );
		return false;
	}

    Item@[] wildplants;
    for( uint i = 0; i < Wildplants.length(); i++ ) {
        map.GetItems( Wildplants[i], wildplants );
    }
    
    uint amount = wildplants.length();
    uint index = map_pids.find( map.GetProtoId() );
    
    int failed = 0;
    
    if( amount >= plant_amount[index] ) { 
		//Log( "Got enough at map PID #" + map.GetProtoId() + "." );
        return false; 
    }
	
    int extraPlants = plant_amount[index] - amount;

	uint16 hexX = 0, hexY = 0;
	map.GetEntireCoords( MAP_EDGE_ENTIRE, 0, hexX, hexY );
	
	for( int k = 0; k < extraPlants; k++ ) {
		
        uint16 x = Random( ( hexX + 1 ), ( hexX + REGULAR_MAP_SIZE - 1  ) );
        uint16 y = Random( ( hexY + 1 ), ( hexY + REGULAR_MAP_SIZE - 1  ) );

		bool sand = checkSand( map, H2T( x ), H2T( y ) ) != 0;
		bool cave = checkCave( map, H2T( x ), H2T( y ) ) != 0;
		bool passed = map.IsHexPassed( x, y );
		
		if( sand && passed ) {
			
			Item@ wildplant = map.AddItem( x, y, Wildplants[ Random( 0, 2 ) ], 1 );
			
            if( !valid( wildplant ) ) {
				Log( "PLANT IS NULL" );
			} else {
			
				uint[] values = { wildplant.Id };
				wildplant.EVENT = CreateTimeEvent( AFTER( REAL_HOUR( 1 ) ), "e_PlantGrowth", values, true );
			}
		
		} else if( cave && passed ) {
			Item@ wildplant = map.AddItem( x, y, Wildplants[ Random( 3, Wildplants.length() - 1 ) ], 1 );
			
            if( !valid( wildplant ) ) {
				Log( "PLANT IS NULL" );
			} else {
			
				uint[] values = { wildplant.Id };
				wildplant.EVENT = CreateTimeEvent( AFTER( REAL_HOUR( 1 ) ), "e_PlantGrowth", values, true );
			}
		
		} else {
			
			k--;            
			failed++;
			//Log( "Не удалось заспаунить(" + failed + ") #" + k + " в координатах " + x + ":" + y );
			
			if( failed > plant_amount[index] ) {
				break;
			}
		}
    }
    
    wildplants.resize(0);
    for( uint i = 0; i < Wildplants.length(); i++ ) 
	{
        map.GetItems( Wildplants[i], wildplants );
    }

    //Log( "Не удалось заспаунить " + failed + " растений. Итого на карте: " + wildplants.length() + " из " + plant_amount[index] + "." );
    return true;
}

uint e_PlantGrowth( uint[]@ values )
{
	uint itemId = values[0];
	Item@ wildplant = GetItem( itemId );
	if( valid( wildplant ) )    
	{
		uint lifetime = 1;
		int stages = 0;
		
		uint16 wildplantPid = wildplant.GetProtoId();
		switch( wildplantPid )
		{
			case( PID_PLANT_BROC ):
				stages = 6;
				if( wildplant.RESOURCE_CAPACITY == 0 )
					wildplant.RESOURCE_CAPACITY = BROC_RESOURCE_CAPACITY;
				break;
			case( PID_PLANT_XANDER ):
				stages = 4;
				if( wildplant.RESOURCE_CAPACITY == 0 )
					wildplant.RESOURCE_CAPACITY = XANDER_RESOURCE_CAPACITY;
				break;
			case( PID_MUSH_LOW ):
				stages = 1;
				lifetime = 3;
				if( wildplant.RESOURCE_CAPACITY == 0 )
					wildplant.RESOURCE_CAPACITY = MUSH_LOW_RESOURCE_CAPACITY;
				break;
			case( PID_PLANT_TONGUE_GECKO ):
			case( PID_PLANT_MURAVNIKTAR ):
			case( PID_PLANT_BLACK_MUSHROOMS ):
			case( PID_PLANT_PALE_MUSHROOM ):
			case( PID_PLANT_MUTMUSH ):
				stages = 3;
				if( wildplant.RESOURCE_CAPACITY == 0 )
					wildplant.RESOURCE_CAPACITY = DEFAULT_RESOURCE_CAPACITY;
				break;
			default:
				stages = 1;
				if( wildplant.RESOURCE_CAPACITY == 0 )
					wildplant.RESOURCE_CAPACITY = DEFAULT_RESOURCE_CAPACITY;
				break;
		}
		
		if( wildplant.DEATH_STAGE == 0 ) {
			wildplant.DEATH_STAGE = stages;
		}
		
		if( wildplant.GROWTH_STAGE < wildplant.DEATH_STAGE ) {
			wildplant.GROWTH_STAGE ++;
			uint8 i = wildplant.GROWTH_STAGE;
			ChangeFrame( wildplant, i );
			uint time = wildplant.GROWTH_STAGE == ( wildplant.DEATH_STAGE - 1 ) ? 3 : 1; //плодоносная стадия длится 3 часа
			return REAL_HOUR( lifetime * time );
		}
		
		EraseTimeEvent( wildplant.EVENT );
		wildplant.EVENT = 0;
		DeleteItem( wildplant );
	}
	
	return 0;
}

//~run wildplant _PlantsInit 0 0 0
void _PlantsInit( Critter& player, int param0, int param1, int param2 )
{
    Map@[] maps;
    Item@[] wildplants;
    for( int i = 0, iend = GetAllMaps( 0, maps ); i < iend; i++)
	{   
		if( map_pids.find( maps[i].GetProtoId() ) != -1 ) 
		{
			for( uint i = 0; i < Wildplants.length(); i++ )
			{
				maps[i].GetItems( Wildplants[i], wildplants );
			}
			for( int i = 0, l = wildplants.length(); i < l; i++ )
				DeleteItem( wildplants[i] );
		}
	}
    
	FoceSpawnPlants();
}

void FoceSpawnPlants()
{
    Map@[] maps;
    for( int i = 0, iend = GetAllMaps( 0, maps ); i < iend; i++)
	{   
		CheckMapEvent( maps[i] );
	}
}

bool CheckMapEvent( Map& map )
{
	if( map_pids.find( map.GetProtoId() ) != -1 ) 
	{
		int[] values = { map.Id };
		map.SetData( MAP_TIME_DATA, CreateTimeEvent( AFTER( REAL_SECOND( 1 ) ), "e_SpawnPlants", values, true ) );
		//Log( "plant_event_started at map pid #" + map.GetProtoId() );
		return true;
	}
	return false;
}