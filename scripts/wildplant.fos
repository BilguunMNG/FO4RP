// Author: Anuri
#ifndef WILDPLANT
#define WILDPLANT

#include "_utils.fos"
#include "wildplant_h.fos"
#include "entire_h.fos"

import uint8 checkSand( Map& map, uint16 tx, uint16 ty ) from "qmap_sand";
import uint8 checkCave( Map& map, uint16 tx, uint16 ty ) from "qmap_cave";
import uint8 checkGrass( Map& map, uint16 tx, uint16 ty ) from "qmap_grass";

void WildplantAutoInit() //export to gameplay.fos
{    
    Map@[] maps;
    for( int i = 0, iend = GetAllMaps( 0, maps ); i < iend; i++)
	{   
		CheckMapEvent( maps[i] );
	}
}

uint e_SpawnPlants( int[] @ values )
{
	Map @ map = GetMap( values[ 0 ] );
	if( !valid( map ) ) { return 0; }
	
	SpawnPlants( map );

	EraseTimeEvent( map.GetData( MAP_TIME_DATA ) );
	map.SetData( MAP_TIME_DATA, CreateTimeEvent( AFTER( DELAY_FOR_HARVESTABLE_LOOT_RESPAWN ), "e_SpawnPlants", values, true ) );
	return 0;
}
 
bool SpawnPlants( Map& map )
{
    if( map.CountEntire( MAP_EDGE_ENTIRE ) != 1 )
	{
		Log( "No entire at map PID #" + map.GetProtoId() + "." );
		return false;
	}

    Item@[] wildplants;
    for( uint i = 0; i < Wildplants.length(); i++ ) {
        map.GetItems( Wildplants[i], wildplants );
    }
    
    uint amount = wildplants.length();
    uint index = map_pids.find( map.GetProtoId() );
    
    int failed = 0;
    
    if( amount >= plant_amount[index] ) { 
		//Log( "Got enough at map PID #" + map.GetProtoId() + "." );
        return false; 
    }
	
    int extraPlants = plant_amount[index] - amount;

	uint16 hexX = 0, hexY = 0;
	map.GetEntireCoords( MAP_EDGE_ENTIRE, 0, hexX, hexY );
	
	for( int k = 0; k < extraPlants; k++ ) {
		
        uint16 x = Random( ( hexX + 1 ), ( hexX + REGULAR_MAP_SIZE - 1  ) );
        uint16 y = Random( ( hexY + 1 ), ( hexY + REGULAR_MAP_SIZE - 1  ) );

		bool sand = checkSand( map, H2T( x ), H2T( y ) ) != 0;
		bool cave = checkCave( map, H2T( x ), H2T( y ) ) != 0;
		bool passed = map.IsHexPassed( x, y );
		
		if( sand && passed ) {
			
			Item@ wildplant = map.AddItem( x, y, Wildplants[ Random( 0, 2 ) ], 1 );
			
            if( !valid( wildplant ) ) {
				Log( "PLANT IS NULL" );
			} else {
			
				uint[] values = { wildplant.Id };
				wildplant.EVENT = CreateTimeEvent( AFTER( REAL_HOUR( 1 ) ), "e_PlantGrowth", values, true );
			}
		
		} else if( cave && passed ) {
			Item@ wildplant = map.AddItem( x, y, Wildplants[ Random( 3, Wildplants.length() - 1 ) ], 1 );
			
            if( !valid( wildplant ) ) {
				Log( "PLANT IS NULL" );
			} else {
			
				uint[] values = { wildplant.Id };
				wildplant.EVENT = CreateTimeEvent( AFTER( REAL_HOUR( 1 ) ), "e_PlantGrowth", values, true );
			}
		
		} else {
			
			k--;            
			failed++;
			//Log( "Не удалось заспаунить(" + failed + ") #" + k + " в координатах " + x + ":" + y );
			
			if( failed > plant_amount[index] ) {
				break;
			}
		}
    }
    
    wildplants.resize(0);
    for( uint i = 0; i < Wildplants.length(); i++ ) 
	{
        map.GetItems( Wildplants[i], wildplants );
    }

    //Log( "Не удалось заспаунить " + failed + " растений. Итого на карте: " + wildplants.length() + " из " + plant_amount[index] + "." );
    return true;
}

uint e_PlantGrowth( uint[]@ values )
{
	uint itemId = values[0];
	Item@ wildplant = GetItem( itemId );
	if( valid( wildplant ) )    
	{
		uint lifetime = 1;
		int stages = 0;
		
		uint16 wildplantPid = wildplant.GetProtoId();
		switch( wildplantPid )
		{
			case( PID_PLANT_BROC ):
				stages = 6;
				if( wildplant.RESOURCE_CAPACITY == 0 )
					wildplant.RESOURCE_CAPACITY = BROC_RESOURCE_CAPACITY;
				break;
			case( PID_PLANT_XANDER ):
				stages = 4;
				if( wildplant.RESOURCE_CAPACITY == 0 )
					wildplant.RESOURCE_CAPACITY = XANDER_RESOURCE_CAPACITY;
				break;
			case( PID_MUSH_LOW ):
				stages = 1;
				lifetime = 3;
				if( wildplant.RESOURCE_CAPACITY == 0 )
					wildplant.RESOURCE_CAPACITY = MUSH_LOW_RESOURCE_CAPACITY;
				break;
			case( PID_PLANT_TONGUE_GECKO ):
			case( PID_PLANT_MURAVNIKTAR ):
			case( PID_PLANT_BLACK_MUSHROOMS ):
			case( PID_PLANT_PALE_MUSHROOM ):
			case( PID_PLANT_MUTMUSH ):
				stages = 3;
				if( wildplant.RESOURCE_CAPACITY == 0 )
					wildplant.RESOURCE_CAPACITY = DEFAULT_RESOURCE_CAPACITY;
				break;
			default:
				stages = 1;
				if( wildplant.RESOURCE_CAPACITY == 0 )
					wildplant.RESOURCE_CAPACITY = DEFAULT_RESOURCE_CAPACITY;
				break;
		}
		
		if( wildplant.DEATH_STAGE == 0 ) {
			wildplant.DEATH_STAGE = stages;
		}
		
		if( wildplant.GROWTH_STAGE < wildplant.DEATH_STAGE ) {
			wildplant.GROWTH_STAGE ++;
			uint8 i = wildplant.GROWTH_STAGE;
			ChangeFrame( wildplant, i );
			uint time = wildplant.GROWTH_STAGE == ( wildplant.DEATH_STAGE - 1 ) ? 3 : 1; //плодоносная стадия длится 3 часа
			return REAL_HOUR( lifetime * time );
		}
		
		EraseTimeEvent( wildplant.EVENT );
		wildplant.EVENT = 0;
		DeleteItem( wildplant );
	}
	
	return 0;
}

//~run wildplant _PlantsInit 0 0 0
void _PlantsInit( Critter& player, int param0, int param1, int param2 )
{
    Map@[] maps;
    Item@[] wildplants;
    for( int i = 0, iend = GetAllMaps( 0, maps ); i < iend; i++)
	{   
		if( map_pids.find( maps[i].GetProtoId() ) != -1 ) 
		{
			for( uint i = 0; i < Wildplants.length(); i++ )
			{
				maps[i].GetItems( Wildplants[i], wildplants );
			}
			for( int i = 0, l = wildplants.length(); i < l; i++ )
				DeleteItem( wildplants[i] );
		}
	}
    
	FoceSpawnPlants();
}

void FoceSpawnPlants()
{
    Map@[] maps;
    for( int i = 0, iend = GetAllMaps( 0, maps ); i < iend; i++)
	{   
		CheckMapEvent( maps[i] );
	}
}

bool CheckMapEvent( Map& map )
{
	if( map_pids.find( map.GetProtoId() ) != -1 ) 
	{
		int[] values = { map.Id };
		map.SetData( MAP_TIME_DATA, CreateTimeEvent( AFTER( REAL_SECOND( 1 ) ), "e_SpawnPlants", values, true ) );
		//Log( "plant_event_started at map pid #" + map.GetProtoId() );
		return true;
	}
	return false;
}

bool PickPlant( Critter& cr, Item& wildplant )
{
	if( !valid( wildplant) ) { return false; }
	
	uint16 wildplantPid = wildplant.GetProtoId();
	cr.Say( SAY_EMOTE, "Срывает растение" );
	bool isMushroom = ( wildplantPid == PID_PLANT_TONGUE_GECKO ) || ( wildplantPid == PID_PLANT_MURAVNIKTAR ) || ( wildplantPid == PID_PLANT_BLACK_MUSHROOMS ) 
						|| ( wildplantPid == PID_PLANT_PALE_MUSHROOM) || ( wildplantPid == PID_PLANT_MUTMUSH || wildplantPid = PID_MUSH_LOW );
	bool isAlive = ( wildplant.GROWTH_STAGE < wildplant.DEATH_STAGE );
	if( ( isMushroom && isAlive ) || ( wildplant.DEATH_STAGE - 1 == wildplant.GROWTH_STAGE ) ) {
		uint16 pickedPlantPid = 0;
		switch( wildplantPid ) 
		{
			case( PID_PLANT_BROC ):
				pickedPlantPid = PID_BROC_FLOWER;
				break;
			
			case( PID_PLANT_XANDER ):
				pickedPlantPid = PID_XANDER_ROOT;
				break;
			
			case( PID_PLANT_MURAVNIKTAR ): 
			{	
				switch( wildplant.GROWTH_STAGE ) {
					case( 1 ):
						pickedPlantPid = PID_SEEDLING_MURAVNIKTAR;
						break;
					case( 2 ):
						pickedPlantPid = PID_RISING_MURAVNIKTAR;
						break;
					case( 3 ):
						pickedPlantPid = PID_MURAVNIKTAR;
						break;
				}
				break;
			}
			
			case( PID_PLANT_TONGUE_GECKO ):
			{							
				switch( wildplant.GROWTH_STAGE ) 
				{
					case( 0 ):
						pickedPlantPid = PID_SEEDLING_TONGUE_GECKO;
						break;
					case( 1 ):
						pickedPlantPid = PID_RISING_TONGUE_GECKO;
						break;
					case( 2 ):
						pickedPlantPid = PID_TONGUE_GECKO;
						break;
				}
				break;
			}
			
			case( PID_PLANT_BLACK_MUSHROOMS ):
			{							
				switch( wildplant.GROWTH_STAGE ) 
				{
					case( 0 ):
						pickedPlantPid = PID_SEEDLING_BLACK_MUSHROOMS;
						break;
					case( 1 ):
						pickedPlantPid = PID_RISING_BLACK_MUSHROOMS;
						break;
					case( 2 ):
						pickedPlantPid = PID_BLACK_MUSHROOMS;
					break;
				}
				break;
			}
			
			case( PID_PLANT_PALE_MUSHROOM ):
			{							
				switch( wildplant.GROWTH_STAGE ) 
				{
					case( 0 ):
						pickedPlantPid = PID_SEEDLING_PALE_MUSHROOM;
						break;
					case( 1 ):
						pickedPlantPid = PID_RISING_PALE_MUSHROOM;
						break;
					case( 2 ):
						pickedPlantPid = PID_PALE_MUSHROOM;
						break;
				}
				break;
			}
			
			case( PID_PLANT_MUTMUSH ): {
				switch( wildplant.GROWTH_STAGE ) {
					case( 0 ):
						pickedPlantPid = PID_SEEDLING_MUTMUSH;
						break;
					case( 1 ):
						pickedPlantPid = PID_PID_RISING_MUTMUSH;
						break;
					case( 2 ):
						pickedPlantPid = PID_MUTMUSH;
						break;
				}
				break;
			}
			
			case( PID_MUSH_LOW ):
				pickedPlantPid = PID_MUSH_LOW;
				break;
		}
		
		int amount = wildplant.RESOURCE_CAPACITY;
		cr.AddItem( pickedPlantPid, amount );
		
		string inform = "Вы добыли: \n";
		inform += "- ";
		inform += "|0xFFFF00 " + _GetProtoName( pickedPlantPid );
		inform += "|0x3CF800  - ";
		inform += "|0xFFFF00 " + amount;
		inform += "|0x3CF800  шт.";
		cr.Say( SAY_NETMSG, inform );
		
		EraseTimeEvent( wildplant.EVENT );
		wildplant.EVENT = 0;
		DeleteItem( wildplant );
	} else {
		cr.Say( SAY_NETMSG, "|0xFFFF00 Вы сорвали растение в неправильной стадии, а затем выкинули его." );
		EraseTimeEvent( wildplant.EVENT );
		wildplant.EVENT = 0;
		DeleteItem( wildplant );
	}
	return true;
}
#endif //WILDPLANT