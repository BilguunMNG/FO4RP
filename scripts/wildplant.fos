// Author: Anuri

#include "_utils.fos"

import uint8 checkSand( Map& map, uint16 tx, uint16 ty ) from "qmap_sand";

#define AMOUNT 						Val2 		// валка для записи кол-ва полезных плодов
#define EVENT 						Val3 		// валка для записи тайм-ивента

#define MAP_TIME_DATA   			( 1 )

#define MAP_EDGE_ENTIRE				( 255 )  	// Точка края карты
#define MAP_SIZE               		( 150 ) 	// по аналогии CIMP

// Дефайны пидов карт
#define riverdale1_2				( 107 )
#define riverdale1_3				( 109 )
#define riverdale2_2				( 111 )
#define riverdale2_3				( 113 )

const uint16[] PlantList = 		{ PID_BROC_FLOWER, PID_XANDER_ROOT }; // PID_PLANT_BROC, PID_PLANT_XANDER 
const uint16[] map_pids =   	{ riverdale1_2, riverdale1_3, riverdale2_2, riverdale2_3 };
const uint16[] plant_amount = 	{	  15, 			  15, 			5, 		      5      };


 //ChangeFrame( target, 1 );
 
//===============PLANT_SPAWNER_MECHANIC===============//

void PlantAutoInit() //export to gameplay.fos
{    
    Map@[] maps;
    for( int i = 0, iend = GetAllMaps( 0, maps ); i < iend; i++)
	{   
		CheckMapEvent( maps[i] );
	}
}

uint e_SpawnPlants( int[] @ values )
{
	Map @ map = GetMap( values[ 0 ] );
	if( !valid( map ) ) { return 0; }
	
	SpawnPlants( map );

	EraseTimeEvent( map.GetData( MAP_TIME_DATA ) );
	map.SetData( MAP_TIME_DATA, CreateTimeEvent( AFTER( DELAY_FOR_HARVERTABLE_LOOT_RESPAWN ), "e_SpawnPlants", values, false ) );
	return 0;
}
 
bool SpawnPlants( Map& map )
{
    if( map.CountEntire( MAP_EDGE_ENTIRE ) != 1 )
	{
		Log( "No entire at map PID #" + map.GetProtoId() + "." );
		return false;
	}

    Item@[] wildplants;
    for( uint i = 0; i < PlantList.length(); i++ ) {
        map.GetItems( PlantList[i], wildplants );
    }
    
    uint amount = wildplants.length();
    uint index = map_pids.find( map.GetProtoId() );
    
    int failed = 0;
    
    if( amount >= plant_amount[index] ) { 
		Log( "Got enough at map PID #" + map.GetProtoId() + "." );
        return false; 
    }
	
    int extraPlants = plant_amount[index] - amount;

	uint16 hexX = 0, hexY = 0;
	map.GetEntireCoords( MAP_EDGE_ENTIRE, 0, hexX, hexY );
	
	Log( hexX + ":" + hexY );
	
	for( int k = 0; k < extraPlants; k++ )
	{
        uint16 x = Random( ( hexX + 1 ), ( hexX + MAP_SIZE - 1  ) );
        uint16 y = Random( ( hexY + 1 ), ( hexY + MAP_SIZE - 1  ) );

		bool sand = checkSand( map, H2T( x ), H2T( y ) ) != 0;
		bool passed = map.IsHexPassed( x, y );
		
		if( sand && passed )
		{
			Item@ wildplant = map.AddItem( x, y, PlantList[ Random( 0, PlantList.length() - 1 ) ], 1 );
			
            if( wildplant is null )
				Log( "PLANT IS NULL" );
		}
        else
		{
			k--;            
			failed++;
			Log( "Не удалось заспаунить(" + failed + ") #" + k + " в кордах " + x + ":" + y );
			if( failed > plant_amount[index] )
				break;
		}
    }
    
    wildplants.resize(0);
    for( uint i = 0; i < PlantList.length(); i++ ) 
	{
        map.GetItems( PlantList[i], wildplants );
    }

    Log( "Не удалось заспаунить " + failed + " растений. Итого на карте: " + wildplants.length() + " из " + plant_amount[index] + "." );
    return true;
}

void _PlantsInit( Critter& player, int param0, int param1, int param2 )
{
    Map@[] maps;
    Item@[] wildplants;
    for( int i = 0, iend = GetAllMaps( 0, maps ); i < iend; i++)
	{   
		if( map_pids.find( maps[i].GetProtoId() ) != -1 ) 
		{
			for( uint i = 0; i < PlantList.length(); i++ )
			{
				maps[i].GetItems( PlantList[i], wildplants );
			}
			for( int i = 0, l = wildplants.length(); i < l; i++ )
				DeleteItem( wildplants[i] );
		}
	}
    
	FoceSpawnPlants();
}

void FoceSpawnPlants()
{
    Map@[] maps;
    for( int i = 0, iend = GetAllMaps( 0, maps ); i < iend; i++)
	{   
		CheckMapEvent( maps[i] );
	}
}

bool CheckMapEvent( Map& map )
{
	if( map_pids.find( map.GetProtoId() ) != -1 ) 
	{
		int[] values = { map.Id };
		map.SetData( MAP_TIME_DATA, CreateTimeEvent( AFTER( REAL_SECOND( 1 ) ), "e_SpawnPlants", values, false ) );
		Log( "plant_event_started at map pid #" + map.GetProtoId() );
		return true;
	}
	return false;
}