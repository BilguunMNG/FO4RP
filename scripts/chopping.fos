// Author: Anuri
// Mentors: Terpsic Mims, qthree, Mio, Frank Kost, Jonathan Joestar, Vvish

#include "_utils.fos"
#include "_ltp.fos"
#include "gathering_h.fos"
#include "critter_skills_h.fos"

const string[] SoundNames = {"Tree1.ogg", "Tree2.ogg", "Tree3.ogg", "Tree4.ogg" };
//=============TREE PARAMETERS============//
#define ORIGINAL_PID	 			Val0		// запись ДНК дерева, чтобы при смене прото вернуться к оригиналу
#define	RESOURCE_CAPACITY			Val1 		// тут записано макс кол-во подходов к дереву. Используется как текущее.
#define DNA							Val2		// тут пишем какому дереву соответствует какой вид пенька
#define EVENT 						Val3 		// валка для записи тайм-ивента на рост дерева

const uint16[] tools = { PID_AXE, PID_AXE2, PID_REVKNIFE2, PID_MACHETE, PID_SHOVEL };
const uint16[][] TreeList =
{
	{ 
		PID_TREE_GXS1, PID_TREE_GXS2, PID_TREE_GXS3,
		// trees_xs
		PID_TREE_DS1, PID_TREE_DS2, PID_TREE_DS3, PID_TREE_DS4, PID_TREE_DS5, PID_TREE_DS6, PID_TREE_DS7, PID_TREE_DS8, PID_TREE_DS9, PID_TREE_DS10, PID_TREE_DS11,
		PID_TREE_BS1, PID_TREE_BS2, PID_TREE_BS3, PID_TREE_GS1, PID_TREE_GS2, PID_TREE_GS3, PID_TREE_GS4, PID_TREE_GS5, PID_TREE_GS6, PID_TREE_GS7, PID_TREE_GS8, PID_TREE_GS9,
		PID_TREE_GS10, PID_TREE_GS11, PID_TREE_GS12, PID_TREE_GS13, PID_TREE_GS14, PID_TREE_GS15, PID_TREE_GS16, PID_TREE_GS17, PID_TREE_GS18, PID_TREE_GS19,
		// trees_s
		PID_TREE_DM1, PID_TREE_DM2, PID_TREE_GM1, PID_TREE_GM2, PID_TREE_GM3, PID_TREE_GM4, PID_TREE_GM5, PID_TREE_GM6, PID_TREE_GM7, PID_TREE_GM8, PID_TREE_GM9,
		PID_TREE_GM10, PID_TREE_GM11, PID_TREE_GM12, PID_TREE_GM13, PID_TREE_GM14, PID_TREE_GM15,
		// trees_m
		PID_TREE_DL1, PID_TREE_DL2, PID_TREE_DL3, PID_TREE_DL4, PID_TREE_DL5, PID_TREE_DL6, PID_TREE_DL7, PID_TREE_DL8, PID_TREE_DL9, PID_TREE_BL1, PID_TREE_BL2,
		PID_TREE_GL1, PID_TREE_GL2, PID_TREE_GL3, PID_TREE_GL4, PID_TREE_GL5, PID_TREE_GL6, PID_TREE_GL7, PID_TREE_GL8,
		// trees_l
		PID_TREE_GXXL1, PID_TREE_GXXL2
		// trees_xl
	}, 
	{ 
		PID_TREE_CS1, PID_TREE_CS2, PID_TREE_CS3, PID_TREE_CL1, PID_TREE_CL2, PID_TREE_CL3, PID_TREE_CL4, PID_TREE_CL5, PID_TREE_GL2S
	} // trees_chopped
};
// Tree array search
uint16 FindTree( Item@ targetItem )
{
    return FindTree( targetItem.GetProtoId() );
}

uint16 FindTree( uint16 pid )
{    
    int index = 0;
    
    for( uint i = 0, l = TreeList.length(); i < l; i++ )
    {
        index = TreeList[i].find( pid );
        if( index != -1 )
            return ++ i;
    }
    return 0;
}

// LTP (long time process)
bool ltp_inited = false;
void ltp_init()
{
	LTPREG( LTP_CHOPPING, process_chopping )
	ltp_inited = true;
}
//exported to main.fos - checks before start
bool PrepareChopping( Critter& cr, Item@ tool, Item@ target ) 
{
	Map@ map = cr.GetMap();
    if( !valid( map ) ) 
    {
    	return false;
    }
	if( !valid( tool ) || !valid(target) )
	{
		return false;
	}
   	uint toolPid = tool.GetProtoId();
	if( tools.find( toolPid ) == -1 )
	{
		return false;
	}
	if( tool.CritSlot != SLOT_HAND1 )
	{
		cr.Say( SAY_NETMSG, "|0xFFFF00 Возьмите инструмент в руку." );
		return false;
	}
	uint8 Tree = FindTree( target );
	if( Tree == 0 )
	{
		return false;
	}
	if( Tree == 1 )
	{
		if( toolPid == PID_SHOVEL )
		{
			cr.Say(SAY_NETMSG, "|0xFF0000 Этот инструмент не подходит для рубки.");
			return false;
		}
	}
	
	if( IsTired( cr ) ) { return false; }
	if( IsWounded( cr ) ) { return false; }
	
	start_chopping( cr, tool, target );
	return true;
}

bool start_chopping( Critter& cr, Item& tool, Item& target )
{
	if(!ltp_inited) 
		ltp_init();

	if( valid( tool ) && valid( target ) )
	{	
		uint hit_pause = ACTION_PAUSE_BASE - (cr.Stat[ST_AGILITY] * ACTION_PAUSE_BONUS_RATE );
		uint action_pause = CLAMP( hit_pause, ACTION_PAUSE_MIN, ACTION_PAUSE_MAX );
		StartProcess( cr, LTP_CHOPPING, 0, tool.Id, target.Id, action_pause );
		CreateTimeEvent( AFTER( REAL_MS( 700 ) ), "e_ChoppingSound", cr.Id, false);
		CreateTimeEvent( AFTER( REAL_MS( 1000 ) ), "gathering@e_TiredenessTimeout", cr.Id, true);
		return true;
	}
	return false;
}

uint process_chopping( Critter@ cr, int& param0, int& param1, int& param2 )
{
    LTPROCESS( cr, param0, LTP_CHOPPING )

	uint hit_pause = ACTION_PAUSE_BASE - (cr.Stat[ST_AGILITY] * ACTION_PAUSE_BONUS_RATE );
	uint action_pause = CLAMP( hit_pause, ACTION_PAUSE_MIN, ACTION_PAUSE_MAX );
    Item@ tool = GetItem( param1 );
  	Item@ target = GetItem( param2 );
  	if( valid( tool ) && valid( target ) )
    {
      	param0++;
  		uint object_dpa = ( cr.Skill[SK_CHOPPING] ) + ( cr.Stat[ST_STRENGTH] * 10 ) + OBJECT_DPA_BASE; 
		int sequence_length = ceil( float( OBJECT_HP_BASE / ( CLAMP( object_dpa, OBJECT_DPA_MIN, OBJECT_DPA_MAX ) ) ) );
		if( param0 > sequence_length )
		{
                uint8 Tree = FindTree( target );
                if( Tree == 0 )
                {
                    return 0;
                }
				if( Tree == 1 )
                {
                    if( target.RESOURCE_CAPACITY <= OBJECT_HP_BASE )
					{	
						CutTree( cr, target );
					}
					else
					{
						if( target.RESOURCE_CAPACITY > ( OBJECT_HP_BASE * 2 ) )
							ChangeFrame( target, 1 );
						if( target.RESOURCE_CAPACITY <= ( OBJECT_HP_BASE * 2 ) )
							ChangeFrame( target, 2 );
					}
                }
				if( Tree == 2 )
                {
                    if( tool.GetProtoId() != PID_SHOVEL )
                    {
                        cr.Say( SAY_NETMSG, "|0xFFFF00 Тут нечего рубить, придется подкопать и выкорчевать." );
                        return 0;
                    }
					if( target.RESOURCE_CAPACITY == 0 )
					{
						EraseTimeEvent( target.EVENT );
						DeleteItem( target );
					}
				}
			Profit( cr, tool, target );
			int skillNum = SK_CHOPPING;
			Accident( cr, skillNum );
        }
		else
		{
			_CritAnimateSwing(cr);
			CreateTimeEvent( AFTER( REAL_MS( 700 ) ), "e_ChoppingSound", cr.Id, false);
			CreateTimeEvent( AFTER( REAL_MS( 1000 ) ), "gathering@e_TiredenessTimeout", cr.Id, true);
			return action_pause;
		}
    }
	return 0;
}
//Action sound delay time event
uint e_ChoppingSound(uint[]@ values)
{
	Critter@cr = GetCritter(values[0]); 
	Map@ map = cr.GetMap();
	map.PlaySound( SoundNames[ Random( 0, SoundNames.length() -1 ) ], cr.HexX, cr.HexY, 5 );
	return 0;
}

//Cut tree pid change, condition to regrow
uint CutTree( Critter& cr, Item@ target )
{
	target.ORIGINAL_PID = target.GetProtoId();
	uint[] values = {target.Id};
	target.EVENT = CreateTimeEvent( AFTER( REAL_DAY( 30 ) ),"e_TreeRegrow", values, true );
	ChangeFrame( target, 0 );
	switch(target.DNA)
	{
		case(1):
			target.ChangeProto( PID_TREE_CS1 );
			break;
		case(2):
			target.ChangeProto( PID_TREE_CS2 );
			break;
		case(3):
			target.ChangeProto( PID_TREE_CS3 );
			break;
		case(4):
			target.ChangeProto( PID_TREE_CL1 );	
			break;
		case(5):
			target.ChangeProto( PID_TREE_CL2 );	
			break;
		case(6):
			target.ChangeProto( PID_TREE_CL3 );	
			break;
		case(7):
			target.ChangeProto( PID_TREE_CL4 );	
			break;
		case(8):
			target.ChangeProto( PID_TREE_CL5 );	
			break;
		case(9):
			target.ChangeProto( PID_TREE_GL2S );	
			break;
	}
	return 0;
}
// Regrowth time event
uint e_TreeRegrow( uint[]@ values )
{
	uint itemId = values[0];
	Item@ cutTree = GetItem( itemId );
	if( valid( cutTree ) )    
	{
		uint newTreePID = cutTree.ORIGINAL_PID;
		cutTree.ChangeProto( newTreePID );
		cutTree.RESOURCE_CAPACITY = cutTree.Proto.StartValue_1;
		ChangeFrame( cutTree, 0 );
	}
	return 0;
}

//Loot
bool Profit(  Critter& cr, Item@ tool, Item@ target )
{
	int amount = 0;
	uint toolMod = tool.GetProtoId();
	switch( toolMod )
	{	
		case( PID_REVKNIFE2 ):
		case( PID_MACHETE ):
			amount--;
			break;
		case( PID_AXE2 ):
			amount++;
			break;
	}
	
	uint lootRoll = ( Random( 0, 2 ) + ( cr.ParamBase[ SK_CHOPPING ] / 50 ) );
	amount+= lootRoll;
	if( amount < 1 ) {
		cr.Say( SAY_NETMSG, "|0xFFFF00 Вы не добыли ничего полезного." );
	
	} else {
		
		int skillNum = SK_CHOPPING;
		raiseSkill( cr, skillNum );
		
		cr.AddItem( PID_FIREWOOD, amount );
		string inform = "Вы добыли: \n";
		inform += "- ";
		inform += "|0xFFFF00 " + _GetProtoName( PID_FIREWOOD );
		inform += "|0x3CF800  - ";
		inform += "|0xFFFF00 " + amount;
		inform += "|0x3CF800  шт.";
		cr.Say( SAY_NETMSG, inform );
		
		cr.StatBase[ST_EXPERIENCE] += 25;
		
		target.RESOURCE_CAPACITY = target.RESOURCE_CAPACITY - OBJECT_HP_BASE;		
	}
	return true;
}

//ONE-TIME LIVE SERVER TREE UPGRADE
/*void _TreeUpgrade (Critter& player, int param0, int param1, int param2)
{
	for( int i = 0, j = TreeList.length() ; i < j; i++)
	{
		for ( int ii = 0, jj = TreeList[i].length() ; ii < jj; ii++)
		{
			array<Item@> worldTrees = array<Item@>();
			int count = GetAllItems(TreeList[i][ii], @worldTrees);
			for( int treeIndex = 0; treeIndex < count; treeIndex++ )
			{
				Item@ currentTree = worldTrees[treeIndex];
				currentTree.RESOURCE_CAPACITY = currentTree.RESOURCE_CAPACITY * 1000;
			}
		}
	}
}*/