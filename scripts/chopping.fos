// Author: Anuri
// Mentors: Terpsic Mims, qthree, Mio, Frank Kost, Jonathan Joestar, Vvish

#include "_utils.fos"
#include "_ltp.fos"
#include "STAT_MODS_H.fos"

import void InjureCritter( Critter& cr, uint dmg, uint dmgType, uint8 dir, uint attackerId ) from "combat";
import void BleedCritter( Critter& cr, int8 bleedValue ) from "critter_status";

const string[] SoundNames = {"Tree1.ogg", "Tree2.ogg", "Tree3.ogg", "Tree4.ogg" };
//=============TREE PARAMETERS============//
#define ORIGINAL_PID	 			Val0		// запись ДНК дерева, чтобы при смене прото вернуться к оригиналу
#define	RESOURCE_CAPACITY			Val1 		// тут записано макс кол-во подходов к дереву. Используется как текущее.
#define DNA							Val2		// тут пишем какому дереву соответствует какой вид пенька
#define EVENT 						Val3 		// валка для записи тайм-ивента на рост дерева

const uint16[] tools = { PID_AXE, PID_REVKNIFE2, PID_MACHETE, PID_SHOVEL };
const uint16[][] TreeList =
{
	{ 
		PID_TREE_GXS1, PID_TREE_GXS2, PID_TREE_GXS3,
		// trees_xs
		PID_TREE_DS1, PID_TREE_DS2, PID_TREE_DS3, PID_TREE_DS4, PID_TREE_DS5, PID_TREE_DS6, PID_TREE_DS7, PID_TREE_DS8, PID_TREE_DS9, PID_TREE_DS10, PID_TREE_DS11,
		PID_TREE_BS1, PID_TREE_BS2, PID_TREE_BS3, PID_TREE_GS1, PID_TREE_GS2, PID_TREE_GS3, PID_TREE_GS4, PID_TREE_GS5, PID_TREE_GS6, PID_TREE_GS7, PID_TREE_GS8, PID_TREE_GS9,
		PID_TREE_GS10, PID_TREE_GS11, PID_TREE_GS12, PID_TREE_GS13, PID_TREE_GS14, PID_TREE_GS15, PID_TREE_GS16, PID_TREE_GS17, PID_TREE_GS18, PID_TREE_GS19,
		// trees_s
		PID_TREE_DM1, PID_TREE_DM2, PID_TREE_GM1, PID_TREE_GM2, PID_TREE_GM3, PID_TREE_GM4, PID_TREE_GM5, PID_TREE_GM6, PID_TREE_GM7, PID_TREE_GM8, PID_TREE_GM9,
		PID_TREE_GM10, PID_TREE_GM11, PID_TREE_GM12, PID_TREE_GM13, PID_TREE_GM14, PID_TREE_GM15,
		// trees_m
		PID_TREE_DL1, PID_TREE_DL2, PID_TREE_DL3, PID_TREE_DL4, PID_TREE_DL5, PID_TREE_DL6, PID_TREE_DL7, PID_TREE_DL8, PID_TREE_DL9, PID_TREE_BL1, PID_TREE_BL2,
		PID_TREE_GL1, PID_TREE_GL2, PID_TREE_GL3, PID_TREE_GL4, PID_TREE_GL5, PID_TREE_GL6, PID_TREE_GL7, PID_TREE_GL8,
		// trees_l
		PID_TREE_GXXL1, PID_TREE_GXXL2
		// trees_xl
	}, 
	{ 
		PID_TREE_CS1, PID_TREE_CS2, PID_TREE_CS3, PID_TREE_CL1, PID_TREE_CL2, PID_TREE_CL3, PID_TREE_CL4, PID_TREE_CL5, PID_TREE_GL2S
	} // trees_chopped
};
// Tree array search
uint FindTree( Item@ targetItem )
{	
	uint8 Tree = 0;
	uint16 targetPID = targetItem.GetProtoId();

	for( uint8 i = 0, l = TreeList.length(); i < l; i++ )
	{
		for( uint8 ii = 0, ll = TreeList[ i ].length(); ii < ll; ii++ )
		{
			if( targetPID == TreeList[ i ][ ii ] ) 
			{ 
				Tree = i+1;
				break;
			}
		}
	}
	return Tree;
}
// LTP (long time process)
bool ltp_inited = false;
void ltp_init()
{
	LTPREG( LTP_CHOPPING, process_chopping )
	ltp_inited = true;
}
//exported to main.fos - checks before start
bool PrepareChopping( Critter& cr, Item@ tool, Item@ target ) 
{
	Map@ map = cr.GetMap();
    if( !valid( map ) ) 
    {
    	return false;
    }
	if( !valid( tool ) || !valid(target) )
	{
		return false;
	}
   	uint toolPid = tool.GetProtoId();
	if( tools.find( toolPid ) == -1 )
	{
		return false;
	}
	if( tool.CritSlot != SLOT_HAND1 )
	{
		cr.Say( SAY_NETMSG, "|0xFFFF00 Возьмите инструмент в руку." );
		return false;
	}
	uint8 Tree = FindTree( target );
	if( Tree == 0 )
	{
		return false;
	}
	if( Tree == 1 )
	{
		if( toolPid == PID_SHOVEL )
		{
			cr.Say(SAY_NETMSG, "|0xFF0000 Этот инструмент не подходит для рубки.");
			return false;
		}
	}
	uint timeout_limit = ( cr.Stat[ST_ENDURANCE] * PHASE_TIMEOUT_RATE ) + PHASE_TIMEOUT_BASE;
	int timeout = CLAMP( timeout_limit, PHASE_TIMEOUT_MIN, PHASE_TIMEOUT_MAX);
	if( cr.Timeout[ TO_TIREDNESS ] > REAL_SECOND( timeout ) )
	{
		cr.Say( SAY_EMOTE_ON_HEAD, "Одышка" );
		cr.Say( SAY_NETMSG, "|0xFF0000 Вы слишком устали, передохните." );
		
		if( !isGM(cr) )
			return false;
	}
	if( cr.ParamBase[ DAMAGE_RIGHT_LEG ] >= 1 || cr.ParamBase[ DAMAGE_LEFT_ARM ] >= 1 || cr.ParamBase[ DAMAGE_LEFT_LEG ] >= 1 || cr.ParamBase[ DAMAGE_RIGHT_ARM ] >= 1 ) 
	{
		cr.Say( SAY_NETMSG, "|0xFF0000 Вы травмированы и не в состоянии рубить деревья." ); 
		return false;
	}
	
	start_chopping( cr, tool, target );
	return true;
}

bool start_chopping( Critter& cr, Item& tool, Item& target )
{
	if(!ltp_inited) 
		ltp_init();

	if( valid( tool ) && valid( target ) )
	{	
		uint hit_pause = ACTION_PAUSE_BASE - (cr.Stat[ST_AGILITY] * ACTION_PAUSE_BONUS_RATE );
		uint action_pause = CLAMP( hit_pause, ACTION_PAUSE_MIN, ACTION_PAUSE_MAX );
		StartProcess( cr, LTP_CHOPPING, 0, tool.Id, target.Id, action_pause );
		CreateTimeEvent( AFTER( REAL_MS( 700 ) ), "e_ChoppingSound", cr.Id, true);
		CreateTimeEvent( AFTER( REAL_MS( 1000 ) ), "e_TiredenessTimeout", cr.Id, true);
		return true;
	}
	return false;
}

uint process_chopping( Critter@ cr, int& param0, int& param1, int& param2 )
{
    LTPROCESS( cr, param0, LTP_CHOPPING )
    //тут из param1 и param2 можно получить item и targetItem (разумеется перед этим отправив их id через StartProcess
	uint hit_pause = ACTION_PAUSE_BASE - (cr.Stat[ST_AGILITY] * ACTION_PAUSE_BONUS_RATE );
	uint action_pause = CLAMP( hit_pause, ACTION_PAUSE_MIN, ACTION_PAUSE_MAX );
    Item@ tool = GetItem( param1 ); // передает инструмент в 1 парам переменная tool
  	Item@ target = GetItem( param2 ); // передает цель в 2 парам переменная target
  	if( valid( tool ) && valid( target ) )
    {
      	param0++;
  		uint object_dpa = ( cr.Skill[SK_OUTDOORSMAN] - 80 ) + ( cr.Stat[ST_STRENGTH] * 10 ) + OBJECT_DPA_BASE; 
		int sequence_length = ceil( float( OBJECT_HP_BASE / ( CLAMP( object_dpa, OBJECT_DPA_MIN, OBJECT_DPA_MAX ) ) ) );
		if( param0 > sequence_length )
		{
                uint8 Tree = FindTree( target );
                if( Tree == 0 )
                {
                    return 0;
                }
				if( Tree == 1 )
                {
                    if( target.RESOURCE_CAPACITY <= OBJECT_HP_BASE )
					{	
						CutTree( cr, target );
					}
					else
					{
						if( target.RESOURCE_CAPACITY > ( OBJECT_HP_BASE * 2 ) )
							ChangeFrame( target, 1 );
						if( target.RESOURCE_CAPACITY <= ( OBJECT_HP_BASE * 2 ) )
							ChangeFrame( target, 2 );
					}
                }
				if( Tree == 2 )
                {
                    if( tool.GetProtoId() != PID_SHOVEL )
                    {
                        cr.Say( SAY_NETMSG, "|0xFFFF00 Тут нечего рубить, придется подкопать и выкорчевать." );
                        return 0;
                    }
					if( target.RESOURCE_CAPACITY == 0 )
					{
						EraseTimeEvent( target.EVENT );
						DeleteItem( target );
					}
				}
			Profit( cr, tool, target );
			Accident( cr );
        }
		else
		{
			_CritAnimateSwing(cr);
			CreateTimeEvent( AFTER( REAL_MS( 700 ) ), "e_ChoppingSound", cr.Id, true);
			CreateTimeEvent( AFTER( REAL_MS( 1000 ) ), "e_TiredenessTimeout", cr.Id, true);
			return action_pause;
		}
    }
	return 0;
}
//Action sound delay time event
uint e_ChoppingSound(uint[]@ values)
{
	Critter@cr = GetCritter(values[0]); 
	Map@ map = cr.GetMap();
	map.PlaySound( SoundNames[ Random( 0, SoundNames.length() -1 ) ], cr.HexX, cr.HexY, 5 );
	return 0;
}
//Action fatigue delay time event
uint e_TiredenessTimeout(uint[]@ values)
{
	Critter@cr = GetCritter( values[0] ); 
	uint fatigue_per_action = ACTION_FATIGUE_BASE - ( cr.Stat[ST_ENDURANCE] * ACTION_FATIGUE_RATE );
	uint fatigue = CLAMP( fatigue_per_action, ACTION_FATIGUE_MIN, ACTION_FATIGUE_MAX);
	cr.TimeoutBase[ TO_TIREDNESS ] = __FullSecond + cr.Timeout[ TO_TIREDNESS ] + REAL_SECOND( fatigue );
	return 0;
}
//Cut tree pid change, condition to regrow
uint CutTree( Critter& cr, Item@ target )
{
	target.ORIGINAL_PID = target.GetProtoId();
	uint[] values = {target.Id};
	target.EVENT = CreateTimeEvent( AFTER( REAL_DAY( 30 ) ),"e_TreeRegrow", values, true );
	ChangeFrame( target, 0 );
	switch(target.DNA)
	{
		case(1):
			target.ChangeProto( PID_TREE_CS1 );
			break;
		case(2):
			target.ChangeProto( PID_TREE_CS2 );
			break;
		case(3):
			target.ChangeProto( PID_TREE_CS3 );
			break;
		case(4):
			target.ChangeProto( PID_TREE_CL1 );	
			break;
		case(5):
			target.ChangeProto( PID_TREE_CL2 );	
			break;
		case(6):
			target.ChangeProto( PID_TREE_CL3 );	
			break;
		case(7):
			target.ChangeProto( PID_TREE_CL4 );	
			break;
		case(8):
			target.ChangeProto( PID_TREE_CL5 );	
			break;
		case(9):
			target.ChangeProto( PID_TREE_GL2S );	
			break;
	}
	return 0;
}
// Regrowth time event
uint e_TreeRegrow( uint[]@ values )
{
	uint itemId = values[0];
	Item@ cutTree = GetItem( itemId );
	if( valid( cutTree ) )    
	{
		uint newTreePID = cutTree.ORIGINAL_PID;
		cutTree.ChangeProto( newTreePID );
		cutTree.RESOURCE_CAPACITY = cutTree.Proto.StartValue_1;
	}
	return 0;
}
// Accident 
bool Accident( Critter& cr )
{
	if( Random( 1, 200 ) <= ( CRITICAL_FAILURE_BASE - (cr.ParamBase[ SK_OUTDOORSMAN ] / 30 ) ) )
	{
		int severity = Random( 1, 100 );
		if( severity > 65 && ( Random( 1, 100 ) < ( cr.Stat[ST_LUCK] * 2 ) ) )
		{	
			cr.Say( SAY_NETMSG, "|0x606060 В последний момент Вы чудом избежали старшной травмы, но все же:" );
			severity = severity - 35;
		}

		if( severity <= 5 )
		{
			cr.Say( SAY_NETMSG, "|0xFF0000 Отлетевший осколок ударил Вас в грудь." );
			InjureCritter( cr, 15, DAMAGE_NORMAL, cr.Dir, cr.Id );
			cr.Say( SAY_EMOTE, "Потирает ушиб" );
		}			
		else if( severity  >= 6 && severity  <= 35 )	
		{			
			cr.Say( SAY_NETMSG, "|0xFF0000 Вы ошиблись и слегка рассекли руку." );
			InjureCritter( cr, 20, DAMAGE_NORMAL, cr.Dir, cr.Id );
			SETFLAG( cr.StatBase[ ST_CRSTATUS ], CR_STATUS_BLEED );
			BleedCritter( cr, 20 );
			cr.Say(SAY_EMOTE, "Вскрикивает от боли");
			cr.Say(SAY_SHOUT_ON_HEAD, "Ай");				
		}
		else if( severity  >= 36 && severity  <= 65 )				
		{			
			cr.Say( SAY_NETMSG, "|0xFF0000 Вы попали инструментом себе по ноге и рассекли плоть." );
			InjureCritter( cr, 30, DAMAGE_NORMAL, cr.Dir, cr.Id );
			BleedCritter( cr, 40 );
			SETFLAG( cr.StatBase[ ST_CRSTATUS ], CR_STATUS_HEAVY_DMG );
			string emote = cr.Param[ ST_GENDER ] == 0 ? "Схватился за окровавленную ногу" : ( cr.Param[ ST_GENDER ] == 1 ? "Схватилась за окровавленную ногу" : "Завыло от боли" );			
		}
		else if( severity  >= 66 && severity  <= 95 )				
		{			
			cr.Say( SAY_NETMSG, "|0xFF0000 Из-за неудачного движения Вы получили тяжелую производственную травму." );
			InjureCritter( cr, 40, DAMAGE_NORMAL, cr.Dir, cr.Id );
			BleedCritter( cr, 50 );
			SETFLAG( cr.StatBase[ ST_CRSTATUS ], CR_STATUS_HEAVY_DMG );
			string emote = cr.Param[ ST_GENDER ] == 0 ? "Заорал от боли" : ( cr.Param[ ST_GENDER ] == 1 ? "Заорала от боли" : "Заорало от боли" );
			cr.Say(SAY_SHOUT_ON_HEAD, "А-а-а-ааа");			
		}	
		else
		{
			cr.Say( SAY_NETMSG, "|0xFF0000 Острый обломок отлетел Вам в глаз, кровь заливает лицо." );
			InjureCritter( cr, 50, DAMAGE_NORMAL, cr.Dir, cr.Id );
			BleedCritter( cr, 50 );
			SETFLAG( cr.StatBase[ ST_CRSTATUS ], CR_STATUS_HEAVY_DMG );	
			cr.ParamBase[ DAMAGE_EYE ] = 1;				
			string emote = cr.Param[ ST_GENDER ] == 0 ? "Взвыл от дикой боли" : ( cr.Param[ ST_GENDER ] == 1 ? "Взвыла от дикой боли" : "Взвыло от дикой боли" );
			cr.Say( SAY_SHOUT_ON_HEAD, "У-А-А-А-ААА" );
		}
		return true;		
	}
	return true;
}
//Loot
bool Profit(  Critter& cr, Item@ tool, Item@ target )
{
	uint8 amount = 0;
	if( tool.GetProtoId() == PID_AXE )
		amount++;

	uint lootRoll = ( Random( 0, 2 ) + ( cr.ParamBase[ SK_OUTDOORSMAN ] / 100 ) );
	amount+= lootRoll;
	if( amount <= 0 )
	{
		cr.Say( SAY_NETMSG, "|0xFFFF00 Вы не добыли ничего полезного." );
	return false;
	}
	else
	{
		cr.AddItem( PID_FIREWOOD, amount );
		cr.Say( SAY_NETMSG, "|0xFFFF00 Вы добыли дрова в количестве " +amount+ " шт." );
		target.RESOURCE_CAPACITY = target.RESOURCE_CAPACITY - OBJECT_HP_BASE;		
	}
	return true;
}

//ONE-TIME LIVE SERVER TREE UPGRADE
/*void _TreeUpgrade (Critter& player, int param0, int param1, int param2)
{
	for( int i = 0, j = TreeList.length() ; i < j; i++)
	{
		for ( int ii = 0, jj = TreeList[i].length() ; ii < jj; ii++)
		{
			array<Item@> worldTrees = array<Item@>();
			int count = GetAllItems(TreeList[i][ii], @worldTrees);
			for( int treeIndex = 0; treeIndex < count; treeIndex++ )
			{
				Item@ currentTree = worldTrees[treeIndex];
				currentTree.RESOURCE_CAPACITY = currentTree.RESOURCE_CAPACITY * 1000;
			}
		}
	}
}*/