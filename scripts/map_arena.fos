#ifndef MAP_ARENA
#define MAP_ARENA

#include "_defines.fos"
#include "_maps.fos"
#include "_itempid.fos"
#include "entire_h.fos"
#include "store.fos"
#include "playlist_h.fos"

void _ArenaMapInit( Map& map, bool firstTime )
{
	SetMapLoop( map, 0, "_CleanJunk", 10800000 );
    SetMapLoop( map, 1, "_SpawnItems", 1800000 );
    SetMapLoop( map, 2, "_PlayMapMusic", 300000 );
}

void SetMapLoop( Map@ map, int index, string& funcDecl, uint time )
{
    map.SetEvent( MAP_EVENT_LOOP_0 + index, funcDecl );
    map.SetLoopTime( index, time );
}

void _SpawnItems( Map& map )
{
	Item@[] containers;
    map.GetItemsByType( ITEM_TYPE_CONTAINER, containers );

    if( containers.length() > 0 )
    {
        for( uint16 i = 0; i < containers.length(); i++ )
        {
            if( !valid( containers[ i ] ) )
			{
				continue;
			}
			
			if( containers[ i ].Proto.Item_Subtype == ITEM_SUBTYPE_FURNITURE || containers[ i ].Proto.Item_Subtype == ITEM_SUBTYPE_PERSONAL_BAG )
			{
				continue;
			}

			bool iscontinue = false;
			Item@[] contItems;
			int j = containers[ i ].GetItems( 0, contItems );
			while( --j >= 0 )
			{
				if( contItems[ j ].IsNotValid )
				{
					iscontinue = true;
					break;
				}
			}
			
			if( iscontinue )
			{
				continue;
			}
			
			uint16 list = Random( 0, 6 );
			uint[] pids;
			
			switch( list )
			{
				case( 0 ):
					pids = itemlist[ 1 ]; //Mellee
					break;
				case( 1 ):
					pids = itemlist[ 2 ]; //Ammo and Thrown
					break;
				case( 2 ):
					pids = itemlist[ 4 ]; //Armour 3.0 Class
					break;
				case( 3 ):
					pids = itemlist[ 6 ]; //Food and Drugs
					break;
				case( 4 ):
					pids = itemlist[ 12 ]; //Small Guns
					break;
				case( 5 ):
					pids = itemlist[ 13 ]; //Big Guns
					break;
				case( 6 ):
					pids = itemlist[ 14 ]; //Energy Weapons
					break;
				default:
					pids = itemlist[ 2 ]; //Ammo and Thrown ( just in case )
					break;
			}
			
			uint16 itemPid = pids[ Random( 0, pids.length - 1 ) ];
			ProtoItem@ protoItem = GetProtoItem( itemPid );
			uint8 amount = 1;
			uint8 ammoAmount = 100;

			switch( protoItem.Type )
			{
				case( ITEM_TYPE_WEAPON ):
				{
					if( protoItem.Item_Subtype >= ITEM_SUBTYPE_WEAPON_GRENADE_BEGIN && protoItem.Item_Subtype <= ITEM_SUBTYPE_WEAPON_GRENADE_END )
					{
						amount = 10;
					}
					
					if( protoItem.Weapon_MaxAmmoCount > 0 && protoItem.Weapon_DefaultAmmoPid > 0 )
					{
						uint16 ammoPid = protoItem.Weapon_DefaultAmmoPid;
						switch( ammoPid )
						{
							case( PID_EXPLOSIVE_ROCKET ):
							case( PID_ROCKET_AP ):
							case( PID_GRENADELAUNCHER_AMMO ):
								ammoAmount = 10;
								break;
							case( PID_FLAMETHROWER_FUEL ):
							case( PID_FLAMETHROWER_FUEL_MK_II ):
								ammoAmount = 20;
								break;
							case( PID_MICRO_FUSION_CELL ):	
								ammoAmount = 50;
								break;
							default:
								ammoAmount = 100;
								break;
						}

						if( ammoPid != 0 )
						{
							containers[ i ].AddItem( ammoPid, ammoAmount, 0 );
						}
					}
					break;
				}
				case( ITEM_TYPE_AMMO ):
				{
					switch( itemPid )
					{
						case( PID_EXPLOSIVE_ROCKET ):
						case( PID_ROCKET_AP ):
						case( PID_GRENADELAUNCHER_AMMO ):
							amount = 10;
							break;
						case( PID_FLAMETHROWER_FUEL ):
						case( PID_FLAMETHROWER_FUEL_MK_II ):
							amount = 20;
							break;
						case( PID_MICRO_FUSION_CELL ):	
							amount = 50;
							break;
						default:
							amount = 100;
							break;
					}
					break;
				}
				case( ITEM_TYPE_DRUG ):
					amount = 5;
					break;
				default:
					amount = 1;
					break;
			}
			containers[ i ].AddItem( itemPid, amount, 0 );
        }
    }
}	

void _PlayMapMusic( Map& map )
{
	string music = "LAUGHTER.mp3";
	uint8 list = Random( 2, 2 );
	if( list == 0 )
	{
		music = FonlineMusic[ Random( 0, FonlineMusic.length() -1 ) ];
	}
	else if( list == 1 )
	{
		music = SuspenceMusic[ Random( 0, SuspenceMusic.length() -1 ) ];
	}
	else
	{
		music = NNMplaylist[ Random( 0, NNMplaylist.length() -1 ) ];
	}
	
	string path = "sound/music/"+music;
	PlayMapMusic( map, path );
}

void _CleanJunk( Map& map )
{
	Item@[] mapItems;
	for( uint i = 0; i < ITEM_TYPE_FLASK; i ++ )
	{
		if( i == ITEM_TYPE_CONTAINER || i == ITEM_TYPE_DOOR )
		{
			continue;
		}
		map.GetItemsByType( i, mapItems );
	}
	
	if( mapItems.length() > 0 )
	{
		for( uint i = 0; i < mapItems.length(); i++ )
		{
			Item@ deleted = mapItems[ i ];
			if( valid( deleted ) )
			{
				DeleteItem( deleted );
			}
		}
	}

	Item@[] containers;
    map.GetItemsByType( ITEM_TYPE_CONTAINER, containers );
	if( containers.length() > 0 )
	{
		Item@[] contItems;
		for( uint i = 0; i < containers.length(); i++ )
		{
			Item@ container = containers[ i ];
			if( valid( container ) )
			{
				container.GetItems( uint( -1 ), contItems );
				if( contItems.length() > 0 )
				{
					for( uint j = 0; j < contItems.length(); j++ )
					{
						Item@ deleted = contItems[ j ];
						if( valid( deleted ) )
						{
							DeleteItem( deleted );
						}
					}
					container.Update();
				}
			}
		}
	}
	_SpawnItems( map );
}

//~run map_arena _ForceArenaInit 0 0 0
void _ForceArenaInit( Critter& player, int param0, int param1, int param2 )
{
	Map@ map = player.GetMap();
	if( valid( map ) )
	{
		_CleanJunk( map );
		_PlayMapMusic( map );
	}
}

void PlayMapMusic( Map& map, string@ path )
{
	Critter@[] players;
    map.GetCritters( 0, FIND_ALL, players );
	for( uint i = 0; i < players.length(); i ++ )
	{
		Critter@ player = players[i];
		if( valid( player ) && !player.IsNpc() )
		{
			int timeStamp = GetTick();
			player.RunClientScript( "fofmod@__StopAll", 0, 0, 0, null, null );
			player.RunClientScript( "fofmod@__PlayMapMusic", map.Id, timeStamp, 0, path, null );
		}
	}
}

#endif // MAP_ARENA