#ifndef PLANTS_MODULE
#define PLANTS_MODULE

#include "_utils.fos"
#include "plants_h.fos"
#include "critter_skills_h.fos"

import bool CheckGard( Map& map, uint16 hexX, uint16 hexY ) from "qmap_farm";

class Plant
{
	uint16 pid;
	uint8 type;
	uint8 seedStage;
	uint8 gatheringStage;
	uint8 deathStage;
	int[] seed;
	int[] loot;
	
	Plant( uint16 pid, uint8 type, uint8 seedStage, uint8 gatheringStage, uint8 deathStage )
	{
		this.pid = pid;
        this.type = type;
        this.seedStage = seedStage;
		this.gatheringStage = gatheringStage;
		this.deathStage = deathStage;
	}
}

class PlantCollection
{
	Plant@[] plants;
	PlantCollection()
	{
	}
	
	PlantCollection@ cplant( uint16 pid, uint8 type, uint8 seedStage, uint8 gatheringStage, uint8 deathStage ) 
	{
		this.plants.insertLast( Plant( pid, type, seedStage, gatheringStage, deathStage ) );
		return this;
	}
	
	PlantCollection@ seed( int seed ) 
	{
		this.plants[ this.plants.length() - 1 ].seed.insertLast( seed );
		return this;
	}
	
	PlantCollection@ loot( int loot ) 
	{
		this.plants[ this.plants.length() - 1 ].loot.insertLast( loot );
		return this;
	}
  
  	PlantCollection@ get_by_type( uint8 type ) 
	{
		PlantCollection result;
		for( uint i=0, len = this.plants.length(); i < len; i++ )
		{
			if( this.plants[i].type == type )
			{
				result.plants.insertLast( this.plants[i] );
			}
		}
		return result;
	}

	Plant@ get_by_seed( uint16 seedPid ) 
	{
		for( uint i = 0, len = this.plants.length(); i < len; i++ )
		{
			if( this.plants[i].seed.find( seedPid ) != -1 )
			{
				return this.plants[i];
			}
		}
		return null;
	}
	
	Plant@ get_by_pid( uint16 pid ) 
	{
		for( uint i = 0, len = this.plants.length(); i < len; i++ )
		{
			if( this.plants[i].pid == pid )
			{
				return this.plants[i];
			}
		}
		return null;
	}	
}

PlantCollection@ plants = PlantCollection()
//					pid,							type, 			seedStage, gatheringStage, deathStage
    .cplant( PID_PLANT_RADCVET,					PLANT_TYPE_FARM, 		3,	 		4,			  5		)
		.seed( PID_PLANT_RADCVET_SEED )
		.loot( PID_PLANT_RADCVET_SEED )
		.loot( PID_RADCVET )
		.loot( PID_PLANT_RADCVET_DEAD )
    .cplant( PID_PLANT_CABBAGE,					PLANT_TYPE_FARM, 		1,	 		3,			  4		)
		.seed( PID_PLANT_CABBAGE_SEED )
		.loot( PID_PLANT_CABBAGE_SEED )
		.loot( PID_CABBAGE )
		.loot( PID_PLANT_CABBAGE_DEAD )
    .cplant( PID_PLANT_FIVELEAF,				PLANT_TYPE_FARM, 		2,	 		3,			  4		)
		.seed( PID_PLANT_FIVELEAF_SEED )
		.loot( PID_PLANT_FIVELEAF_SEED )
		.loot( PID_FIVELEAF )
		.loot( PID_PLANT_FIVELEAF_DEAD )
	.cplant( PID_PLANT_CORN,					PLANT_TYPE_FARM, 		2,	 		3,			  4		)
		.seed( PID_PLANT_CORN_SEED )
		.loot( PID_PLANT_CORN_SEED )
		.loot( PID_CORN )
		.loot( PID_PLANT_CORN_DEAD )	
	.cplant( PID_HYDRO_NS_CORN,					PLANT_TYPE_HYDRO, 		2,	 		3,			  4		)
		.seed( PID_PLANT_CORN_SEED )
		.loot( PID_PLANT_CORN_SEED )
		.loot( PID_CORN )
		.loot( PID_PLANT_CORN_DEAD )
	.cplant( PID_HYDRO_EW_CORN,					PLANT_TYPE_HYDRO, 		2,	 		3,			  4		)
		.seed( PID_PLANT_CORN_SEED )
		.loot( PID_PLANT_CORN_SEED )
		.loot( PID_CORN )
		.loot( PID_PLANT_CORN_DEAD )
	.cplant( PID_HYDRO_NS_CAB,					PLANT_TYPE_HYDRO, 		1,	 		3,			  4		)
		.seed( PID_PLANT_CABBAGE_SEED )
		.loot( PID_PLANT_CABBAGE_SEED )
		.loot( PID_CABBAGE )
		.loot( PID_PLANT_CABBAGE_DEAD )	
	.cplant( PID_HYDRO_EW_CAB,					PLANT_TYPE_HYDRO, 		1,	 		3,			  4		)
		.seed( PID_PLANT_CABBAGE_SEED )
		.loot( PID_PLANT_CABBAGE_SEED )
		.loot( PID_CABBAGE )
		.loot( PID_PLANT_CABBAGE_DEAD )	
	.cplant( PID_MUSHBED_PALE,					PLANT_TYPE_MUSHBED, 	0,	 		3,			  0		)
		.seed( PID_SEEDLING_TONGUE_GECKO )
		.seed( PID_RISING_TONGUE_GECKO )
		.seed( PID_TONGUE_GECKO )
		.loot( PID_SEEDLING_TONGUE_GECKO )
		.loot( PID_RISING_TONGUE_GECKO )
		.loot( PID_TONGUE_GECKO )
	.cplant( PID_MUSHBED_BLACK,					PLANT_TYPE_MUSHBED, 	0,	 		3,			  0		)
		.seed( PID_SEEDLING_BLACK_MUSHROOMS )
		.seed( PID_RISING_BLACK_MUSHROOMS )
		.seed( PID_BLACK_MUSHROOMS )
		.loot( PID_SEEDLING_BLACK_MUSHROOMS )
		.loot( PID_RISING_BLACK_MUSHROOMS )
		.loot( PID_BLACK_MUSHROOMS )
	.cplant( PID_MUSHBED_GECKO,					PLANT_TYPE_MUSHBED, 	0,	 		3,			  0		)
		.seed( PID_SEEDLING_TONGUE_GECKO )
		.seed( PID_RISING_TONGUE_GECKO )
		.seed( PID_TONGUE_GECKO )
		.loot( PID_SEEDLING_TONGUE_GECKO )
		.loot( PID_RISING_TONGUE_GECKO )
		.loot( PID_TONGUE_GECKO )
	.cplant( PID_MUSHBED_ANT,					PLANT_TYPE_MUSHBED, 	0,	 		3,			  0		)
		.seed( PID_SEEDLING_MURAVNIKTAR )
		.seed( PID_RISING_MURAVNIKTAR )
		.seed( PID_MURAVNIKTAR )
		.loot( PID_SEEDLING_MURAVNIKTAR )
		.loot( PID_RISING_MURAVNIKTAR )
		.loot( PID_MURAVNIKTAR )
	.cplant( PID_MUSHBED_MUT,					PLANT_TYPE_MUSHBED, 	0,	 		3,			  0		)
		.seed( PID_SEEDLING_MUTMUSH )
		.seed( PID_PID_RISING_MUTMUSH )
		.seed( PID_MUTMUSH )
		.loot( PID_SEEDLING_MUTMUSH )
		.loot( PID_PID_RISING_MUTMUSH )
		.loot( PID_MUTMUSH )
	;

Plant@ GetByPid( Item@ item )
{
    uint16 Pid = item.GetProtoId();
    return plants.get_by_pid( Pid );
}

Plant@ GetPlant( Item@ seed, bool isFarm ) 
{
	bool isMushroom = ( mushbed_seeds.find( seed.GetProtoId() ) != -1 );
	uint8 type = isFarm ? PLANT_TYPE_FARM : ( isMushroom ? PLANT_TYPE_MUSHBED : PLANT_TYPE_HYDRO );
	return plants.get_by_type( type ).get_by_seed( seed.GetProtoId() );
}

void TryPlantSeed( Critter& cr, Item& seed, int hexX, int hexY, Item@ plant_bed ) 
{
	bool isFarm = true;
	Map@ map = cr.GetMap();
	if( !valid( map ) )
	{
		return;
	}

	if( valid( plant_bed ) )
	{
		isFarm = false;
	}
	
	Plant@ plant = GetPlant( seed, isFarm );
	Log( "type: " + plant.type );
	if( !valid( plant ) ) 
	{
		cr.Say( SAY_NETMSG, "|0xFFFF00 You can't plant this!" );
		return;
	}

	if( plant.type == PLANT_TYPE_FARM )
	{
		if( GetDistantion( cr.HexX, cr.HexY, hexX, hexY ) > 1 )
		{
			cr.Say( SAY_NETMSG, "|0xFFFF00 You are too far from a plant bed." );
			return;
		}

		if( CheckGard( map, hexX, hexY ) )
		{
			PlantSeed( cr, seed, hexX, hexY );
		}
		else
		{
			cr.Say( SAY_NETMSG, "|0xFFFF00 You need to plant it in some good soil." );
		}
	}
	else if( plant.type == PLANT_TYPE_HYDRO )
	{
		if( PlantHydro( cr, seed, plant_bed ) )
		{
			cr.Say( SAY_NETMSG, "|0xFFFF00 Planting Hydro" );
		}
		else
		{
			cr.Say( SAY_NETMSG, "|0xFFFF00 You need to plant it on a hydroponics farm." );
		}
	}
	else if( plant.type == PLANT_TYPE_MUSHBED )
	{
		if( PlantMushroom( cr, seed, plant_bed ) )
		{
			cr.Say( SAY_NETMSG, "|0xFFFF00 Planting Mushroom" );
		}
		else
		{
			cr.Say( SAY_NETMSG, "|0xFFFF00 You need to plant it in a mushroom bed." );
		}
	}
}

void PlantSeed( Critter& cr, Item& seed, int hexX, int hexY )
{
	Map@ map = cr.GetMap();	
	MoveItem( seed, 1, map, hexX, hexY );
	cr.Say( SAY_NETMSG, "|0xFFFF00 Planting Seed" );
}

bool PlantHydro( Critter& cr, Item& seed, Item& plant_bed )
{
	return true;
}

bool PlantMushroom( Critter& cr, Item& seed, Item& plant_bed )
{
	return true;
}

void StartMenuPlant( Critter& cr, Item& plant )
{
    Map@ map = cr.GetMap();
    if( map is null )
	{
        return;
    }

    iMenuHandler@ handler = MenuPlant( plant, map );
    iDialogBox@ menu = OpenMenu( cr, "", handler );
}

class MenuPlant: CenteredMenuHandler 
{
    uint plant_id;
    uint map_id;
	
    MenuPlant ( Item& plant, Map& map )
	{
        plant_id = plant.Id;
        map_id = map.Id;
    }

    bool MenuUpdate( Critter& cr, iDialogBox& menu )
	{
        Map@ map = GetMap( map_id );
        Item@ plant = GetItem( plant_id );
	
		if( plant.WATERING <= 0 )
		{
			if( menu.Button( "Water" ) )
			{
				return true;
			}
		}
		
		if( plant.FERTILITY <= 0 )
		{
			if( menu.Button( "Fertilize" ) )
			{
				return true;
			}	
		}
			
		if( menu.Button( "Gather" ) )
		{
			return false;
		}	
		
		return true;
    }
	
    string@ Description( Critter& cr )
	{
	
		string info = "Text";
        return info;
    }
	
    string@ ButtonCancel()
	{
        return ButtonDecorator( "Close Menu", null );
    }
}

void tryRaiseSkill( Critter& cr )
{
	if( Random( 1, 10 ) == 10 )
	{
		int skillNum = SK_FARMING;
		raiseSkill( cr, skillNum );
	}
}

void IncreaseCrop( Item& plant, int amount )
{
	for( int i = 0; i < amount ; i++ )
	{
		if( Random( 0, 1 ) == 1 )
		{
			plant.RESOURCE_CAPACITY ++;
		}
	}
}

#endif // PLANTS_MODULE

/*
class Mushroom: GenericPlant
{
	GenericPlant@ implant_seed() 
	{
		return this;
	}
}






/*
public interface IGameState
{
	public DateTimeOffset GameTime { get; }
}

public interface ICultivatable
{
	CultivationAction[] GetAvailableActions(IGameState state);
	object[] Act(CultivationAction action, IGameState state);
}

public enum CultivationAction
{
	Water,
	Gather,
	Fertilize,
}

/// <summary>
///   Ёто вкор€чиваетс€ в класс самого растени€, хз как у вас это делаетс€
/// </summary>
public class CultivatablePartMixinAttachedShit : ICultivatable
{
	// вот эти 2 пол€ надо как-то проинициализировать, в зависимости от механизма наследовани€/аттача итп
	private CultivationStage _currentStage;
	private DateTimeOffset _lastChange;

	public CultivationAction[] GetAvailableActions(IGameState state) =>
		_currentStage.GetAvailableActions(state, _lastChange);
	public object[] Act(CultivationAction action, IGameState state)
	{
		var result = _currentStage.Next(action, state, _lastChange);
		_currentStage = result.NewStage;
		return result.Items;
	}
}




public sealed class CultivationActionResult
{
	/// <summary>
	///   если при действии что-то выблевалось
	/// </summary>
	public object[] Items { get; set; }

	public CultivationStage NewStage { get; set; }
}

public class CultivationStage
{

	public CultivationStageTransition[] Transitions { get; set; }
	// вместо этого впили что тебе надо знать о стадии, ключи какие итп
	public string Description { get; set; }


	public CultivationAction[] GetAvailableActions(IGameState state, DateTimeOffset lastChange) =>
		Transitions.Where((transition) => state.GameTime + transition.Delay <= lastChange)
			.Select(transition => transition.Action)
			.ToArray();

	public CultivationActionResult Next(CultivationAction action, IGameState state, DateTimeOffset lastChange)
	{
		var effective = Transitions
			.FirstOrDefault((transition) =>
				transition.Action == action && state.GameTime + transition.Delay <= lastChange);
		if (effective == null)
			throw new InvalidOperationException("...");
		return new CultivationActionResult()
		{
			NewStage = effective.NewStage,
			Items = effective.CreateItems(state, lastChange)
		};
	}

}

public class CultivationStageTransition
{
	public CultivationStage NewStage { get; set; }
	public CultivationAction Action { get; set; }
	/// <summary>
	///     врем€, которое должно пройти после смены состо€ни€ на текущее, чтобы этот транзишн работал (например: ждать 3 дн€ после полива чтоб ещЄ полить)
	/// </summary>
	public TimeSpan Delay { get; set; } = TimeSpan.Zero;

	public virtual object[] CreateItems(IGameState state, DateTimeOffset lastChange)
	// + параметры состо€ни€, родительский объект, если надо итп
	{
		return null;
	}
}

/// <summary>
///     это пример создани€ объекта стадии, с которой всЄ начинаетс€.
///     делать это в статическом классе “ј ќЁ, € хз какой у вас там  DI, переделай под него
/// </summary>
public static class CultivationStages
{
	public static readonly CultivationStage[] Roots;

	static CultivationStages()
	{
		var roots = new List<CultivationStage>();

		// в обратном пор€дке
		var deadBerry = new CultivationStage()
		{
			Transitions = new CultivationStageTransition[0],
			Description = "Dead."
		};
		var fruitingBerry = new CultivationStage()
		{
			Transitions = new CultivationStageTransition[]
			{
				new BerryGatheringTransition()
				{
					Action = CultivationAction.Gather,
					Delay = TimeSpan.FromDays(3),
					NewStage = deadBerry
				},
			},
			Description = "Fruiting"
		};
		var newBerry = new CultivationStage()
		{
			Transitions = new CultivationStageTransition[]
			{
				new CultivationStageTransition()
				{
					Action = CultivationAction.Water,
					NewStage = fruitingBerry,
				}
			},
			Description = "Small plant"
		};

		roots.Add(newBerry);

		// ... 

		Roots = roots.ToArray();

	}
}

public class BerryGatheringTransition : CultivationStageTransition
{
	public override object[] CreateItems(IGameState state, DateTimeOffset lastChange)
	{
		// тут определ€ешь что нужно выблевать
		return new object[] { "Berry1", "Berry2" };
	}
}

*/