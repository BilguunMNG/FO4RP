/* ТЗ
 *
 * система чек поинтов
 *      поиск ближайшего
 *      связки чекпоинтов
 *
 * стаи
 *      спаун стаи
 *      перемещение стаи
 *      переход по локациям
 *      поиск нового лидера
 *      войны разных типов мобов
 *      ночные \ дневные мобы
 *
 * лидер
 *      тип поведения
 *      динамическое количество миньонов
 *
 *
 *
 * тех инфо
 *
 * чекпоинт -   value 0-3 установки перемещения
 *              value 4-5 id следущей точки
 *              //trapValue - тип моба
 *
 * лидер    -	cr.StatBase[ST_VAR9] - critterGroup
 *              cr.StatBase[ST_VAR8] - index
 *
 *
 *
 *
 *
 *
 */


/*		CHECKPOINTS		*/

#include "_macros.fos"
//#include "npc_planes.fos"

#define         ITEM_CHECKPOINT     ( 3 )
#define         MAX_MINION_COUNT    ( 5 )
#define         LVAR_MINION_ID      ( LVAR_MinionId0 )

void SetCheckPointPath( Item& item, uint8 index, uint16  value )
{
    if( index >= 0 && index < 4 )
        switch( index )
        {
        case 0:
            item.Val0 = value;
            break;
        case 1:
            item.Val1 = value;
            break;
        case 2:
            item.Val2 = value;
            break;
        case 3:
            item.Val3 = value;
            break;

        default:
            break;
        }
}

void SetCheckPointCritters( Item& item, uint8 index, uint16  critterGroup )
{
    if( index >= 0 && index < 4 )
    {
        uint16 path0 = ( item.Val4 ) & 0xFFFF,
               path1 = ( item.Val4 >> 16 ) & 0xFFFF,
               path2 = ( item.Val5 ) & 0xFFFF,
               path3 = ( item.Val5 >> 16 ) & 0xFFFF,
               pathTemp = 0;

        switch( index )
        {
        case 0:
            !FLAG( path0, critterGroup ) ? SETFLAG( path0, critterGroup ) : UNSETFLAG( path0, critterGroup );
            break;
        case 1:
            !FLAG( path1, critterGroup ) ? SETFLAG( path1, critterGroup ) : UNSETFLAG( path1, critterGroup );
            break;
        case 2:
            !FLAG( path2, critterGroup ) ? SETFLAG( path2, critterGroup ) : UNSETFLAG( path2, critterGroup );
            break;
        case 3:
            !FLAG( path3, critterGroup ) ? SETFLAG( path3, critterGroup ) : UNSETFLAG( path3, critterGroup );
            break;
        default:
            break;
        }

        item.Val4 = ( ( path0 ) & 0xFFFF ) | ( ( path1 << 16 ) & 0xFFFF );
        item.Val5 = ( ( path2 ) & 0xFFFF ) | ( ( path3 << 16 ) & 0xFFFF );
    }
}

bool CheckCritterTypeCheckPoint( Item& item, uint8 index, uint16 critterGroup )
{
    if( index >= 0 && index < 4 )
    {
        uint16 path0 = ( item.Val4 ) & 0xFFFF,
               path1 = ( item.Val4 >> 16 ) & 0xFFFF,
               path2 = ( item.Val5 ) & 0xFFFF,
               path3 = ( item.Val5 >> 16 ) & 0xFFFF,
               pathTemp = 0;

        switch( index )
        {
        case 0:
            pathTemp = path0;
            break;
        case 1:
            pathTemp = path1;
            break;
        case 2:
            pathTemp = path2;
            break;
        case 3:
            pathTemp = path3;
            break;
        default:
            return false;
        }

        /*bool temp = */ if( FLAG( pathTemp, critterGroup ) || pathTemp == 0 )
            return true;
        // temp ? return true : return false;
    }

    return false;
}

Item@ FindNearesCheckPoint( Critter& cr )
{
    uint16 hexX = 0, hexY = 0;

    Item@  checkpoint;
    Item@[] @ points;
    Map@map = cr.GetMap();

    if( map is null )
    {
        cr.Say( SAY_NORM, "map is null" );
        return null;
    }

    cr.Say( SAY_NORM, "" + map.GetItems( ITEM_CHECKPOINT, points ) /*+" "+points[0].GetProtoId()*/ );

    if( points[ 0 ] is null )
    {
        cr.Say( SAY_NORM, "points is null" );
        return null;
    }

    for( uint16 i = 0; i < points.length(); ++i )
    {
        if( points[ i ] !is null )
        {
            int hexXTemp = ABS( points[ i ].HexX - cr.HexX ), hexYTemp = ABS( points[ i ].HexY - cr.HexY );
            if( ( hexX <  hexXTemp && hexY < hexYTemp ) && CheckCritterTypeCheckPoint( points[ i ], cr.StatBase[ ST_VAR8 ], cr.StatBase[ ST_VAR9 ] ) )
            {
                hexX = hexXTemp;
                hexY = hexYTemp;

                @checkpoint = points[ i ];
            }
        }
    }
    /*
       @checkpoint = map.GetItem(hexX, hexY, ITEM_CHECKPOINT);
       return @checkpoint;*/

    return null;
}

/*      TOOLS	*/

void AddCheckPoint( Critter& cr, int index, int hexX, int hexY )
{
    Item @ item = cr.GetMap().AddItem( ( hexX > 0 ? hexX : cr.HexX ), ( hexY > 0 ? hexY : cr.HexY ), ITEM_CHECKPOINT, 1 );
    if( item !is null )
    {
        SetCheckPointPath( item, index, cr.StatBase[ ST_VAR8 ] );
        cr.StatBase[ ST_VAR8 ] = item.Id;
    }
}

void EditLastCheckPoint( Critter& cr, int type, int index, int value )
{
    Item @ item = GetItem( cr.StatBase[ ST_VAR0 ] );
    if( item !is null )
    {
        if( type > 0 )
            SetCheckPointCritters( item, index, value );
        else
            SetCheckPointPath( item, index, value );
    }
}




/*		CRITTERS		*/


void _LeaderInit( Critter& npc, bool firstTime )
{
    npc.SetEvent( CRITTER_EVENT_IDLE,        "_Patrol" );
}

void _Patrol( Critter& npc )
{
    Item @ item = FindNearesCheckPoint( npc );
    if( item !is null )
    {
        SetCritterMove( npc, item.HexX, item.HexY );
    }
}

import bool AddWalkPlane( Critter& npc, uint priority, uint16 hexX, uint16 hexY, uint8 dir, bool run, uint cut ) from "npc_planes";

void SetCritterMove( Critter& leader, uint16 hexX, uint16 hexY )
{
    GameVar @ minionId;

    for( uint8 i = 0; i < MAX_MINION_COUNT; ++i )
    {
        @minionId = GetLocalVar( LVAR_MINION_ID + i, leader.Id );
        Critter @ minion = GetCritter( minionId.GetValue() );
        if( minion !is null )
        {
            AddWalkPlane( minion, 10, hexX, hexY, Random( 0, 5 ), false, 0 );
        }
    }
}

void SetLeaderMinion( Critter& leader, Critter& minion )
{
    GameVar @ minionId;

    for( uint8 i = 0; i < MAX_MINION_COUNT; ++i )
    {
        @minionId = GetLocalVar( LVAR_MINION_ID + i, leader.Id );
        if( minionId.GetValue() == 0 && minionId.GetValue() != int( minion.Id ) )
            minionId = minion.Id;
    }
}


/*		DEBUG		*/
void test( Critter& cr, int pointsCount, int mobCout, int radius )
{
    for( uint8 i = 0; i < pointsCount; ++i )
    {
        uint16 hexX = cr.HexX + Random( radius - ( radius * radius ), radius ), hexY = cr.HexY + Random( radius - ( radius * radius ), radius );

        AddCheckPoint( cr, 0, hexX, hexY );

        Critter @ leader = cr.GetMap().AddNpc( 64, hexX + Random( 0, 4 ), hexY + Random( 0, 4 ), Random( 0, 5 ), null, null, null );
        if( leader is null )
        {
            cr.Say( SAY_NORM, "null leader" );
            continue;
        }
        leader.SetScript( "livemobs@_LeaderInit" );
        for( uint8 i = 0; i < MAX_MINION_COUNT; ++i )
        {
            Critter @ minion = cr.GetMap().AddNpc( 63, hexX + Random( 0, 4 ), hexY + Random( 0, 4 ), Random( 0, 5 ), null, null, null );
            SetLeaderMinion( leader, minion );
        }
    }
}

void test1( Critter& cr, int pointsCount, int mobCout, int radius )
{
    for( uint8 i = 0; i < pointsCount; ++i )
    {
        uint16 hexX = cr.HexX + Random( radius - ( radius * radius ), radius ), hexY = cr.HexY + Random( radius - ( radius * radius ), radius );

        AddCheckPoint( cr, 0, hexX, hexY );
    }
}

void test2( Critter& cr, int pointsCount, int mobCout, int radius )
{
    Item @ item = FindNearesCheckPoint( cr );
}
