#include "_utils.fos"

#ifndef __ACTIONS
#define __ACTIONS

class Action
{
	int skill;
	
	Critter@ cr;
	Critter@ targetCr;
	Item@ targetItem;
	Scenery@ targetScen;
	
	Action( Critter& cr, int skill, Critter@ targetCr, Item@ targetItem, Scenery@ targetScen )
	{
		this.skill = skill;
		
		@this.cr = @cr;
		@this.targetCr = @targetCr;
		@this.targetItem = @targetItem;
		@this.targetScen = @targetScen;
	}
}
#endif

#ifndef __CHECKS
#define __CHECKS

//import bool ComfirmedAction( Critter& cr, int skill, Critter@ targetCr, Item@ targetItem, Scenery@ targetScen ) from "actions";
bool ComfirmedAction( Critter& cr, int skill, Critter@ targetCr, Item@ targetItem, Scenery@ targetScen )
{
	Action action = Action( cr, skill, targetCr, targetItem, targetScen );
	
	for( uint i = 0, l = Demands.list.length(); i < l; i++ )
		if( Demands.list[i].check( action ) )
			return true;
		
	return false;
}

CheckList Demands;
class CheckList
{
	Check@[] list;
	
	CheckList()
	{
		list.insertLast( Check_MedSkills() );
	}
}

funcdef bool State( Action@ action );

class Check
{
	Check@[] subchecks;
	State@[] statements;
	
	Check() 
	{ 
		skippable = false;
		final = false;

		init(); 
	}
	
	void init() {} //override
	
	bool skippable;
	Check@ setSkippable( bool state ) { skippable = state; return this; }
	
	bool final;
	Check@ setFinal( bool state ) { final = state; return this; }
	
	void Add( Check@ subcheck ) { subchecks.insertLast( subcheck ); }
	void Add( State@ statement ) { statements.insertLast( statement ); }	
	
	bool check( Action@ action )
	{
		for( uint i = 0, l = subchecks.length(); i < l; i++ )
		{
			bool result = subchecks[i].check(action);
			if( result )
			{
				if( subchecks[i].final )
					return true;
			}
			else
			{
				if( !subchecks[i].skippable )
					return false;
			}
		}
			
		return ok(action);
	}

	bool ok( Action@ action )
	{
		for( uint i = 0, l = statements.length(); i < l; i++ )
		{
			//if( !valid( statements[i] ) ) continue;
			
			State@ state = statements[i];
			if( !state(action) )
				return fail(action);
		}
			
		return success(action);
	}

	bool success( Action@ action ) //override
	{
		return true;
	}

	bool fail( Action@ action ) //override
	{
		return false;
	}
}

class CheckFinalPoint : Check
{
	CheckFinalPoint()
	{
		final = true;
		skippable = true;
		
		init(); 
	}
}

bool HasTimeout( Action@ action ){ return action.cr.Timeout[ skillTimeout( action.skill ) ] > 0; }
bool NoTimeout( Action@ action ){ return !HasTimeout( action ); }

uint skillTimeout( uint skill )
{
	switch( skill ) {
		case( SK_FIRST_AID ): return TO_SK_FIRST_AID;
		case( SK_DOCTOR ): 	  return TO_SK_DOCTOR;
		case( SK_REPAIR ): 	  return TO_SK_REPAIR;
		case( SK_SCIENCE ):   return TO_SK_SCIENCE;
		case( SK_LOCKPICK ):  return TO_SK_LOCKPICK;
		case( SK_STEAL ):     return TO_SK_STEAL;
	}
	
	return TO_TIREDNESS;
}

class Check_Timeout : Check
{
	void init() override
	{
		Add( NoTimeout );
	}
	
	bool fail( Action@ action ) override
	{
		action.cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SKILL_WEARINESS );
		return false;
	}
}

bool TargetSelf( Action@ action )
{
	if( !valid( action.targetCr ) )
		@action.targetCr = @action.cr;
	return true;
}

bool TargetCritter( Action@ action ) { return valid( action.targetCr ) && !valid( action.targetItem ) && !valid( action.targetScen ); }

class Check_TargetExists : Check
{
	void init() override
	{
		Add( TargetSelf );
		Add( TargetCritter );
	}

	bool fail( Action@ action ) override
	{
		action.cr.Say( SAY_NETMSG, "Используйте навык на существо." );
		return false;
	}
}

bool TargetDead( Action@ action )    { return valid( action.targetCr ) && action.targetCr.IsDead(); }
bool TargetNotDead( Action@ action )    { return !TargetDead( action ); }

class Check_TargetDead : Check
{
	void init() override
	{
		Add( Check_TargetExists() );
		Add( TargetNotDead );
	}

	bool fail( Action@ action ) override
	{
		action.cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SKILL_NORESSURECT );
		return false;
	}
}

bool TargetRobot( Action@ action )   { return valid( action.targetCr ) && action.targetCr.Stat[ ST_BODY_TYPE ] == BT_ROBOT; }
bool TargetNotRobot( Action@ action )   { return !TargetRobot( action ); }

class Check_TargetOrganic : Check
{
	void init() override
	{
		Add( Check_TargetDead() );
		Add( TargetNotRobot );
	}

	bool fail( Action@ action ) override
	{
		action.cr.Say( SAY_NETMSG, "Цель - робот." );
		return false;
	}
}

bool CheckBrahminPregnancy( Critter& cr, Critter@ target )
{
	cr.Say( SAY_NETMSG, "Вы проверяете состояние самки брамина:" );

	uint[] index;
	uint[] duration;
	uint[] rate;

	uint count = target.GetTimeEvents( CTE_BRAHMIN_PREGNANCY, index, duration, rate );
	if( count > 0 )
	{
		for( uint j = 0; j < count; j++ )
		{
			string time = DeltaTime_HMS( duration[j] / __TimeMultiplier );
			cr.Say( SAY_NETMSG, "Она разродится через " + time + "." );
		}
	}
	else
	{
		cr.Say( SAY_NETMSG, "Она не беременна." );
	}
	
	return true;
}

bool TargetFemale( Action@ action )  { return valid( action.targetCr ) && action.targetCr.Stat[ST_GENDER] == GENDER_FEMALE; }
bool TargetBrahmin( Action@ action ) { return valid( action.targetCr ) && action.targetCr.Stat[ST_BASE_CRTYPE] == CRTYPE_BRAMIN; }
bool TargetNPC( Action@ action )     { return valid( action.targetCr ) && action.targetCr.IsNpc(); }

class Check_Brahmin_Pregnancy : CheckFinalPoint
{
	void init() override
	{
		Add( TargetFemale );
		Add( TargetBrahmin );
		Add( TargetNPC );
	}

	bool success( Action@ action ) override
	{
		CheckBrahminPregnancy( action.cr, action.targetCr );

		return true;
	}
}

import bool ProccessDoctorSkill( Critter& cr, Critter& targetCr, bool alreadyAllowed ) from "heal";

class Check_Doctor : CheckFinalPoint
{
	bool success( Action@ action ) override
	{
		return action.skill == SK_DOCTOR && ProccessDoctorSkill( action.cr, action.targetCr, false );
	}
}


import bool ProccessFirstAidSkill( Critter& cr, Critter& targetCr, bool alreadyAllowed ) from "heal"; // pm added

class Check_FirstAid : CheckFinalPoint
{
	bool success( Action@ action ) override
	{
		return action.skill == SK_FIRST_AID && ProccessFirstAidSkill( action.cr, action.targetCr, false );
	}
}

bool UsedMedSkills( Action@ action )
{ 
	uint[] proper_skills = { SK_DOCTOR, SK_FIRST_AID };
	return proper_skills.find( action.skill ) != -1;
}

class Check_UsedMedSkills : Check
{
	void init() override
	{
		Add( UsedMedSkills );		
	}
}

class Check_MedSkills : CheckFinalPoint
{
	void init() override
	{
		Add( Check_UsedMedSkills() );
	
		Add( Check_Timeout() );
		Add( Check_TargetOrganic() );
		
		Add( Check_FirstAid() );
		Add( Check_Brahmin_Pregnancy() );
		Add( Check_Doctor() );
	}
}
#endif